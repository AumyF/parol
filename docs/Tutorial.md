# Tutorial

This tutorial will help new users to get quickly familiar with the tool `parol`.
To get something useful we need a goal that is not too complicated but covers the most steps to be
able to use `parol` in real-world projects.

How about a BASIC interpreter? Maybe you remember the old C64 with its BASIC V2.0?

I decided to re-implement a small part of this BASIC dialect for this tutorial.
You may ask, why to choose a forty years old language? I say, why not? Because we can and because it's fun. üòâ

## Prerequisites

First we need to install `parol`:

```shell
cargo install parol
```

Having this completed we can take advantage of the `parol new` subcommand and let `parol` create our
new test project for us.

Change your working directory to where the new project should be created in a subfolder.

```shell
parol new --bin --path ./basic
```

Then change into the new project folder and start the initial build. Here parol is already
generating two files from the initial grammar definition.

```shell
cd ./basic
cargo build
```

If this is completed open your favorite editor.

```shell
code .
```

>One side note about your favorite editor. If it happens that you use Visual Studio Code you can
install my VS Code extension [parol-vscode](https://github.com/jsinger67/parol-vscode.git).
Download the vsix package from the latest release and install it with
>
>> ```code --install-extension ./parol-vscode-0.1.2.vsix```
>
>This extension provides syntax highlighting, folding and language icons and will surely be useful for you.

## Initial commit

Before we change anything in the new project please do the initial commit in git now.

## Project structure

You should see the following project structure:

```text
‚îÄ src ‚îÄ‚îê
       ‚îú‚îÄ basic_grammar_trait.rs
       ‚îú‚îÄ basic_grammar.rs
       ‚îú‚îÄ basic_parser.rs
       ‚îî‚îÄ main.rs
‚îÄ .gitignore
‚îÄ basic-exp.par
‚îÄ basic.par
‚îÄ build.rs
‚îÄ Cargo.lock
‚îÄ Cargo.toml
```

Some of them are the usual constituent parts of a rust project, such as Cargo.toml, Cargo.lock etc.

We are more interested in the parts that are specific for a `parol` project.

### The grammar description file `basic.par`

This file is the initial grammar description file that parol has created for us.
Or grammar will be developed here later on.

### The expanded grammar description file `basic-exp.par`

This file was derived from the `basic.par` by parol. It is actually a equivalent transformation of
our original grammar definition. This transformation is optimized for LL parsing. Normally we seldom
need to look at it.

### The build script `build.rs`

This file contains the build instructions for parol to generate the necessary output files from the
file `basic.par` during cargo build.

### The main module `src/main.rs`

Here we have our usual main function where we call the generated parser and feed it with a text file
that was given as command line argument. We will provide our basic files here later.

### The parser module `src/basic_parser.rs`

This is the generated parser module. Actually it contains data the LLKParser from the `parol_runtime`
crate is initialized with. We actually don't need to understand all the internals of it.

### The module with the grammar trait `src/basic_grammar_trait.rs`

This is also a generated file that receives a special-made trait `BasicGrammarTrait` whit default
implementations of our semantic actions. We will later look into it in more detail.

### The grammar implementation module `src/basic_grammar.rs`

Here we will actually do our coding and will develop out Basic interpreter in the course of this
tutorial.

## The BASIC grammar we want to support

We will of course not be able to implement the whole BASIC language in this tutorial so we need to
select a useful subset.

We will support the following language elements:

* Comments with REM
* Numeric constants (integer and float)
* Floating point variables
* Statements
  * IF THEN
  * IF GOTO
  * GOTO
  * Assignments
* Expressions
  * Arithmetic expressions with Addition, Subtraction, Multiplication and Division as well as using parenthesis
  * Comparison expressions
* BASIC commands
  * PRINT/?
  * STOP

### The structure of a BASIC program

We will first hav a look at the basic structure of any BASIC program.

It is a list of lines:

```ebnf
Basic  : { Line }
       ;
```

In turn a line is a list of statements:

```ebnf
Line   : LineNumber Statement { ":" Statement } EndOfLine
       ;
```

And we start with the simplest statement: the REM statement:

```ebnf
Statement
       : "REM" Comment EndOfLine
       ;
```

I will give here the complete content of the `basic.par` at this stage of development:

```ebnf
%start Basic
%title "Basic grammar"
%comment "Empty grammar generated by `parol`"
%auto_newline_off

%%

Basic   : [EndOfLine] Line { EndOfLine Line } [EndOfLine]
        ;
Line    : LineNumber Statement { ":" Statement }
        ;
Statement
        : "REM" [Comment]
        ;
LineNumber
        : "0|[1-9][0-9]{0,4}"
        ;
EndOfLine
        : "(\r?\n|\r)+"
        ;
Comment : "[^\r\n]+"
        ;
```

Some details like the handling of new lines we will explain later (because we are in the 21st
century now we additionally allow empty lines).

Just let us come quickly up and running.

Now we can build our new BASIC interpreter with

```shell
cargo build
```

And we write a little BASIC program that we should be able to parse now.

`test.bas`:

```basic
10 REM
20 REM Hello
30 REM World!
```

```shell
cargo run --release  -- ./test.bas
   Compiling basic v0.1.0 ...
Parsing took 1 milliseconds.
Success!
No parse result
```

Wow, very impressive! We can parse BASIC just out of the box only by defining some lines in the
`basic.par` grammar description. No code had to be written by us until now.

Here you can see one of the principles in parol. Grammar definition and grammar processing are kept
separate to be able to develop both sides independently of each other.

Also `parol` works by default as acceptor, i.e. if you don't do any language processing, we can
still evaluate the correctness of the grammar description.

We can build a little error in our `test.bas` to test the error detection:

```basic
10 REM
20 
30 REM World!
```

```shell
cargo run  -- .\test.bas 
```

You should see errors reported by `parol` now.

```text
Error: parol_runtime::parser::syntax_error

  √ó Failed parsing file .\test.bas
  ‚ï∞‚îÄ‚ñ∂ Found "'\r\n'(EndOfLine) at .\test.bas:2:4"
      Current scanner is INITIAL
      Current production is:
      /* 11 */ Statement: "REM" StatementSuffix;
      Expecting one of REM
  help: Syntax error in input prevents prediction of next production

Error: parol_runtime::unexpected_token

  √ó Unexpected token: LA(1) (EndOfLine)
   ‚ï≠‚îÄ[.\test.bas:1:1]
 1 ‚îÇ 10 REM
 2 ‚îÇ 20
   ¬∑    ‚îÄ‚î¨
   ¬∑     ‚ï∞‚îÄ‚îÄ Unexpected token
 3 ‚îÇ 30 REM World!
   ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ
  help: Unexpected token

error: process didn't exit successfully: `target\debug\basic.exe .\test.bas` (exit code: 1)
```
