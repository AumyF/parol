%start Oberon2
%title "Oberon2 grammar"
%comment "Adapted from https://cseweb.ucsd.edu/~wgg/CSE131B/oberon2.htm for `parol`"
%block_comment "\(\*" "\*\)"

%%

/*   0 */ KwBegin: "BEGIN";
/*   1 */ KwCase: "CASE";
/*   2 */ KwDo: "DO";
/*   3 */ KwElse: "ELSE";
/*   4 */ KwElsif: "ELSIF";
/*   5 */ KwEnd: "END";
/*   6 */ KwIf: "IF";
/*   7 */ KwOf: "OF";
/*   8 */ KwProcedure: "PROCEDURE";
/*   9 */ KwThen: "THEN";
/*  10 */ KwTo: "TO";
/*  11 */ KwVar: "VAR";
/*  12 */ Oberon2: "MODULE" Ident ";" Oberon2Opt /* Option */ DeclSeq Oberon2Opt0 /* Option */ KwEnd Ident "\.";
/*  13 */ Oberon2Opt0: KwBegin StatementSeq; // Option<T>::Some
/*  14 */ Oberon2Opt0: ; // Option<T>::None
/*  15 */ Oberon2Opt: ImportList; // Option<T>::Some
/*  16 */ Oberon2Opt: ; // Option<T>::None
/*  17 */ ImportList: "IMPORT" ImportListOpt /* Option */ Ident ImportListList /* Vec */ ";";
/*  18 */ ImportListList: "," ImportListOpt0 /* Option */ Ident ImportListList; // Vec<T>::Push
/*  19 */ ImportListList: ; // Vec<T>::New
/*  20 */ ImportListOpt0: Ident ":="; // Option<T>::Some
/*  21 */ ImportListOpt0: ; // Option<T>::None
/*  22 */ ImportListOpt: Ident ":="; // Option<T>::Some
/*  23 */ ImportListOpt: ; // Option<T>::None
/*  24 */ DeclSeq: DeclSeqList /* Vec */ DeclSeqList0 /* Vec */;
/*  25 */ DeclSeqList0: DeclSeqList0Group DeclSeqList0; // Vec<T>::Push
/*  26 */ DeclSeqList0Group: ProcDecl ";";
/*  27 */ DeclSeqList0Group: ForwardDecl ";";
/*  28 */ DeclSeqList0: ; // Vec<T>::New
/*  29 */ DeclSeqList: DeclSeqListGroup DeclSeqList; // Vec<T>::Push
/*  30 */ DeclSeqListGroup: "CONST" DeclSeqListGroupList /* Vec */;
/*  31 */ DeclSeqListGroupList: ConstDecl ";" DeclSeqListGroupList; // Vec<T>::Push
/*  32 */ DeclSeqListGroupList: ; // Vec<T>::New
/*  33 */ DeclSeqListGroup: "TYPE" DeclSeqListGroupList0 /* Vec */;
/*  34 */ DeclSeqListGroupList0: TypeDecl ";" DeclSeqListGroupList0; // Vec<T>::Push
/*  35 */ DeclSeqListGroupList0: ; // Vec<T>::New
/*  36 */ DeclSeqListGroup: KwVar DeclSeqListGroupList1 /* Vec */;
/*  37 */ DeclSeqListGroupList1: VarDecl ";" DeclSeqListGroupList1; // Vec<T>::Push
/*  38 */ DeclSeqListGroupList1: ; // Vec<T>::New
/*  39 */ DeclSeqList: ; // Vec<T>::New
/*  40 */ ConstDecl: IdentDef "=" ConstExpr;
/*  41 */ TypeDecl: IdentDef "=" TypeDef;
/*  42 */ VarDecl: IdentList ":" TypeDef;
/*  43 */ ProcDecl: KwProcedure ProcDeclOpt /* Option */ IdentDef ProcDeclOpt0 /* Option */ ";" DeclSeq ProcDeclOpt1 /* Option */ KwEnd Ident;
/*  44 */ ProcDeclOpt1: KwBegin StatementSeq; // Option<T>::Some
/*  45 */ ProcDeclOpt1: ; // Option<T>::None
/*  46 */ ProcDeclOpt0: FormalPars; // Option<T>::Some
/*  47 */ ProcDeclOpt0: ; // Option<T>::None
/*  48 */ ProcDeclOpt: Receiver; // Option<T>::Some
/*  49 */ ProcDeclOpt: ; // Option<T>::None
/*  50 */ ForwardDecl: KwProcedure "\^" ForwardDeclOpt /* Option */ IdentDef ForwardDeclOpt0 /* Option */;
/*  51 */ ForwardDeclOpt0: FormalPars; // Option<T>::Some
/*  52 */ ForwardDeclOpt0: ; // Option<T>::None
/*  53 */ ForwardDeclOpt: Receiver; // Option<T>::Some
/*  54 */ ForwardDeclOpt: ; // Option<T>::None
/*  55 */ FormalPars: "\(" FormalParsOpt /* Option */ "\)" FormalParsOpt0 /* Option */;
/*  56 */ FormalParsOpt0: ":" QualIdent; // Option<T>::Some
/*  57 */ FormalParsOpt0: ; // Option<T>::None
/*  58 */ FormalParsOpt: FPSection FormalParsOptList /* Vec */; // Option<T>::Some
/*  59 */ FormalParsOptList: ";" FPSection FormalParsOptList; // Vec<T>::Push
/*  60 */ FormalParsOptList: ; // Vec<T>::New
/*  61 */ FormalParsOpt: ; // Option<T>::None
/*  62 */ FPSection: FPSectionOpt /* Option */ Ident FPSectionList /* Vec */ ":" TypeDef;
/*  63 */ FPSectionList: "," Ident FPSectionList; // Vec<T>::Push
/*  64 */ FPSectionList: ; // Vec<T>::New
/*  65 */ FPSectionOpt: KwVar; // Option<T>::Some
/*  66 */ FPSectionOpt: ; // Option<T>::None
/*  67 */ Receiver: "\(" ReceiverOpt /* Option */ Ident ":" Ident "\)";
/*  68 */ ReceiverOpt: KwVar; // Option<T>::Some
/*  69 */ ReceiverOpt: ; // Option<T>::None
/*  70 */ TypeDef: QualIdent;
/*  71 */ TypeDef: "ARRAY" TypeDefOpt /* Option */ KwOf TypeDef;
/*  72 */ TypeDef: "RECORD" TypeDefOpt0 /* Option */ FieldList TypeDefList /* Vec */ KwEnd;
/*  73 */ TypeDefList: ";" FieldList TypeDefList; // Vec<T>::Push
/*  74 */ TypeDefList: ; // Vec<T>::New
/*  75 */ TypeDef: "POINTER" KwTo TypeDef;
/*  76 */ TypeDef: KwProcedure TypeDefOpt1 /* Option */;
/*  77 */ TypeDefOpt1: FormalPars; // Option<T>::Some
/*  78 */ TypeDefOpt1: ; // Option<T>::None
/*  79 */ TypeDefOpt0: "\(" QualIdent "\)"; // Option<T>::Some
/*  80 */ TypeDefOpt0: ; // Option<T>::None
/*  81 */ TypeDefOpt: ConstExpr TypeDefOptList /* Vec */; // Option<T>::Some
/*  82 */ TypeDefOptList: "," ConstExpr TypeDefOptList; // Vec<T>::Push
/*  83 */ TypeDefOptList: ; // Vec<T>::New
/*  84 */ TypeDefOpt: ; // Option<T>::None
/*  85 */ FieldList: FieldListOpt /* Option */;
/*  86 */ FieldListOpt: IdentList ":" TypeDef; // Option<T>::Some
/*  87 */ FieldListOpt: ; // Option<T>::None
/*  88 */ StatementSeq: Statement StatementSeqList /* Vec */;
/*  89 */ StatementSeqList: ";" Statement StatementSeqList; // Vec<T>::Push
/*  90 */ StatementSeqList: ; // Vec<T>::New
/*  91 */ Statement: StatementOpt /* Option */;
/*  92 */ StatementOpt: StatementOptGroup; // Option<T>::Some
/*  93 */ StatementOptGroup: Designator StatementOptGroupSuffix;
/*  94 */ StatementOptGroupSuffix: ":=" Expr;
/*  95 */ StatementOptGroupSuffix: StatementOpt0 /* Option */;
/*  96 */ StatementOptGroup: KwIf Expr KwThen StatementSeq StatementOptGroupList /* Vec */ StatementOpt1 /* Option */ KwEnd;
/*  97 */ StatementOptGroup: KwCase Expr KwOf Case StatementOptGroupList0 /* Vec */ StatementOpt2 /* Option */ KwEnd;
/*  98 */ StatementOptGroup: "WHILE" Expr KwDo StatementSeq KwEnd;
/*  99 */ StatementOptGroup: "REPEAT" StatementSeq "UNTIL" Expr;
/* 100 */ StatementOptGroup: "FOR" Ident ":=" Expr KwTo Expr StatementOpt3 /* Option */ KwDo StatementSeq KwEnd;
/* 101 */ StatementOptGroup: "LOOP" StatementSeq KwEnd;
/* 102 */ StatementOptGroup: "WITH" Guard KwDo StatementSeq StatementOptGroupList1 /* Vec */ StatementOpt4 /* Option */ KwEnd;
/* 103 */ StatementOptGroup: "EXIT";
/* 104 */ StatementOptGroup: "RETURN" StatementOpt5 /* Option */;
/* 105 */ StatementOptGroupList: KwElsif Expr KwThen StatementSeq StatementOptGroupList; // Vec<T>::Push
/* 106 */ StatementOptGroupList: ; // Vec<T>::New
/* 107 */ StatementOptGroupList0: "\|" Case StatementOptGroupList0; // Vec<T>::Push
/* 108 */ StatementOptGroupList0: ; // Vec<T>::New
/* 109 */ StatementOptGroupList1: "\|" Guard KwDo StatementSeq StatementOptGroupList1; // Vec<T>::Push
/* 110 */ StatementOptGroupList1: ; // Vec<T>::New
/* 111 */ StatementOpt5: Expr; // Option<T>::Some
/* 112 */ StatementOpt5: ; // Option<T>::None
/* 113 */ StatementOpt4: KwElse StatementSeq; // Option<T>::Some
/* 114 */ StatementOpt4: ; // Option<T>::None
/* 115 */ StatementOpt3: "BY" ConstExpr; // Option<T>::Some
/* 116 */ StatementOpt3: ; // Option<T>::None
/* 117 */ StatementOpt2: KwElse StatementSeq; // Option<T>::Some
/* 118 */ StatementOpt2: ; // Option<T>::None
/* 119 */ StatementOpt1: KwElse StatementSeq; // Option<T>::Some
/* 120 */ StatementOpt1: ; // Option<T>::None
/* 121 */ StatementOpt0: "\(" StatementOpt6 /* Option */ "\)"; // Option<T>::Some
/* 122 */ StatementOpt6: ExprList; // Option<T>::Some
/* 123 */ StatementOpt6: ; // Option<T>::None
/* 124 */ StatementOpt0: ; // Option<T>::None
/* 125 */ StatementOpt: ; // Option<T>::None
/* 126 */ Case: CaseOpt /* Option */;
/* 127 */ CaseOpt: CaseLabels CaseOptList /* Vec */ ":" StatementSeq; // Option<T>::Some
/* 128 */ CaseOptList: "," CaseLabels CaseOptList; // Vec<T>::Push
/* 129 */ CaseOptList: ; // Vec<T>::New
/* 130 */ CaseOpt: ; // Option<T>::None
/* 131 */ CaseLabels: ConstExpr CaseLabelsOpt /* Option */;
/* 132 */ CaseLabelsOpt: "\.\." ConstExpr; // Option<T>::Some
/* 133 */ CaseLabelsOpt: ; // Option<T>::None
/* 134 */ Guard: QualIdent ":" QualIdent;
/* 135 */ ConstExpr: Expr;
/* 136 */ Expr: SimpleExpr ExprOpt /* Option */;
/* 137 */ ExprOpt: Relation SimpleExpr; // Option<T>::Some
/* 138 */ ExprOpt: ; // Option<T>::None
/* 139 */ SimpleExpr: SimpleExprOpt /* Option */ Term SimpleExprList /* Vec */;
/* 140 */ SimpleExprList: AddOp Term SimpleExprList; // Vec<T>::Push
/* 141 */ SimpleExprList: ; // Vec<T>::New
/* 142 */ SimpleExprOpt: SimpleExprOptGroup; // Option<T>::Some
/* 143 */ SimpleExprOptGroup: "\+";
/* 144 */ SimpleExprOptGroup: "-";
/* 145 */ SimpleExprOpt: ; // Option<T>::None
/* 146 */ Term: Factor TermList /* Vec */;
/* 147 */ TermList: MulOp Factor TermList; // Vec<T>::Push
/* 148 */ TermList: ; // Vec<T>::New
/* 149 */ Factor: Designator FactorOpt /* Option */;
/* 150 */ Factor: Number;
/* 151 */ Factor: Character;
/* 152 */ Factor: String;
/* 153 */ Factor: "NIL";
/* 154 */ Factor: Set;
/* 155 */ Factor: "\(" Expr "\)";
/* 156 */ Factor: "~" Factor;
/* 157 */ FactorOpt: "\(" FactorOpt0 /* Option */ "\)"; // Option<T>::Some
/* 158 */ FactorOpt0: ExprList; // Option<T>::Some
/* 159 */ FactorOpt0: ; // Option<T>::None
/* 160 */ FactorOpt: ; // Option<T>::None
/* 161 */ Set: "\{" SetOpt /* Option */ "\}";
/* 162 */ SetOpt: Element SetOptList /* Vec */; // Option<T>::Some
/* 163 */ SetOptList: "," Element SetOptList; // Vec<T>::Push
/* 164 */ SetOptList: ; // Vec<T>::New
/* 165 */ SetOpt: ; // Option<T>::None
/* 166 */ Element: Expr ElementOpt /* Option */;
/* 167 */ ElementOpt: "\.\." Expr; // Option<T>::Some
/* 168 */ ElementOpt: ; // Option<T>::None
/* 169 */ Relation: "=";
/* 170 */ Relation: "#";
/* 171 */ Relation: "<";
/* 172 */ Relation: "<=";
/* 173 */ Relation: ">";
/* 174 */ Relation: ">=";
/* 175 */ Relation: InOp;
/* 176 */ Relation: "IS";
/* 177 */ AddOp: "\+";
/* 178 */ AddOp: "-";
/* 179 */ AddOp: "OR";
/* 180 */ MulOp: "\*";
/* 181 */ MulOp: "/";
/* 182 */ MulOp: "DIV";
/* 183 */ MulOp: "MOD";
/* 184 */ MulOp: "&";
/* 185 */ Designator: QualIdent DesignatorList /* Vec */;
/* 186 */ DesignatorList: DesignatorSuffix DesignatorList; // Vec<T>::Push
/* 187 */ DesignatorList: ; // Vec<T>::New
/* 188 */ DesignatorSuffix: "\." Ident;
/* 189 */ DesignatorSuffix: "\[" ExprList "\]";
/* 190 */ DesignatorSuffix: "\^";
/* 191 */ ExprList: Expr ExprListList /* Vec */;
/* 192 */ ExprListList: "," Expr ExprListList; // Vec<T>::Push
/* 193 */ ExprListList: ; // Vec<T>::New
/* 194 */ IdentList: IdentDef IdentListList /* Vec */;
/* 195 */ IdentListList: "," IdentDef IdentListList; // Vec<T>::Push
/* 196 */ IdentListList: ; // Vec<T>::New
/* 197 */ QualIdent: Ident;
/* 198 */ QualIdent: QIdent;
/* 199 */ IdentDef: Ident IdentDefOpt /* Option */;
/* 200 */ IdentDefOpt: IdentDefOptGroup; // Option<T>::Some
/* 201 */ IdentDefOptGroup: "\*";
/* 202 */ IdentDefOptGroup: "-";
/* 203 */ IdentDefOpt: ; // Option<T>::None
/* 204 */ Number: Integer;
/* 205 */ Number: Real;
/* 206 */ Real: "[0-9][0-9]*\.[0-9]*(ED[+-]?[0-9][0-9]*)?";
/* 207 */ Character: "[0-9][0-9A-F]*X";
/* 208 */ Integer: "[0-9][0-9]*|[0-9][0-9A-F]*H";
/* 209 */ QIdent: "[a-zA-Z_]\w*\.[a-zA-Z_]\w*";
/* 210 */ Ident: "[a-zA-Z_]\w*";
/* 211 */ String: "\u{0022}[^\u{0022}]*\u{0022}|'[^']*'";
/* 212 */ InOp: "IN";
