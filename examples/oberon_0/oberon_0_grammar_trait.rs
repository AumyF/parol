// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use crate::oberon_0_grammar::Oberon0Grammar;
use anyhow::Result;
use id_tree::Tree;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

///
/// The `Oberon0GrammarTrait` trait is automatically generated for the
/// given grammar.
/// All functions have default implementations.
///
pub trait Oberon0GrammarTrait {
    /// Semantic action for production 0:
    ///
    /// selector: selectorlist;
    ///
    fn selector_0(
        &mut self,
        _selectorlist_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// selectorlist: "\." ident selectorlist;
    ///
    fn selectorlist_1(
        &mut self,
        _dot_0: &ParseTreeStackEntry,
        _ident_1: &ParseTreeStackEntry,
        _selectorlist_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// selectorlist: "\[" expression "]" selectorlist;
    ///
    fn selectorlist_2(
        &mut self,
        _l_bracket_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _r_bracket_2: &ParseTreeStackEntry,
        _selectorlist_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// selectorlist: ;
    ///
    fn selectorlist_3(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// factor: ident selector;
    ///
    fn factor_4(
        &mut self,
        _ident_0: &ParseTreeStackEntry,
        _selector_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// factor: integer;
    ///
    fn factor_5(
        &mut self,
        _integer_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// factor: "\(" expression "\)";
    ///
    fn factor_6(
        &mut self,
        _l_paren_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _r_paren_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// factor: "~" factor;
    ///
    fn factor_7(
        &mut self,
        _tilde_0: &ParseTreeStackEntry,
        _factor_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// factor: UnaryOp factor;
    ///
    fn factor_8(
        &mut self,
        _unary_op_0: &ParseTreeStackEntry,
        _factor_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// term: factor MulExpression;
    ///
    fn term_9(
        &mut self,
        _factor_0: &ParseTreeStackEntry,
        _mul_expression_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// MulExpression: MulOperator factor MulExpression;
    ///
    fn mul_expression_10(
        &mut self,
        _mul_operator_0: &ParseTreeStackEntry,
        _factor_1: &ParseTreeStackEntry,
        _mul_expression_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// MulExpression: ;
    ///
    fn mul_expression_11(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// SimpleExpression: term AddExpression;
    ///
    fn simple_expression_12(
        &mut self,
        _term_0: &ParseTreeStackEntry,
        _add_expression_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// AddExpression: AddOperator term AddExpression;
    ///
    fn add_expression_13(
        &mut self,
        _add_operator_0: &ParseTreeStackEntry,
        _term_1: &ParseTreeStackEntry,
        _add_expression_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// AddExpression: ;
    ///
    fn add_expression_14(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// AssignOp: ":=";
    ///
    fn assign_op_15(
        &mut self,
        _colon_equ_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// RelationOp: AssignOp;
    ///
    fn relation_op_16(
        &mut self,
        _assign_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// RelationOp: RelationalOps;
    ///
    fn relation_op_17(
        &mut self,
        _relational_ops_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// RelationalOps: ">=|<=|\#|<|>";
    ///
    fn relational_ops_18(
        &mut self,
        _relational_ops_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// AssignOp: "=";
    ///
    fn assign_op_19(
        &mut self,
        _equ_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// expression: SimpleExpression expressionSuffix;
    ///
    fn expression_20(
        &mut self,
        _simple_expression_0: &ParseTreeStackEntry,
        _expression_suffix_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// expressionSuffix: RelationOp SimpleExpression;
    ///
    fn expression_suffix_21(
        &mut self,
        _relation_op_0: &ParseTreeStackEntry,
        _simple_expression_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// expressionSuffix: ;
    ///
    fn expression_suffix_22(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// assignment: ident selector AssignOp expression;
    ///
    fn assignment_23(
        &mut self,
        _ident_0: &ParseTreeStackEntry,
        _selector_1: &ParseTreeStackEntry,
        _assign_op_2: &ParseTreeStackEntry,
        _expression_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// ActualParameters: "\(" ActualParametersSuffix;
    ///
    fn actual_parameters_24(
        &mut self,
        _l_paren_0: &ParseTreeStackEntry,
        _actual_parameters_suffix_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// ActualParametersSuffix: "\)";
    ///
    fn actual_parameters_suffix_25(
        &mut self,
        _r_paren_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// ActualParametersSuffix: expression expressionlistrest "\)";
    ///
    fn actual_parameters_suffix_26(
        &mut self,
        _expression_0: &ParseTreeStackEntry,
        _expressionlistrest_1: &ParseTreeStackEntry,
        _r_paren_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// expressionlistrest: "," expression expressionlistrest;
    ///
    fn expressionlistrest_27(
        &mut self,
        _comma_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _expressionlistrest_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// expressionlistrest: ;
    ///
    fn expressionlistrest_28(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// ProcedureCall: ident ProcedureCallSuffix;
    ///
    fn procedure_call_29(
        &mut self,
        _ident_0: &ParseTreeStackEntry,
        _procedure_call_suffix_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// ProcedureCallSuffix: ActualParameters;
    ///
    fn procedure_call_suffix_30(
        &mut self,
        _actual_parameters_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// ProcedureCallSuffix: ;
    ///
    fn procedure_call_suffix_31(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// IfStatement: IfPrefix IfStatementSuffix;
    ///
    fn if_statement_32(
        &mut self,
        _if_prefix_0: &ParseTreeStackEntry,
        _if_statement_suffix_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// IfStatementSuffix: "ELSE" StatementSequence "END";
    ///
    fn if_statement_suffix_33(
        &mut self,
        _e_l_s_e_0: &ParseTreeStackEntry,
        _statement_sequence_1: &ParseTreeStackEntry,
        _e_n_d_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// IfStatementSuffix: "END";
    ///
    fn if_statement_suffix_34(
        &mut self,
        _e_n_d_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// IfPrefix: "IF" expression "THEN" StatementSequence elseiflist;
    ///
    fn if_prefix_35(
        &mut self,
        _i_f_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _t_h_e_n_2: &ParseTreeStackEntry,
        _statement_sequence_3: &ParseTreeStackEntry,
        _elseiflist_4: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// elseiflist: "ELSIF" expression "THEN" StatementSequence elseiflist;
    ///
    fn elseiflist_36(
        &mut self,
        _e_l_s_i_f_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _t_h_e_n_2: &ParseTreeStackEntry,
        _statement_sequence_3: &ParseTreeStackEntry,
        _elseiflist_4: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// elseiflist: ;
    ///
    fn elseiflist_37(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// WhileStatement: "WHILE" expression "DO" StatementSequence "END";
    ///
    fn while_statement_38(
        &mut self,
        _w_h_i_l_e_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _d_o_2: &ParseTreeStackEntry,
        _statement_sequence_3: &ParseTreeStackEntry,
        _e_n_d_4: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// RepeatStatement: "REPEAT" StatementSequence "UNTIL" expression;
    ///
    fn repeat_statement_39(
        &mut self,
        _r_e_p_e_a_t_0: &ParseTreeStackEntry,
        _statement_sequence_1: &ParseTreeStackEntry,
        _u_n_t_i_l_2: &ParseTreeStackEntry,
        _expression_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// statement: assignment;
    ///
    fn statement_40(
        &mut self,
        _assignment_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// statement: ProcedureCall;
    ///
    fn statement_41(
        &mut self,
        _procedure_call_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// statement: IfStatement;
    ///
    fn statement_42(
        &mut self,
        _if_statement_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// statement: WhileStatement;
    ///
    fn statement_43(
        &mut self,
        _while_statement_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// statement: RepeatStatement;
    ///
    fn statement_44(
        &mut self,
        _repeat_statement_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// statement: ;
    ///
    fn statement_45(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// StatementSequence: statement StatementSequenceRest;
    ///
    fn statement_sequence_46(
        &mut self,
        _statement_0: &ParseTreeStackEntry,
        _statement_sequence_rest_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// StatementSequenceRest: ";" statement StatementSequenceRest;
    ///
    fn statement_sequence_rest_47(
        &mut self,
        _semicolon_0: &ParseTreeStackEntry,
        _statement_1: &ParseTreeStackEntry,
        _statement_sequence_rest_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// StatementSequenceRest: ;
    ///
    fn statement_sequence_rest_48(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// IdentList: ident IdentListRest;
    ///
    fn ident_list_49(
        &mut self,
        _ident_0: &ParseTreeStackEntry,
        _ident_list_rest_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// IdentListRest: "," ident IdentListRest;
    ///
    fn ident_list_rest_50(
        &mut self,
        _comma_0: &ParseTreeStackEntry,
        _ident_1: &ParseTreeStackEntry,
        _ident_list_rest_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// IdentListRest: ;
    ///
    fn ident_list_rest_51(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// ArrayType: "ARRAY" expression "OF" type;
    ///
    fn array_type_52(
        &mut self,
        _a_r_r_a_y_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _o_f_2: &ParseTreeStackEntry,
        _type_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// FieldList: IdentList ":" type;
    ///
    fn field_list_53(
        &mut self,
        _ident_list_0: &ParseTreeStackEntry,
        _colon_1: &ParseTreeStackEntry,
        _type_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// FieldList: ;
    ///
    fn field_list_54(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// RecordType: "RECORD" FieldList FieldListRest "END";
    ///
    fn record_type_55(
        &mut self,
        _r_e_c_o_r_d_0: &ParseTreeStackEntry,
        _field_list_1: &ParseTreeStackEntry,
        _field_list_rest_2: &ParseTreeStackEntry,
        _e_n_d_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// FieldListRest: ";" FieldList FieldListRest;
    ///
    fn field_list_rest_56(
        &mut self,
        _semicolon_0: &ParseTreeStackEntry,
        _field_list_1: &ParseTreeStackEntry,
        _field_list_rest_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// FieldListRest: ;
    ///
    fn field_list_rest_57(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// type: ident;
    ///
    fn type_58(
        &mut self,
        _ident_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// type: ArrayType;
    ///
    fn type_59(
        &mut self,
        _array_type_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// type: RecordType;
    ///
    fn type_60(
        &mut self,
        _record_type_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// FPSection: "VAR" IdentList ":" type;
    ///
    fn f_p_section_61(
        &mut self,
        _v_a_r_0: &ParseTreeStackEntry,
        _ident_list_1: &ParseTreeStackEntry,
        _colon_2: &ParseTreeStackEntry,
        _type_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// FPSection: IdentList ":" type;
    ///
    fn f_p_section_62(
        &mut self,
        _ident_list_0: &ParseTreeStackEntry,
        _colon_1: &ParseTreeStackEntry,
        _type_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// FormalParameters: "\(" FormalParametersSuffix;
    ///
    fn formal_parameters_63(
        &mut self,
        _l_paren_0: &ParseTreeStackEntry,
        _formal_parameters_suffix_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// FormalParametersSuffix: "\)";
    ///
    fn formal_parameters_suffix_64(
        &mut self,
        _r_paren_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// FormalParametersSuffix: FPSection FPSectionRest "\)";
    ///
    fn formal_parameters_suffix_65(
        &mut self,
        _f_p_section_0: &ParseTreeStackEntry,
        _f_p_section_rest_1: &ParseTreeStackEntry,
        _r_paren_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// FPSectionRest: ";" FPSection FPSectionRest;
    ///
    fn f_p_section_rest_66(
        &mut self,
        _semicolon_0: &ParseTreeStackEntry,
        _f_p_section_1: &ParseTreeStackEntry,
        _f_p_section_rest_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// FPSectionRest: ;
    ///
    fn f_p_section_rest_67(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// ProcedureHeading: "PROCEDURE" ident ProcedureHeadingSuffix;
    ///
    fn procedure_heading_68(
        &mut self,
        _p_r_o_c_e_d_u_r_e_0: &ParseTreeStackEntry,
        _ident_1: &ParseTreeStackEntry,
        _procedure_heading_suffix_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// ProcedureHeadingSuffix: FormalParameters;
    ///
    fn procedure_heading_suffix_69(
        &mut self,
        _formal_parameters_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// ProcedureHeadingSuffix: ;
    ///
    fn procedure_heading_suffix_70(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// ProcedureBody: declarations ProcedureBodySuffix1;
    ///
    fn procedure_body_71(
        &mut self,
        _declarations_0: &ParseTreeStackEntry,
        _procedure_body_suffix1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// ProcedureBodySuffix1: "BEGIN" StatementSequence ProcedureBodySuffix;
    ///
    fn procedure_body_suffix1_72(
        &mut self,
        _b_e_g_i_n_0: &ParseTreeStackEntry,
        _statement_sequence_1: &ParseTreeStackEntry,
        _procedure_body_suffix_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// ProcedureBodySuffix1: "RETURN" expression "END" ident;
    ///
    fn procedure_body_suffix1_73(
        &mut self,
        _r_e_t_u_r_n_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _e_n_d_2: &ParseTreeStackEntry,
        _ident_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// ProcedureBodySuffix1: "END" ident;
    ///
    fn procedure_body_suffix1_74(
        &mut self,
        _e_n_d_0: &ParseTreeStackEntry,
        _ident_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// ProcedureBodySuffix: "RETURN" expression "END" ident;
    ///
    fn procedure_body_suffix_75(
        &mut self,
        _r_e_t_u_r_n_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _e_n_d_2: &ParseTreeStackEntry,
        _ident_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// ProcedureBodySuffix: "END" ident;
    ///
    fn procedure_body_suffix_76(
        &mut self,
        _e_n_d_0: &ParseTreeStackEntry,
        _ident_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// ProcedureDeclaration: ProcedureHeading ";" ProcedureBody;
    ///
    fn procedure_declaration_77(
        &mut self,
        _procedure_heading_0: &ParseTreeStackEntry,
        _semicolon_1: &ParseTreeStackEntry,
        _procedure_body_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// declarations: "TYPE" TypeDecls declarationsSuffix2;
    ///
    fn declarations_78(
        &mut self,
        _t_y_p_e_0: &ParseTreeStackEntry,
        _type_decls_1: &ParseTreeStackEntry,
        _declarations_suffix2_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// declarations: "CONST" ConstDecls declarationsSuffix1;
    ///
    fn declarations_79(
        &mut self,
        _c_o_n_s_t_0: &ParseTreeStackEntry,
        _const_decls_1: &ParseTreeStackEntry,
        _declarations_suffix1_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// declarationsSuffix2: "VAR" VarDecls ProcedureDeclarationList;
    ///
    fn declarations_suffix2_80(
        &mut self,
        _v_a_r_0: &ParseTreeStackEntry,
        _var_decls_1: &ParseTreeStackEntry,
        _procedure_declaration_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// declarationsSuffix2: ProcedureDeclarationList;
    ///
    fn declarations_suffix2_81(
        &mut self,
        _procedure_declaration_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// declarations: "VAR" VarDecls ProcedureDeclarationList;
    ///
    fn declarations_82(
        &mut self,
        _v_a_r_0: &ParseTreeStackEntry,
        _var_decls_1: &ParseTreeStackEntry,
        _procedure_declaration_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// declarations: ProcedureDeclarationList;
    ///
    fn declarations_83(
        &mut self,
        _procedure_declaration_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// declarationsSuffix1: "TYPE" TypeDecls declarationsSuffix;
    ///
    fn declarations_suffix1_84(
        &mut self,
        _t_y_p_e_0: &ParseTreeStackEntry,
        _type_decls_1: &ParseTreeStackEntry,
        _declarations_suffix_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// declarationsSuffix1: "VAR" VarDecls ProcedureDeclarationList;
    ///
    fn declarations_suffix1_85(
        &mut self,
        _v_a_r_0: &ParseTreeStackEntry,
        _var_decls_1: &ParseTreeStackEntry,
        _procedure_declaration_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// declarationsSuffix1: ProcedureDeclarationList;
    ///
    fn declarations_suffix1_86(
        &mut self,
        _procedure_declaration_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// declarationsSuffix: "VAR" VarDecls ProcedureDeclarationList;
    ///
    fn declarations_suffix_87(
        &mut self,
        _v_a_r_0: &ParseTreeStackEntry,
        _var_decls_1: &ParseTreeStackEntry,
        _procedure_declaration_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// declarationsSuffix: ProcedureDeclarationList;
    ///
    fn declarations_suffix_88(
        &mut self,
        _procedure_declaration_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// ProcedureDeclarationList: ProcedureDeclaration ";" ProcedureDeclarationList;
    ///
    fn procedure_declaration_list_89(
        &mut self,
        _procedure_declaration_0: &ParseTreeStackEntry,
        _semicolon_1: &ParseTreeStackEntry,
        _procedure_declaration_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// ProcedureDeclarationList: ;
    ///
    fn procedure_declaration_list_90(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// ConstDecls: ident AssignOp expression ";" ConstDecls;
    ///
    fn const_decls_91(
        &mut self,
        _ident_0: &ParseTreeStackEntry,
        _assign_op_1: &ParseTreeStackEntry,
        _expression_2: &ParseTreeStackEntry,
        _semicolon_3: &ParseTreeStackEntry,
        _const_decls_4: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// ConstDecls: ;
    ///
    fn const_decls_92(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// TypeDecls: ident AssignOp type ";" TypeDecls;
    ///
    fn type_decls_93(
        &mut self,
        _ident_0: &ParseTreeStackEntry,
        _assign_op_1: &ParseTreeStackEntry,
        _type_2: &ParseTreeStackEntry,
        _semicolon_3: &ParseTreeStackEntry,
        _type_decls_4: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// TypeDecls: ;
    ///
    fn type_decls_94(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// VarDecls: IdentList ":" type ";" VarDecls;
    ///
    fn var_decls_95(
        &mut self,
        _ident_list_0: &ParseTreeStackEntry,
        _colon_1: &ParseTreeStackEntry,
        _type_2: &ParseTreeStackEntry,
        _semicolon_3: &ParseTreeStackEntry,
        _var_decls_4: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// VarDecls: ;
    ///
    fn var_decls_96(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// module: "MODULE" ident ";" declarations moduleSuffix;
    ///
    fn module_97(
        &mut self,
        _m_o_d_u_l_e_0: &ParseTreeStackEntry,
        _ident_1: &ParseTreeStackEntry,
        _semicolon_2: &ParseTreeStackEntry,
        _declarations_3: &ParseTreeStackEntry,
        _module_suffix_4: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// moduleSuffix: "BEGIN" StatementSequence "END" ident "\.";
    ///
    fn module_suffix_98(
        &mut self,
        _b_e_g_i_n_0: &ParseTreeStackEntry,
        _statement_sequence_1: &ParseTreeStackEntry,
        _e_n_d_2: &ParseTreeStackEntry,
        _ident_3: &ParseTreeStackEntry,
        _dot_4: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// moduleSuffix: "END" ident "\.";
    ///
    fn module_suffix_99(
        &mut self,
        _e_n_d_0: &ParseTreeStackEntry,
        _ident_1: &ParseTreeStackEntry,
        _dot_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// MulOperator: "\*|/|DIV|MOD|&";
    ///
    fn mul_operator_100(
        &mut self,
        _mul_operator_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// AddOperator: "\+|-|OR";
    ///
    fn add_operator_101(
        &mut self,
        _add_operator_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// UnaryOp: "\+|-";
    ///
    fn unary_op_102(
        &mut self,
        _unary_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// ident: "[a-zA-Z][a-zA-Z0-9]*";
    ///
    fn ident_103(
        &mut self,
        _ident_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// integer: "[0-9]+";
    ///
    fn integer_104(
        &mut self,
        _integer_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }
}

impl UserActionsTrait for Oberon0Grammar {
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry],
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        match prod_num {
            0 => self.selector_0(&children[0], parse_tree),

            1 => self.selectorlist_1(&children[0], &children[1], &children[2], parse_tree),

            2 => self.selectorlist_2(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),

            3 => self.selectorlist_3(parse_tree),

            4 => self.factor_4(&children[0], &children[1], parse_tree),

            5 => self.factor_5(&children[0], parse_tree),

            6 => self.factor_6(&children[0], &children[1], &children[2], parse_tree),

            7 => self.factor_7(&children[0], &children[1], parse_tree),

            8 => self.factor_8(&children[0], &children[1], parse_tree),

            9 => self.term_9(&children[0], &children[1], parse_tree),

            10 => self.mul_expression_10(&children[0], &children[1], &children[2], parse_tree),

            11 => self.mul_expression_11(parse_tree),

            12 => self.simple_expression_12(&children[0], &children[1], parse_tree),

            13 => self.add_expression_13(&children[0], &children[1], &children[2], parse_tree),

            14 => self.add_expression_14(parse_tree),

            15 => self.assign_op_15(&children[0], parse_tree),

            16 => self.relation_op_16(&children[0], parse_tree),

            17 => self.relation_op_17(&children[0], parse_tree),

            18 => self.relational_ops_18(&children[0], parse_tree),

            19 => self.assign_op_19(&children[0], parse_tree),

            20 => self.expression_20(&children[0], &children[1], parse_tree),

            21 => self.expression_suffix_21(&children[0], &children[1], parse_tree),

            22 => self.expression_suffix_22(parse_tree),

            23 => self.assignment_23(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),

            24 => self.actual_parameters_24(&children[0], &children[1], parse_tree),

            25 => self.actual_parameters_suffix_25(&children[0], parse_tree),

            26 => self.actual_parameters_suffix_26(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),

            27 => self.expressionlistrest_27(&children[0], &children[1], &children[2], parse_tree),

            28 => self.expressionlistrest_28(parse_tree),

            29 => self.procedure_call_29(&children[0], &children[1], parse_tree),

            30 => self.procedure_call_suffix_30(&children[0], parse_tree),

            31 => self.procedure_call_suffix_31(parse_tree),

            32 => self.if_statement_32(&children[0], &children[1], parse_tree),

            33 => self.if_statement_suffix_33(&children[0], &children[1], &children[2], parse_tree),

            34 => self.if_statement_suffix_34(&children[0], parse_tree),

            35 => self.if_prefix_35(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),

            36 => self.elseiflist_36(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),

            37 => self.elseiflist_37(parse_tree),

            38 => self.while_statement_38(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),

            39 => self.repeat_statement_39(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),

            40 => self.statement_40(&children[0], parse_tree),

            41 => self.statement_41(&children[0], parse_tree),

            42 => self.statement_42(&children[0], parse_tree),

            43 => self.statement_43(&children[0], parse_tree),

            44 => self.statement_44(&children[0], parse_tree),

            45 => self.statement_45(parse_tree),

            46 => self.statement_sequence_46(&children[0], &children[1], parse_tree),

            47 => self.statement_sequence_rest_47(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),

            48 => self.statement_sequence_rest_48(parse_tree),

            49 => self.ident_list_49(&children[0], &children[1], parse_tree),

            50 => self.ident_list_rest_50(&children[0], &children[1], &children[2], parse_tree),

            51 => self.ident_list_rest_51(parse_tree),

            52 => self.array_type_52(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),

            53 => self.field_list_53(&children[0], &children[1], &children[2], parse_tree),

            54 => self.field_list_54(parse_tree),

            55 => self.record_type_55(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),

            56 => self.field_list_rest_56(&children[0], &children[1], &children[2], parse_tree),

            57 => self.field_list_rest_57(parse_tree),

            58 => self.type_58(&children[0], parse_tree),

            59 => self.type_59(&children[0], parse_tree),

            60 => self.type_60(&children[0], parse_tree),

            61 => self.f_p_section_61(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),

            62 => self.f_p_section_62(&children[0], &children[1], &children[2], parse_tree),

            63 => self.formal_parameters_63(&children[0], &children[1], parse_tree),

            64 => self.formal_parameters_suffix_64(&children[0], parse_tree),

            65 => self.formal_parameters_suffix_65(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),

            66 => self.f_p_section_rest_66(&children[0], &children[1], &children[2], parse_tree),

            67 => self.f_p_section_rest_67(parse_tree),

            68 => self.procedure_heading_68(&children[0], &children[1], &children[2], parse_tree),

            69 => self.procedure_heading_suffix_69(&children[0], parse_tree),

            70 => self.procedure_heading_suffix_70(parse_tree),

            71 => self.procedure_body_71(&children[0], &children[1], parse_tree),

            72 => {
                self.procedure_body_suffix1_72(&children[0], &children[1], &children[2], parse_tree)
            }

            73 => self.procedure_body_suffix1_73(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),

            74 => self.procedure_body_suffix1_74(&children[0], &children[1], parse_tree),

            75 => self.procedure_body_suffix_75(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),

            76 => self.procedure_body_suffix_76(&children[0], &children[1], parse_tree),

            77 => {
                self.procedure_declaration_77(&children[0], &children[1], &children[2], parse_tree)
            }

            78 => self.declarations_78(&children[0], &children[1], &children[2], parse_tree),

            79 => self.declarations_79(&children[0], &children[1], &children[2], parse_tree),

            80 => {
                self.declarations_suffix2_80(&children[0], &children[1], &children[2], parse_tree)
            }

            81 => self.declarations_suffix2_81(&children[0], parse_tree),

            82 => self.declarations_82(&children[0], &children[1], &children[2], parse_tree),

            83 => self.declarations_83(&children[0], parse_tree),

            84 => {
                self.declarations_suffix1_84(&children[0], &children[1], &children[2], parse_tree)
            }

            85 => {
                self.declarations_suffix1_85(&children[0], &children[1], &children[2], parse_tree)
            }

            86 => self.declarations_suffix1_86(&children[0], parse_tree),

            87 => self.declarations_suffix_87(&children[0], &children[1], &children[2], parse_tree),

            88 => self.declarations_suffix_88(&children[0], parse_tree),

            89 => self.procedure_declaration_list_89(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),

            90 => self.procedure_declaration_list_90(parse_tree),

            91 => self.const_decls_91(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),

            92 => self.const_decls_92(parse_tree),

            93 => self.type_decls_93(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),

            94 => self.type_decls_94(parse_tree),

            95 => self.var_decls_95(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),

            96 => self.var_decls_96(parse_tree),

            97 => self.module_97(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),

            98 => self.module_suffix_98(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),

            99 => self.module_suffix_99(&children[0], &children[1], &children[2], parse_tree),

            100 => self.mul_operator_100(&children[0], parse_tree),

            101 => self.add_operator_101(&children[0], parse_tree),

            102 => self.unary_op_102(&children[0], parse_tree),

            103 => self.ident_103(&children[0], parse_tree),

            104 => self.integer_104(&children[0], parse_tree),

            _ => panic!("Unhandled production number: {}", prod_num),
        }
    }
}
