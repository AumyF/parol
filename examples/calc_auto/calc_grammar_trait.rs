// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

#[allow(unused_imports)]
use crate::calc_grammar::CalcGrammar;
use id_tree::Tree;
use log::trace;
use miette::{miette, IntoDiagnostic, Result};
use parol_runtime::lexer::OwnedToken;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};
use std::path::{Path, PathBuf};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait CalcGrammarTrait {
    fn init(&mut self, _file_name: &Path) {}

    /// Semantic action for user production 0:
    ///
    /// calc: {instruction <0>";"};
    ///
    fn calc(&mut self, _arg: Calc) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 1:
    ///
    /// equality_op: <0>"==|!=";
    ///
    fn equality_op(&mut self, _arg: EqualityOp) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 2:
    ///
    /// assign_op: <0>"(\+|-|\*|/|%|<<|>>|&|\^|\|)?=";
    ///
    fn assign_op(&mut self, _arg: AssignOp) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 3:
    ///
    /// logical_or_op: <0>"\|\|";
    ///
    fn logical_or_op(&mut self, _arg: LogicalOrOp) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 4:
    ///
    /// logical_and_op: <0>"&&";
    ///
    fn logical_and_op(&mut self, _arg: LogicalAndOp) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 5:
    ///
    /// bitwise_or_op: <0>"\|";
    ///
    fn bitwise_or_op(&mut self, _arg: BitwiseOrOp) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 6:
    ///
    /// bitwise_and_op: <0>"&";
    ///
    fn bitwise_and_op(&mut self, _arg: BitwiseAndOp) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 7:
    ///
    /// bitwise_shift_op: <0>"<<|>>";
    ///
    fn bitwise_shift_op(&mut self, _arg: BitwiseShiftOp) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 8:
    ///
    /// relational_op: <0>"<=|<|>=|>";
    ///
    fn relational_op(&mut self, _arg: RelationalOp) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 9:
    ///
    /// plus: <0>"\+";
    ///
    fn plus(&mut self, _arg: Plus) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 10:
    ///
    /// minus: <0>"-";
    ///
    fn minus(&mut self, _arg: Minus) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 11:
    ///
    /// pow_op: <0>"\*\*";
    ///
    fn pow_op(&mut self, _arg: PowOp) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 12:
    ///
    /// mult_op: <0>"\*|/|%";
    ///
    fn mult_op(&mut self, _arg: MultOp) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 13:
    ///
    /// instruction: assignment;
    ///
    fn instruction(&mut self, _arg: Instruction) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 15:
    ///
    /// assign_item: id assign_op;
    ///
    fn assign_item(&mut self, _arg: AssignItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 16:
    ///
    /// assignment: assign_item {assign_item} logical_or;
    ///
    fn assignment(&mut self, _arg: Assignment) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 17:
    ///
    /// logical_or: logical_and {logical_or_op logical_and};
    ///
    fn logical_or(&mut self, _arg: LogicalOr) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 18:
    ///
    /// logical_and: bitwise_or {logical_and_op bitwise_or};
    ///
    fn logical_and(&mut self, _arg: LogicalAnd) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 19:
    ///
    /// bitwise_or: bitwise_and {bitwise_or_op bitwise_and};
    ///
    fn bitwise_or(&mut self, _arg: BitwiseOr) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 20:
    ///
    /// bitwise_and: equality {bitwise_and_op equality};
    ///
    fn bitwise_and(&mut self, _arg: BitwiseAnd) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 21:
    ///
    /// equality: relational {equality_op relational};
    ///
    fn equality(&mut self, _arg: Equality) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 22:
    ///
    /// relational: bitwise_shift {relational_op bitwise_shift};
    ///
    fn relational(&mut self, _arg: Relational) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 23:
    ///
    /// bitwise_shift: summ {bitwise_shift_op summ};
    ///
    fn bitwise_shift(&mut self, _arg: BitwiseShift) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 24:
    ///
    /// add_op: plus | minus;
    ///
    fn add_op(&mut self, _arg: AddOp) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 25:
    ///
    /// summ: mult {add_op mult};
    ///
    fn summ(&mut self, _arg: Summ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 26:
    ///
    /// mult: power {mult_op power};
    ///
    fn mult(&mut self, _arg: Mult) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 27:
    ///
    /// power: factor {pow_op factor};
    ///
    fn power(&mut self, _arg: Power) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 28:
    ///
    /// negate: minus;
    ///
    fn negate(&mut self, _arg: Negate) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 29:
    ///
    /// factor: number | idref | negate factor | <0>"\(" logical_or <0>"\)";
    ///
    fn factor(&mut self, _arg: Factor) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 30:
    ///
    /// number: <0>"0|[1-9][0-9]*";
    ///
    fn number(&mut self, _arg: Number) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 31:
    ///
    /// idref: id;
    ///
    fn idref(&mut self, _arg: Idref) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 32:
    ///
    /// id: <0>"[a-zA-Z_][a-zA-Z0-9_]*";
    ///
    fn id(&mut self, _arg: Id) -> Result<()> {
        Ok(())
    }
}

//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 15
///
/// instruction: assignment;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Instruction15 {
    pub assignment_0: Box<Assignment>,
}

///
/// Type derived for production 16
///
/// instruction: logical_or;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Instruction16 {
    pub logical_or_0: Box<LogicalOr>,
}

///
/// Type derived for production 42
///
/// add_op: plus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AddOp42 {
    pub plus_0: Box<Plus>,
}

///
/// Type derived for production 43
///
/// add_op: minus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AddOp43 {
    pub minus_0: Box<Minus>,
}

///
/// Type derived for production 54
///
/// factor: number;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor54 {
    pub number_0: Box<Number>,
}

///
/// Type derived for production 55
///
/// factor: idref;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor55 {
    pub idref_0: Box<Idref>,
}

///
/// Type derived for production 56
///
/// factor: negate factor;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor56 {
    pub negate_0: Box<Negate>,
    pub factor_1: Box<Factor>,
}

///
/// Type derived for production 57
///
/// factor: "\(" logical_or "\)";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor57 {
    pub l_paren_0: OwnedToken, /* \( */
    pub logical_or_1: Box<LogicalOr>,
    pub r_paren_2: OwnedToken, /* \) */
}

//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal add_op
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AddOp {
    AddOp42(AddOp42),
    AddOp43(AddOp43),
}

///
/// Type derived for non-terminal assign_item
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AssignItem {
    pub id_0: Box<Id>,
    pub assign_op_1: Box<AssignOp>,
}

///
/// Type derived for non-terminal assign_op
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AssignOp {
    pub assign_op_0: OwnedToken, /* (\+|-|\*|/|%|<<|>>|&|\^|\|)?= */
}

///
/// Type derived for non-terminal assignment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Assignment {
    pub assign_item_0: Box<AssignItem>,
    pub assignment_list_1: Vec<AssignmentList>,
    pub logical_or_2: Box<LogicalOr>,
}

///
/// Type derived for non-terminal assignmentList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AssignmentList {
    pub assign_item_0: Box<AssignItem>,
}

///
/// Type derived for non-terminal bitwise_and
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BitwiseAnd {
    pub equality_0: Box<Equality>,
    pub bitwise_and_list_1: Vec<BitwiseAndList>,
}

///
/// Type derived for non-terminal bitwise_andList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BitwiseAndList {
    pub bitwise_and_op_0: Box<BitwiseAndOp>,
    pub equality_1: Box<Equality>,
}

///
/// Type derived for non-terminal bitwise_and_op
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BitwiseAndOp {
    pub bitwise_and_op_0: OwnedToken, /* & */
}

///
/// Type derived for non-terminal bitwise_or
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BitwiseOr {
    pub bitwise_and_0: Box<BitwiseAnd>,
    pub bitwise_or_list_1: Vec<BitwiseOrList>,
}

///
/// Type derived for non-terminal bitwise_orList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BitwiseOrList {
    pub bitwise_or_op_0: Box<BitwiseOrOp>,
    pub bitwise_and_1: Box<BitwiseAnd>,
}

///
/// Type derived for non-terminal bitwise_or_op
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BitwiseOrOp {
    pub bitwise_or_op_0: OwnedToken, /* \| */
}

///
/// Type derived for non-terminal bitwise_shift
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BitwiseShift {
    pub summ_0: Box<Summ>,
    pub bitwise_shift_list_1: Vec<BitwiseShiftList>,
}

///
/// Type derived for non-terminal bitwise_shiftList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BitwiseShiftList {
    pub bitwise_shift_op_0: Box<BitwiseShiftOp>,
    pub summ_1: Box<Summ>,
}

///
/// Type derived for non-terminal bitwise_shift_op
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BitwiseShiftOp {
    pub bitwise_shift_op_0: OwnedToken, /* <<|>> */
}

///
/// Type derived for non-terminal calc
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Calc {
    pub calc_list_0: Vec<CalcList>,
}

///
/// Type derived for non-terminal calcList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CalcList {
    pub instruction_0: Box<Instruction>,
    pub semicolon_1: OwnedToken, /* ; */
}

///
/// Type derived for non-terminal equality
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Equality {
    pub relational_0: Box<Relational>,
    pub equality_list_1: Vec<EqualityList>,
}

///
/// Type derived for non-terminal equalityList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct EqualityList {
    pub equality_op_0: Box<EqualityOp>,
    pub relational_1: Box<Relational>,
}

///
/// Type derived for non-terminal equality_op
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct EqualityOp {
    pub equality_op_0: OwnedToken, /* ==|!= */
}

///
/// Type derived for non-terminal factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor {
    Factor54(Factor54),
    Factor55(Factor55),
    Factor56(Factor56),
    Factor57(Factor57),
}

///
/// Type derived for non-terminal id
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Id {
    pub id_0: OwnedToken, /* [a-zA-Z_][a-zA-Z0-9_]* */
}

///
/// Type derived for non-terminal idref
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Idref {
    pub id_0: Box<Id>,
}

///
/// Type derived for non-terminal instruction
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Instruction {
    Instruction15(Instruction15),
    Instruction16(Instruction16),
}

///
/// Type derived for non-terminal logical_and
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalAnd {
    pub bitwise_or_0: Box<BitwiseOr>,
    pub logical_and_list_1: Vec<LogicalAndList>,
}

///
/// Type derived for non-terminal logical_andList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalAndList {
    pub logical_and_op_0: Box<LogicalAndOp>,
    pub bitwise_or_1: Box<BitwiseOr>,
}

///
/// Type derived for non-terminal logical_and_op
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalAndOp {
    pub logical_and_op_0: OwnedToken, /* && */
}

///
/// Type derived for non-terminal logical_or
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalOr {
    pub logical_and_0: Box<LogicalAnd>,
    pub logical_or_list_1: Vec<LogicalOrList>,
}

///
/// Type derived for non-terminal logical_orList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalOrList {
    pub logical_or_op_0: Box<LogicalOrOp>,
    pub logical_and_1: Box<LogicalAnd>,
}

///
/// Type derived for non-terminal logical_or_op
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalOrOp {
    pub logical_or_op_0: OwnedToken, /* \|\| */
}

///
/// Type derived for non-terminal minus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Minus {
    pub minus_0: OwnedToken, /* - */
}

///
/// Type derived for non-terminal mult
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Mult {
    pub power_0: Box<Power>,
    pub mult_list_1: Vec<MultList>,
}

///
/// Type derived for non-terminal multList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MultList {
    pub mult_op_0: Box<MultOp>,
    pub power_1: Box<Power>,
}

///
/// Type derived for non-terminal mult_op
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MultOp {
    pub mult_op_0: OwnedToken, /* \*|/|% */
}

///
/// Type derived for non-terminal negate
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Negate {
    pub minus_0: Box<Minus>,
}

///
/// Type derived for non-terminal number
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number {
    pub number_0: OwnedToken, /* 0|[1-9][0-9]* */
}

///
/// Type derived for non-terminal plus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Plus {
    pub plus_0: OwnedToken, /* \+ */
}

///
/// Type derived for non-terminal pow_op
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct PowOp {
    pub pow_op_0: OwnedToken, /* \*\* */
}

///
/// Type derived for non-terminal power
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Power {
    pub factor_0: Box<Factor>,
    pub power_list_1: Vec<PowerList>,
}

///
/// Type derived for non-terminal powerList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct PowerList {
    pub pow_op_0: Box<PowOp>,
    pub factor_1: Box<Factor>,
}

///
/// Type derived for non-terminal relational
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relational {
    pub bitwise_shift_0: Box<BitwiseShift>,
    pub relational_list_1: Vec<RelationalList>,
}

///
/// Type derived for non-terminal relationalList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RelationalList {
    pub relational_op_0: Box<RelationalOp>,
    pub bitwise_shift_1: Box<BitwiseShift>,
}

///
/// Type derived for non-terminal relational_op
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RelationalOp {
    pub relational_op_0: OwnedToken, /* <=|<|>=|> */
}

///
/// Type derived for non-terminal summ
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Summ {
    pub mult_0: Box<Mult>,
    pub summ_list_1: Vec<SummList>,
}

///
/// Type derived for non-terminal summList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SummList {
    pub add_op_0: Box<AddOp>,
    pub mult_1: Box<Mult>,
}

//
// AST type of the transformed grammar
//

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType {
    AddOp(AddOp),
    AssignItem(AssignItem),
    AssignOp(AssignOp),
    Assignment(Assignment),
    AssignmentList(Vec<AssignmentList>),
    BitwiseAnd(BitwiseAnd),
    BitwiseAndList(Vec<BitwiseAndList>),
    BitwiseAndOp(BitwiseAndOp),
    BitwiseOr(BitwiseOr),
    BitwiseOrList(Vec<BitwiseOrList>),
    BitwiseOrOp(BitwiseOrOp),
    BitwiseShift(BitwiseShift),
    BitwiseShiftList(Vec<BitwiseShiftList>),
    BitwiseShiftOp(BitwiseShiftOp),
    Calc(Calc),
    CalcList(Vec<CalcList>),
    Equality(Equality),
    EqualityList(Vec<EqualityList>),
    EqualityOp(EqualityOp),
    Factor(Factor),
    Id(Id),
    Idref(Idref),
    Instruction(Instruction),
    LogicalAnd(LogicalAnd),
    LogicalAndList(Vec<LogicalAndList>),
    LogicalAndOp(LogicalAndOp),
    LogicalOr(LogicalOr),
    LogicalOrList(Vec<LogicalOrList>),
    LogicalOrOp(LogicalOrOp),
    Minus(Minus),
    Mult(Mult),
    MultList(Vec<MultList>),
    MultOp(MultOp),
    Negate(Negate),
    Number(Number),
    Plus(Plus),
    PowOp(PowOp),
    Power(Power),
    PowerList(Vec<PowerList>),
    Relational(Relational),
    RelationalList(Vec<RelationalList>),
    RelationalOp(RelationalOp),
    Summ(Summ),
    SummList(Vec<SummList>),
}

/// Auto-implemented adapter grammar
#[allow(dead_code)]
pub struct CalcGrammarAuto<'a> {
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'a mut dyn CalcGrammarTrait,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType>,
    // Path of the input file. Used for diagnostics.
    file_name: PathBuf,
}

///
/// The `CalcGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'a> CalcGrammarAuto<'a> {
    pub fn new(user_grammar: &'a mut dyn CalcGrammarTrait) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            file_name: PathBuf::default(),
        }
    }

    fn push(&mut self, item: ASTType, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    fn pop(&mut self, context: &str) -> Option<ASTType> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// calc: calcList /* Vec */;
    ///
    fn calc_0(
        &mut self,
        _calc_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "calc_0";
        trace!("{}", self.trace_item_stack(context));
        let calc_list_0 = if let Some(ASTType::CalcList(mut calc_list_0)) = self.pop(context) {
            calc_list_0.reverse();
            calc_list_0
        } else {
            Err(miette!("{}: Expecting ASTType::CalcList", context))?
        };
        let calc_0 = CalcBuilder::default()
            .calc_list_0(calc_list_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.calc(calc_0.clone())?;
        self.push(ASTType::Calc(calc_0), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// calcList: instruction ";" calcList; // Vec<T>::Push
    ///
    fn calc_list_1(
        &mut self,
        _instruction_0: &ParseTreeStackEntry,
        semicolon_1: &ParseTreeStackEntry,
        _calc_list_2: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "calc_list_1";
        trace!("{}", self.trace_item_stack(context));
        let semicolon_1 = semicolon_1.token(parse_tree)?.to_owned();
        let mut calc_list_2 = if let Some(ASTType::CalcList(calc_list_2)) = self.pop(context) {
            calc_list_2
        } else {
            Err(miette!("{}: Expecting ASTType::CalcList", context))?
        };
        let instruction_0 = if let Some(ASTType::Instruction(instruction_0)) = self.pop(context) {
            instruction_0
        } else {
            Err(miette!("{}: Expecting ASTType::Instruction", context))?
        };
        let calc_list_1 = CalcListBuilder::default()
            .semicolon_1(semicolon_1)
            .instruction_0(Box::new(instruction_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        calc_list_2.push(calc_list_1);
        self.push(ASTType::CalcList(calc_list_2), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// calcList: ; // Vec<T>::New
    ///
    fn calc_list_2(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        let context = "calc_list_2";
        trace!("{}", self.trace_item_stack(context));
        let calc_list_2 = Vec::new();
        self.push(ASTType::CalcList(calc_list_2), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// equality_op: "==|!=";
    ///
    fn equality_op_3(
        &mut self,
        equality_op_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "equality_op_3";
        trace!("{}", self.trace_item_stack(context));
        let equality_op_0 = equality_op_0.token(parse_tree)?.to_owned();
        let equality_op_3 = EqualityOpBuilder::default()
            .equality_op_0(equality_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.equality_op(equality_op_3.clone())?;
        self.push(ASTType::EqualityOp(equality_op_3), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// assign_op: "(\+|-|\*|/|%|<<|>>|&|\^|\|)?=";
    ///
    fn assign_op_4(
        &mut self,
        assign_op_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "assign_op_4";
        trace!("{}", self.trace_item_stack(context));
        let assign_op_0 = assign_op_0.token(parse_tree)?.to_owned();
        let assign_op_4 = AssignOpBuilder::default()
            .assign_op_0(assign_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.assign_op(assign_op_4.clone())?;
        self.push(ASTType::AssignOp(assign_op_4), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// logical_or_op: "\|\|";
    ///
    fn logical_or_op_5(
        &mut self,
        logical_or_op_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "logical_or_op_5";
        trace!("{}", self.trace_item_stack(context));
        let logical_or_op_0 = logical_or_op_0.token(parse_tree)?.to_owned();
        let logical_or_op_5 = LogicalOrOpBuilder::default()
            .logical_or_op_0(logical_or_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_or_op(logical_or_op_5.clone())?;
        self.push(ASTType::LogicalOrOp(logical_or_op_5), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// logical_and_op: "&&";
    ///
    fn logical_and_op_6(
        &mut self,
        logical_and_op_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "logical_and_op_6";
        trace!("{}", self.trace_item_stack(context));
        let logical_and_op_0 = logical_and_op_0.token(parse_tree)?.to_owned();
        let logical_and_op_6 = LogicalAndOpBuilder::default()
            .logical_and_op_0(logical_and_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_and_op(logical_and_op_6.clone())?;
        self.push(ASTType::LogicalAndOp(logical_and_op_6), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// bitwise_or_op: "\|";
    ///
    fn bitwise_or_op_7(
        &mut self,
        bitwise_or_op_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "bitwise_or_op_7";
        trace!("{}", self.trace_item_stack(context));
        let bitwise_or_op_0 = bitwise_or_op_0.token(parse_tree)?.to_owned();
        let bitwise_or_op_7 = BitwiseOrOpBuilder::default()
            .bitwise_or_op_0(bitwise_or_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bitwise_or_op(bitwise_or_op_7.clone())?;
        self.push(ASTType::BitwiseOrOp(bitwise_or_op_7), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// bitwise_and_op: "&";
    ///
    fn bitwise_and_op_8(
        &mut self,
        bitwise_and_op_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "bitwise_and_op_8";
        trace!("{}", self.trace_item_stack(context));
        let bitwise_and_op_0 = bitwise_and_op_0.token(parse_tree)?.to_owned();
        let bitwise_and_op_8 = BitwiseAndOpBuilder::default()
            .bitwise_and_op_0(bitwise_and_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bitwise_and_op(bitwise_and_op_8.clone())?;
        self.push(ASTType::BitwiseAndOp(bitwise_and_op_8), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// bitwise_shift_op: "<<|>>";
    ///
    fn bitwise_shift_op_9(
        &mut self,
        bitwise_shift_op_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "bitwise_shift_op_9";
        trace!("{}", self.trace_item_stack(context));
        let bitwise_shift_op_0 = bitwise_shift_op_0.token(parse_tree)?.to_owned();
        let bitwise_shift_op_9 = BitwiseShiftOpBuilder::default()
            .bitwise_shift_op_0(bitwise_shift_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .bitwise_shift_op(bitwise_shift_op_9.clone())?;
        self.push(ASTType::BitwiseShiftOp(bitwise_shift_op_9), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// relational_op: "<=|<|>=|>";
    ///
    fn relational_op_10(
        &mut self,
        relational_op_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "relational_op_10";
        trace!("{}", self.trace_item_stack(context));
        let relational_op_0 = relational_op_0.token(parse_tree)?.to_owned();
        let relational_op_10 = RelationalOpBuilder::default()
            .relational_op_0(relational_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.relational_op(relational_op_10.clone())?;
        self.push(ASTType::RelationalOp(relational_op_10), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// plus: "\+";
    ///
    fn plus_11(
        &mut self,
        plus_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "plus_11";
        trace!("{}", self.trace_item_stack(context));
        let plus_0 = plus_0.token(parse_tree)?.to_owned();
        let plus_11 = PlusBuilder::default()
            .plus_0(plus_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.plus(plus_11.clone())?;
        self.push(ASTType::Plus(plus_11), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// minus: "-";
    ///
    fn minus_12(
        &mut self,
        minus_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "minus_12";
        trace!("{}", self.trace_item_stack(context));
        let minus_0 = minus_0.token(parse_tree)?.to_owned();
        let minus_12 = MinusBuilder::default()
            .minus_0(minus_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.minus(minus_12.clone())?;
        self.push(ASTType::Minus(minus_12), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// pow_op: "\*\*";
    ///
    fn pow_op_13(
        &mut self,
        pow_op_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "pow_op_13";
        trace!("{}", self.trace_item_stack(context));
        let pow_op_0 = pow_op_0.token(parse_tree)?.to_owned();
        let pow_op_13 = PowOpBuilder::default()
            .pow_op_0(pow_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.pow_op(pow_op_13.clone())?;
        self.push(ASTType::PowOp(pow_op_13), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// mult_op: "\*|/|%";
    ///
    fn mult_op_14(
        &mut self,
        mult_op_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "mult_op_14";
        trace!("{}", self.trace_item_stack(context));
        let mult_op_0 = mult_op_0.token(parse_tree)?.to_owned();
        let mult_op_14 = MultOpBuilder::default()
            .mult_op_0(mult_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.mult_op(mult_op_14.clone())?;
        self.push(ASTType::MultOp(mult_op_14), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// instruction: assignment;
    ///
    fn instruction_15(
        &mut self,
        _assignment_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "instruction_15";
        trace!("{}", self.trace_item_stack(context));
        let assignment_0 = if let Some(ASTType::Assignment(assignment_0)) = self.pop(context) {
            assignment_0
        } else {
            Err(miette!("{}: Expecting ASTType::Assignment", context))?
        };
        let instruction_15 = Instruction15Builder::default()
            .assignment_0(Box::new(assignment_0))
            .build()
            .into_diagnostic()?;
        let instruction_15 = Instruction::Instruction15(instruction_15);
        // Calling user action here
        self.user_grammar.instruction(instruction_15.clone())?;
        self.push(ASTType::Instruction(instruction_15), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// instruction: logical_or;
    ///
    fn instruction_16(
        &mut self,
        _logical_or_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "instruction_16";
        trace!("{}", self.trace_item_stack(context));
        let logical_or_0 = if let Some(ASTType::LogicalOr(logical_or_0)) = self.pop(context) {
            logical_or_0
        } else {
            Err(miette!("{}: Expecting ASTType::LogicalOr", context))?
        };
        let instruction_16 = Instruction16Builder::default()
            .logical_or_0(Box::new(logical_or_0))
            .build()
            .into_diagnostic()?;
        let instruction_16 = Instruction::Instruction16(instruction_16);
        // Calling user action here
        self.user_grammar.instruction(instruction_16.clone())?;
        self.push(ASTType::Instruction(instruction_16), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// assign_item: id assign_op;
    ///
    fn assign_item_17(
        &mut self,
        _id_0: &ParseTreeStackEntry,
        _assign_op_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "assign_item_17";
        trace!("{}", self.trace_item_stack(context));
        let assign_op_1 = if let Some(ASTType::AssignOp(assign_op_1)) = self.pop(context) {
            assign_op_1
        } else {
            Err(miette!("{}: Expecting ASTType::AssignOp", context))?
        };
        let id_0 = if let Some(ASTType::Id(id_0)) = self.pop(context) {
            id_0
        } else {
            Err(miette!("{}: Expecting ASTType::Id", context))?
        };
        let assign_item_17 = AssignItemBuilder::default()
            .id_0(Box::new(id_0))
            .assign_op_1(Box::new(assign_op_1))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.assign_item(assign_item_17.clone())?;
        self.push(ASTType::AssignItem(assign_item_17), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// assignment: assign_item assignmentList /* Vec */ logical_or;
    ///
    fn assignment_18(
        &mut self,
        _assign_item_0: &ParseTreeStackEntry,
        _assignment_list_1: &ParseTreeStackEntry,
        _logical_or_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "assignment_18";
        trace!("{}", self.trace_item_stack(context));
        let logical_or_2 = if let Some(ASTType::LogicalOr(logical_or_2)) = self.pop(context) {
            logical_or_2
        } else {
            Err(miette!("{}: Expecting ASTType::LogicalOr", context))?
        };
        let assignment_list_1 =
            if let Some(ASTType::AssignmentList(mut assignment_list_1)) = self.pop(context) {
                assignment_list_1.reverse();
                assignment_list_1
            } else {
                Err(miette!("{}: Expecting ASTType::AssignmentList", context))?
            };
        let assign_item_0 = if let Some(ASTType::AssignItem(assign_item_0)) = self.pop(context) {
            assign_item_0
        } else {
            Err(miette!("{}: Expecting ASTType::AssignItem", context))?
        };
        let assignment_18 = AssignmentBuilder::default()
            .assign_item_0(Box::new(assign_item_0))
            .assignment_list_1(assignment_list_1)
            .logical_or_2(Box::new(logical_or_2))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.assignment(assignment_18.clone())?;
        self.push(ASTType::Assignment(assignment_18), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// assignmentList: assign_item assignmentList; // Vec<T>::Push
    ///
    fn assignment_list_19(
        &mut self,
        _assign_item_0: &ParseTreeStackEntry,
        _assignment_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "assignment_list_19";
        trace!("{}", self.trace_item_stack(context));
        let mut assignment_list_1 =
            if let Some(ASTType::AssignmentList(assignment_list_1)) = self.pop(context) {
                assignment_list_1
            } else {
                Err(miette!("{}: Expecting ASTType::AssignmentList", context))?
            };
        let assign_item_0 = if let Some(ASTType::AssignItem(assign_item_0)) = self.pop(context) {
            assign_item_0
        } else {
            Err(miette!("{}: Expecting ASTType::AssignItem", context))?
        };
        let assignment_list_19 = AssignmentListBuilder::default()
            .assign_item_0(Box::new(assign_item_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        assignment_list_1.push(assignment_list_19);
        self.push(ASTType::AssignmentList(assignment_list_1), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// assignmentList: ; // Vec<T>::New
    ///
    fn assignment_list_20(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        let context = "assignment_list_20";
        trace!("{}", self.trace_item_stack(context));
        let assignment_list_20 = Vec::new();
        self.push(ASTType::AssignmentList(assignment_list_20), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// logical_or: logical_and logical_orList /* Vec */;
    ///
    fn logical_or_21(
        &mut self,
        _logical_and_0: &ParseTreeStackEntry,
        _logical_or_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "logical_or_21";
        trace!("{}", self.trace_item_stack(context));
        let logical_or_list_1 =
            if let Some(ASTType::LogicalOrList(mut logical_or_list_1)) = self.pop(context) {
                logical_or_list_1.reverse();
                logical_or_list_1
            } else {
                Err(miette!("{}: Expecting ASTType::LogicalOrList", context))?
            };
        let logical_and_0 = if let Some(ASTType::LogicalAnd(logical_and_0)) = self.pop(context) {
            logical_and_0
        } else {
            Err(miette!("{}: Expecting ASTType::LogicalAnd", context))?
        };
        let logical_or_21 = LogicalOrBuilder::default()
            .logical_and_0(Box::new(logical_and_0))
            .logical_or_list_1(logical_or_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_or(logical_or_21.clone())?;
        self.push(ASTType::LogicalOr(logical_or_21), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// logical_orList: logical_or_op logical_and logical_orList; // Vec<T>::Push
    ///
    fn logical_or_list_22(
        &mut self,
        _logical_or_op_0: &ParseTreeStackEntry,
        _logical_and_1: &ParseTreeStackEntry,
        _logical_or_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "logical_or_list_22";
        trace!("{}", self.trace_item_stack(context));
        let mut logical_or_list_2 =
            if let Some(ASTType::LogicalOrList(logical_or_list_2)) = self.pop(context) {
                logical_or_list_2
            } else {
                Err(miette!("{}: Expecting ASTType::LogicalOrList", context))?
            };
        let logical_and_1 = if let Some(ASTType::LogicalAnd(logical_and_1)) = self.pop(context) {
            logical_and_1
        } else {
            Err(miette!("{}: Expecting ASTType::LogicalAnd", context))?
        };
        let logical_or_op_0 = if let Some(ASTType::LogicalOrOp(logical_or_op_0)) = self.pop(context)
        {
            logical_or_op_0
        } else {
            Err(miette!("{}: Expecting ASTType::LogicalOrOp", context))?
        };
        let logical_or_list_22 = LogicalOrListBuilder::default()
            .logical_and_1(Box::new(logical_and_1))
            .logical_or_op_0(Box::new(logical_or_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        logical_or_list_2.push(logical_or_list_22);
        self.push(ASTType::LogicalOrList(logical_or_list_2), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// logical_orList: ; // Vec<T>::New
    ///
    fn logical_or_list_23(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        let context = "logical_or_list_23";
        trace!("{}", self.trace_item_stack(context));
        let logical_or_list_23 = Vec::new();
        self.push(ASTType::LogicalOrList(logical_or_list_23), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// logical_and: bitwise_or logical_andList /* Vec */;
    ///
    fn logical_and_24(
        &mut self,
        _bitwise_or_0: &ParseTreeStackEntry,
        _logical_and_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "logical_and_24";
        trace!("{}", self.trace_item_stack(context));
        let logical_and_list_1 =
            if let Some(ASTType::LogicalAndList(mut logical_and_list_1)) = self.pop(context) {
                logical_and_list_1.reverse();
                logical_and_list_1
            } else {
                Err(miette!("{}: Expecting ASTType::LogicalAndList", context))?
            };
        let bitwise_or_0 = if let Some(ASTType::BitwiseOr(bitwise_or_0)) = self.pop(context) {
            bitwise_or_0
        } else {
            Err(miette!("{}: Expecting ASTType::BitwiseOr", context))?
        };
        let logical_and_24 = LogicalAndBuilder::default()
            .bitwise_or_0(Box::new(bitwise_or_0))
            .logical_and_list_1(logical_and_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_and(logical_and_24.clone())?;
        self.push(ASTType::LogicalAnd(logical_and_24), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// logical_andList: logical_and_op bitwise_or logical_andList; // Vec<T>::Push
    ///
    fn logical_and_list_25(
        &mut self,
        _logical_and_op_0: &ParseTreeStackEntry,
        _bitwise_or_1: &ParseTreeStackEntry,
        _logical_and_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "logical_and_list_25";
        trace!("{}", self.trace_item_stack(context));
        let mut logical_and_list_2 =
            if let Some(ASTType::LogicalAndList(logical_and_list_2)) = self.pop(context) {
                logical_and_list_2
            } else {
                Err(miette!("{}: Expecting ASTType::LogicalAndList", context))?
            };
        let bitwise_or_1 = if let Some(ASTType::BitwiseOr(bitwise_or_1)) = self.pop(context) {
            bitwise_or_1
        } else {
            Err(miette!("{}: Expecting ASTType::BitwiseOr", context))?
        };
        let logical_and_op_0 =
            if let Some(ASTType::LogicalAndOp(logical_and_op_0)) = self.pop(context) {
                logical_and_op_0
            } else {
                Err(miette!("{}: Expecting ASTType::LogicalAndOp", context))?
            };
        let logical_and_list_25 = LogicalAndListBuilder::default()
            .bitwise_or_1(Box::new(bitwise_or_1))
            .logical_and_op_0(Box::new(logical_and_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        logical_and_list_2.push(logical_and_list_25);
        self.push(ASTType::LogicalAndList(logical_and_list_2), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// logical_andList: ; // Vec<T>::New
    ///
    fn logical_and_list_26(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        let context = "logical_and_list_26";
        trace!("{}", self.trace_item_stack(context));
        let logical_and_list_26 = Vec::new();
        self.push(ASTType::LogicalAndList(logical_and_list_26), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// bitwise_or: bitwise_and bitwise_orList /* Vec */;
    ///
    fn bitwise_or_27(
        &mut self,
        _bitwise_and_0: &ParseTreeStackEntry,
        _bitwise_or_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "bitwise_or_27";
        trace!("{}", self.trace_item_stack(context));
        let bitwise_or_list_1 =
            if let Some(ASTType::BitwiseOrList(mut bitwise_or_list_1)) = self.pop(context) {
                bitwise_or_list_1.reverse();
                bitwise_or_list_1
            } else {
                Err(miette!("{}: Expecting ASTType::BitwiseOrList", context))?
            };
        let bitwise_and_0 = if let Some(ASTType::BitwiseAnd(bitwise_and_0)) = self.pop(context) {
            bitwise_and_0
        } else {
            Err(miette!("{}: Expecting ASTType::BitwiseAnd", context))?
        };
        let bitwise_or_27 = BitwiseOrBuilder::default()
            .bitwise_and_0(Box::new(bitwise_and_0))
            .bitwise_or_list_1(bitwise_or_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bitwise_or(bitwise_or_27.clone())?;
        self.push(ASTType::BitwiseOr(bitwise_or_27), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// bitwise_orList: bitwise_or_op bitwise_and bitwise_orList; // Vec<T>::Push
    ///
    fn bitwise_or_list_28(
        &mut self,
        _bitwise_or_op_0: &ParseTreeStackEntry,
        _bitwise_and_1: &ParseTreeStackEntry,
        _bitwise_or_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "bitwise_or_list_28";
        trace!("{}", self.trace_item_stack(context));
        let mut bitwise_or_list_2 =
            if let Some(ASTType::BitwiseOrList(bitwise_or_list_2)) = self.pop(context) {
                bitwise_or_list_2
            } else {
                Err(miette!("{}: Expecting ASTType::BitwiseOrList", context))?
            };
        let bitwise_and_1 = if let Some(ASTType::BitwiseAnd(bitwise_and_1)) = self.pop(context) {
            bitwise_and_1
        } else {
            Err(miette!("{}: Expecting ASTType::BitwiseAnd", context))?
        };
        let bitwise_or_op_0 = if let Some(ASTType::BitwiseOrOp(bitwise_or_op_0)) = self.pop(context)
        {
            bitwise_or_op_0
        } else {
            Err(miette!("{}: Expecting ASTType::BitwiseOrOp", context))?
        };
        let bitwise_or_list_28 = BitwiseOrListBuilder::default()
            .bitwise_and_1(Box::new(bitwise_and_1))
            .bitwise_or_op_0(Box::new(bitwise_or_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        bitwise_or_list_2.push(bitwise_or_list_28);
        self.push(ASTType::BitwiseOrList(bitwise_or_list_2), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// bitwise_orList: ; // Vec<T>::New
    ///
    fn bitwise_or_list_29(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        let context = "bitwise_or_list_29";
        trace!("{}", self.trace_item_stack(context));
        let bitwise_or_list_29 = Vec::new();
        self.push(ASTType::BitwiseOrList(bitwise_or_list_29), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// bitwise_and: equality bitwise_andList /* Vec */;
    ///
    fn bitwise_and_30(
        &mut self,
        _equality_0: &ParseTreeStackEntry,
        _bitwise_and_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "bitwise_and_30";
        trace!("{}", self.trace_item_stack(context));
        let bitwise_and_list_1 =
            if let Some(ASTType::BitwiseAndList(mut bitwise_and_list_1)) = self.pop(context) {
                bitwise_and_list_1.reverse();
                bitwise_and_list_1
            } else {
                Err(miette!("{}: Expecting ASTType::BitwiseAndList", context))?
            };
        let equality_0 = if let Some(ASTType::Equality(equality_0)) = self.pop(context) {
            equality_0
        } else {
            Err(miette!("{}: Expecting ASTType::Equality", context))?
        };
        let bitwise_and_30 = BitwiseAndBuilder::default()
            .equality_0(Box::new(equality_0))
            .bitwise_and_list_1(bitwise_and_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bitwise_and(bitwise_and_30.clone())?;
        self.push(ASTType::BitwiseAnd(bitwise_and_30), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// bitwise_andList: bitwise_and_op equality bitwise_andList; // Vec<T>::Push
    ///
    fn bitwise_and_list_31(
        &mut self,
        _bitwise_and_op_0: &ParseTreeStackEntry,
        _equality_1: &ParseTreeStackEntry,
        _bitwise_and_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "bitwise_and_list_31";
        trace!("{}", self.trace_item_stack(context));
        let mut bitwise_and_list_2 =
            if let Some(ASTType::BitwiseAndList(bitwise_and_list_2)) = self.pop(context) {
                bitwise_and_list_2
            } else {
                Err(miette!("{}: Expecting ASTType::BitwiseAndList", context))?
            };
        let equality_1 = if let Some(ASTType::Equality(equality_1)) = self.pop(context) {
            equality_1
        } else {
            Err(miette!("{}: Expecting ASTType::Equality", context))?
        };
        let bitwise_and_op_0 =
            if let Some(ASTType::BitwiseAndOp(bitwise_and_op_0)) = self.pop(context) {
                bitwise_and_op_0
            } else {
                Err(miette!("{}: Expecting ASTType::BitwiseAndOp", context))?
            };
        let bitwise_and_list_31 = BitwiseAndListBuilder::default()
            .equality_1(Box::new(equality_1))
            .bitwise_and_op_0(Box::new(bitwise_and_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        bitwise_and_list_2.push(bitwise_and_list_31);
        self.push(ASTType::BitwiseAndList(bitwise_and_list_2), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// bitwise_andList: ; // Vec<T>::New
    ///
    fn bitwise_and_list_32(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        let context = "bitwise_and_list_32";
        trace!("{}", self.trace_item_stack(context));
        let bitwise_and_list_32 = Vec::new();
        self.push(ASTType::BitwiseAndList(bitwise_and_list_32), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// equality: relational equalityList /* Vec */;
    ///
    fn equality_33(
        &mut self,
        _relational_0: &ParseTreeStackEntry,
        _equality_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "equality_33";
        trace!("{}", self.trace_item_stack(context));
        let equality_list_1 =
            if let Some(ASTType::EqualityList(mut equality_list_1)) = self.pop(context) {
                equality_list_1.reverse();
                equality_list_1
            } else {
                Err(miette!("{}: Expecting ASTType::EqualityList", context))?
            };
        let relational_0 = if let Some(ASTType::Relational(relational_0)) = self.pop(context) {
            relational_0
        } else {
            Err(miette!("{}: Expecting ASTType::Relational", context))?
        };
        let equality_33 = EqualityBuilder::default()
            .relational_0(Box::new(relational_0))
            .equality_list_1(equality_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.equality(equality_33.clone())?;
        self.push(ASTType::Equality(equality_33), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// equalityList: equality_op relational equalityList; // Vec<T>::Push
    ///
    fn equality_list_34(
        &mut self,
        _equality_op_0: &ParseTreeStackEntry,
        _relational_1: &ParseTreeStackEntry,
        _equality_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "equality_list_34";
        trace!("{}", self.trace_item_stack(context));
        let mut equality_list_2 =
            if let Some(ASTType::EqualityList(equality_list_2)) = self.pop(context) {
                equality_list_2
            } else {
                Err(miette!("{}: Expecting ASTType::EqualityList", context))?
            };
        let relational_1 = if let Some(ASTType::Relational(relational_1)) = self.pop(context) {
            relational_1
        } else {
            Err(miette!("{}: Expecting ASTType::Relational", context))?
        };
        let equality_op_0 = if let Some(ASTType::EqualityOp(equality_op_0)) = self.pop(context) {
            equality_op_0
        } else {
            Err(miette!("{}: Expecting ASTType::EqualityOp", context))?
        };
        let equality_list_34 = EqualityListBuilder::default()
            .relational_1(Box::new(relational_1))
            .equality_op_0(Box::new(equality_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        equality_list_2.push(equality_list_34);
        self.push(ASTType::EqualityList(equality_list_2), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// equalityList: ; // Vec<T>::New
    ///
    fn equality_list_35(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        let context = "equality_list_35";
        trace!("{}", self.trace_item_stack(context));
        let equality_list_35 = Vec::new();
        self.push(ASTType::EqualityList(equality_list_35), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// relational: bitwise_shift relationalList /* Vec */;
    ///
    fn relational_36(
        &mut self,
        _bitwise_shift_0: &ParseTreeStackEntry,
        _relational_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "relational_36";
        trace!("{}", self.trace_item_stack(context));
        let relational_list_1 =
            if let Some(ASTType::RelationalList(mut relational_list_1)) = self.pop(context) {
                relational_list_1.reverse();
                relational_list_1
            } else {
                Err(miette!("{}: Expecting ASTType::RelationalList", context))?
            };
        let bitwise_shift_0 =
            if let Some(ASTType::BitwiseShift(bitwise_shift_0)) = self.pop(context) {
                bitwise_shift_0
            } else {
                Err(miette!("{}: Expecting ASTType::BitwiseShift", context))?
            };
        let relational_36 = RelationalBuilder::default()
            .bitwise_shift_0(Box::new(bitwise_shift_0))
            .relational_list_1(relational_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.relational(relational_36.clone())?;
        self.push(ASTType::Relational(relational_36), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// relationalList: relational_op bitwise_shift relationalList; // Vec<T>::Push
    ///
    fn relational_list_37(
        &mut self,
        _relational_op_0: &ParseTreeStackEntry,
        _bitwise_shift_1: &ParseTreeStackEntry,
        _relational_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "relational_list_37";
        trace!("{}", self.trace_item_stack(context));
        let mut relational_list_2 =
            if let Some(ASTType::RelationalList(relational_list_2)) = self.pop(context) {
                relational_list_2
            } else {
                Err(miette!("{}: Expecting ASTType::RelationalList", context))?
            };
        let bitwise_shift_1 =
            if let Some(ASTType::BitwiseShift(bitwise_shift_1)) = self.pop(context) {
                bitwise_shift_1
            } else {
                Err(miette!("{}: Expecting ASTType::BitwiseShift", context))?
            };
        let relational_op_0 =
            if let Some(ASTType::RelationalOp(relational_op_0)) = self.pop(context) {
                relational_op_0
            } else {
                Err(miette!("{}: Expecting ASTType::RelationalOp", context))?
            };
        let relational_list_37 = RelationalListBuilder::default()
            .bitwise_shift_1(Box::new(bitwise_shift_1))
            .relational_op_0(Box::new(relational_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        relational_list_2.push(relational_list_37);
        self.push(ASTType::RelationalList(relational_list_2), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// relationalList: ; // Vec<T>::New
    ///
    fn relational_list_38(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        let context = "relational_list_38";
        trace!("{}", self.trace_item_stack(context));
        let relational_list_38 = Vec::new();
        self.push(ASTType::RelationalList(relational_list_38), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// bitwise_shift: summ bitwise_shiftList /* Vec */;
    ///
    fn bitwise_shift_39(
        &mut self,
        _summ_0: &ParseTreeStackEntry,
        _bitwise_shift_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "bitwise_shift_39";
        trace!("{}", self.trace_item_stack(context));
        let bitwise_shift_list_1 =
            if let Some(ASTType::BitwiseShiftList(mut bitwise_shift_list_1)) = self.pop(context) {
                bitwise_shift_list_1.reverse();
                bitwise_shift_list_1
            } else {
                Err(miette!("{}: Expecting ASTType::BitwiseShiftList", context))?
            };
        let summ_0 = if let Some(ASTType::Summ(summ_0)) = self.pop(context) {
            summ_0
        } else {
            Err(miette!("{}: Expecting ASTType::Summ", context))?
        };
        let bitwise_shift_39 = BitwiseShiftBuilder::default()
            .summ_0(Box::new(summ_0))
            .bitwise_shift_list_1(bitwise_shift_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bitwise_shift(bitwise_shift_39.clone())?;
        self.push(ASTType::BitwiseShift(bitwise_shift_39), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// bitwise_shiftList: bitwise_shift_op summ bitwise_shiftList; // Vec<T>::Push
    ///
    fn bitwise_shift_list_40(
        &mut self,
        _bitwise_shift_op_0: &ParseTreeStackEntry,
        _summ_1: &ParseTreeStackEntry,
        _bitwise_shift_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "bitwise_shift_list_40";
        trace!("{}", self.trace_item_stack(context));
        let mut bitwise_shift_list_2 =
            if let Some(ASTType::BitwiseShiftList(bitwise_shift_list_2)) = self.pop(context) {
                bitwise_shift_list_2
            } else {
                Err(miette!("{}: Expecting ASTType::BitwiseShiftList", context))?
            };
        let summ_1 = if let Some(ASTType::Summ(summ_1)) = self.pop(context) {
            summ_1
        } else {
            Err(miette!("{}: Expecting ASTType::Summ", context))?
        };
        let bitwise_shift_op_0 =
            if let Some(ASTType::BitwiseShiftOp(bitwise_shift_op_0)) = self.pop(context) {
                bitwise_shift_op_0
            } else {
                Err(miette!("{}: Expecting ASTType::BitwiseShiftOp", context))?
            };
        let bitwise_shift_list_40 = BitwiseShiftListBuilder::default()
            .summ_1(Box::new(summ_1))
            .bitwise_shift_op_0(Box::new(bitwise_shift_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        bitwise_shift_list_2.push(bitwise_shift_list_40);
        self.push(ASTType::BitwiseShiftList(bitwise_shift_list_2), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// bitwise_shiftList: ; // Vec<T>::New
    ///
    fn bitwise_shift_list_41(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        let context = "bitwise_shift_list_41";
        trace!("{}", self.trace_item_stack(context));
        let bitwise_shift_list_41 = Vec::new();
        self.push(ASTType::BitwiseShiftList(bitwise_shift_list_41), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// add_op: plus;
    ///
    fn add_op_42(
        &mut self,
        _plus_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "add_op_42";
        trace!("{}", self.trace_item_stack(context));
        let plus_0 = if let Some(ASTType::Plus(plus_0)) = self.pop(context) {
            plus_0
        } else {
            Err(miette!("{}: Expecting ASTType::Plus", context))?
        };
        let add_op_42 = AddOp42Builder::default()
            .plus_0(Box::new(plus_0))
            .build()
            .into_diagnostic()?;
        let add_op_42 = AddOp::AddOp42(add_op_42);
        // Calling user action here
        self.user_grammar.add_op(add_op_42.clone())?;
        self.push(ASTType::AddOp(add_op_42), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// add_op: minus;
    ///
    fn add_op_43(
        &mut self,
        _minus_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "add_op_43";
        trace!("{}", self.trace_item_stack(context));
        let minus_0 = if let Some(ASTType::Minus(minus_0)) = self.pop(context) {
            minus_0
        } else {
            Err(miette!("{}: Expecting ASTType::Minus", context))?
        };
        let add_op_43 = AddOp43Builder::default()
            .minus_0(Box::new(minus_0))
            .build()
            .into_diagnostic()?;
        let add_op_43 = AddOp::AddOp43(add_op_43);
        // Calling user action here
        self.user_grammar.add_op(add_op_43.clone())?;
        self.push(ASTType::AddOp(add_op_43), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// summ: mult summList /* Vec */;
    ///
    fn summ_44(
        &mut self,
        _mult_0: &ParseTreeStackEntry,
        _summ_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "summ_44";
        trace!("{}", self.trace_item_stack(context));
        let summ_list_1 = if let Some(ASTType::SummList(mut summ_list_1)) = self.pop(context) {
            summ_list_1.reverse();
            summ_list_1
        } else {
            Err(miette!("{}: Expecting ASTType::SummList", context))?
        };
        let mult_0 = if let Some(ASTType::Mult(mult_0)) = self.pop(context) {
            mult_0
        } else {
            Err(miette!("{}: Expecting ASTType::Mult", context))?
        };
        let summ_44 = SummBuilder::default()
            .mult_0(Box::new(mult_0))
            .summ_list_1(summ_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.summ(summ_44.clone())?;
        self.push(ASTType::Summ(summ_44), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// summList: add_op mult summList; // Vec<T>::Push
    ///
    fn summ_list_45(
        &mut self,
        _add_op_0: &ParseTreeStackEntry,
        _mult_1: &ParseTreeStackEntry,
        _summ_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "summ_list_45";
        trace!("{}", self.trace_item_stack(context));
        let mut summ_list_2 = if let Some(ASTType::SummList(summ_list_2)) = self.pop(context) {
            summ_list_2
        } else {
            Err(miette!("{}: Expecting ASTType::SummList", context))?
        };
        let mult_1 = if let Some(ASTType::Mult(mult_1)) = self.pop(context) {
            mult_1
        } else {
            Err(miette!("{}: Expecting ASTType::Mult", context))?
        };
        let add_op_0 = if let Some(ASTType::AddOp(add_op_0)) = self.pop(context) {
            add_op_0
        } else {
            Err(miette!("{}: Expecting ASTType::AddOp", context))?
        };
        let summ_list_45 = SummListBuilder::default()
            .mult_1(Box::new(mult_1))
            .add_op_0(Box::new(add_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        summ_list_2.push(summ_list_45);
        self.push(ASTType::SummList(summ_list_2), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// summList: ; // Vec<T>::New
    ///
    fn summ_list_46(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        let context = "summ_list_46";
        trace!("{}", self.trace_item_stack(context));
        let summ_list_46 = Vec::new();
        self.push(ASTType::SummList(summ_list_46), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// mult: power multList /* Vec */;
    ///
    fn mult_47(
        &mut self,
        _power_0: &ParseTreeStackEntry,
        _mult_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "mult_47";
        trace!("{}", self.trace_item_stack(context));
        let mult_list_1 = if let Some(ASTType::MultList(mut mult_list_1)) = self.pop(context) {
            mult_list_1.reverse();
            mult_list_1
        } else {
            Err(miette!("{}: Expecting ASTType::MultList", context))?
        };
        let power_0 = if let Some(ASTType::Power(power_0)) = self.pop(context) {
            power_0
        } else {
            Err(miette!("{}: Expecting ASTType::Power", context))?
        };
        let mult_47 = MultBuilder::default()
            .power_0(Box::new(power_0))
            .mult_list_1(mult_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.mult(mult_47.clone())?;
        self.push(ASTType::Mult(mult_47), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// multList: mult_op power multList; // Vec<T>::Push
    ///
    fn mult_list_48(
        &mut self,
        _mult_op_0: &ParseTreeStackEntry,
        _power_1: &ParseTreeStackEntry,
        _mult_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "mult_list_48";
        trace!("{}", self.trace_item_stack(context));
        let mut mult_list_2 = if let Some(ASTType::MultList(mult_list_2)) = self.pop(context) {
            mult_list_2
        } else {
            Err(miette!("{}: Expecting ASTType::MultList", context))?
        };
        let power_1 = if let Some(ASTType::Power(power_1)) = self.pop(context) {
            power_1
        } else {
            Err(miette!("{}: Expecting ASTType::Power", context))?
        };
        let mult_op_0 = if let Some(ASTType::MultOp(mult_op_0)) = self.pop(context) {
            mult_op_0
        } else {
            Err(miette!("{}: Expecting ASTType::MultOp", context))?
        };
        let mult_list_48 = MultListBuilder::default()
            .power_1(Box::new(power_1))
            .mult_op_0(Box::new(mult_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        mult_list_2.push(mult_list_48);
        self.push(ASTType::MultList(mult_list_2), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// multList: ; // Vec<T>::New
    ///
    fn mult_list_49(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        let context = "mult_list_49";
        trace!("{}", self.trace_item_stack(context));
        let mult_list_49 = Vec::new();
        self.push(ASTType::MultList(mult_list_49), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// power: factor powerList /* Vec */;
    ///
    fn power_50(
        &mut self,
        _factor_0: &ParseTreeStackEntry,
        _power_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "power_50";
        trace!("{}", self.trace_item_stack(context));
        let power_list_1 = if let Some(ASTType::PowerList(mut power_list_1)) = self.pop(context) {
            power_list_1.reverse();
            power_list_1
        } else {
            Err(miette!("{}: Expecting ASTType::PowerList", context))?
        };
        let factor_0 = if let Some(ASTType::Factor(factor_0)) = self.pop(context) {
            factor_0
        } else {
            Err(miette!("{}: Expecting ASTType::Factor", context))?
        };
        let power_50 = PowerBuilder::default()
            .factor_0(Box::new(factor_0))
            .power_list_1(power_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.power(power_50.clone())?;
        self.push(ASTType::Power(power_50), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// powerList: pow_op factor powerList; // Vec<T>::Push
    ///
    fn power_list_51(
        &mut self,
        _pow_op_0: &ParseTreeStackEntry,
        _factor_1: &ParseTreeStackEntry,
        _power_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "power_list_51";
        trace!("{}", self.trace_item_stack(context));
        let mut power_list_2 = if let Some(ASTType::PowerList(power_list_2)) = self.pop(context) {
            power_list_2
        } else {
            Err(miette!("{}: Expecting ASTType::PowerList", context))?
        };
        let factor_1 = if let Some(ASTType::Factor(factor_1)) = self.pop(context) {
            factor_1
        } else {
            Err(miette!("{}: Expecting ASTType::Factor", context))?
        };
        let pow_op_0 = if let Some(ASTType::PowOp(pow_op_0)) = self.pop(context) {
            pow_op_0
        } else {
            Err(miette!("{}: Expecting ASTType::PowOp", context))?
        };
        let power_list_51 = PowerListBuilder::default()
            .factor_1(Box::new(factor_1))
            .pow_op_0(Box::new(pow_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        power_list_2.push(power_list_51);
        self.push(ASTType::PowerList(power_list_2), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// powerList: ; // Vec<T>::New
    ///
    fn power_list_52(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        let context = "power_list_52";
        trace!("{}", self.trace_item_stack(context));
        let power_list_52 = Vec::new();
        self.push(ASTType::PowerList(power_list_52), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// negate: minus;
    ///
    fn negate_53(
        &mut self,
        _minus_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "negate_53";
        trace!("{}", self.trace_item_stack(context));
        let minus_0 = if let Some(ASTType::Minus(minus_0)) = self.pop(context) {
            minus_0
        } else {
            Err(miette!("{}: Expecting ASTType::Minus", context))?
        };
        let negate_53 = NegateBuilder::default()
            .minus_0(Box::new(minus_0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.negate(negate_53.clone())?;
        self.push(ASTType::Negate(negate_53), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// factor: number;
    ///
    fn factor_54(
        &mut self,
        _number_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "factor_54";
        trace!("{}", self.trace_item_stack(context));
        let number_0 = if let Some(ASTType::Number(number_0)) = self.pop(context) {
            number_0
        } else {
            Err(miette!("{}: Expecting ASTType::Number", context))?
        };
        let factor_54 = Factor54Builder::default()
            .number_0(Box::new(number_0))
            .build()
            .into_diagnostic()?;
        let factor_54 = Factor::Factor54(factor_54);
        // Calling user action here
        self.user_grammar.factor(factor_54.clone())?;
        self.push(ASTType::Factor(factor_54), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// factor: idref;
    ///
    fn factor_55(
        &mut self,
        _idref_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "factor_55";
        trace!("{}", self.trace_item_stack(context));
        let idref_0 = if let Some(ASTType::Idref(idref_0)) = self.pop(context) {
            idref_0
        } else {
            Err(miette!("{}: Expecting ASTType::Idref", context))?
        };
        let factor_55 = Factor55Builder::default()
            .idref_0(Box::new(idref_0))
            .build()
            .into_diagnostic()?;
        let factor_55 = Factor::Factor55(factor_55);
        // Calling user action here
        self.user_grammar.factor(factor_55.clone())?;
        self.push(ASTType::Factor(factor_55), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// factor: negate factor;
    ///
    fn factor_56(
        &mut self,
        _negate_0: &ParseTreeStackEntry,
        _factor_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "factor_56";
        trace!("{}", self.trace_item_stack(context));
        let factor_1 = if let Some(ASTType::Factor(factor_1)) = self.pop(context) {
            factor_1
        } else {
            Err(miette!("{}: Expecting ASTType::Factor", context))?
        };
        let negate_0 = if let Some(ASTType::Negate(negate_0)) = self.pop(context) {
            negate_0
        } else {
            Err(miette!("{}: Expecting ASTType::Negate", context))?
        };
        let factor_56 = Factor56Builder::default()
            .negate_0(Box::new(negate_0))
            .factor_1(Box::new(factor_1))
            .build()
            .into_diagnostic()?;
        let factor_56 = Factor::Factor56(factor_56);
        // Calling user action here
        self.user_grammar.factor(factor_56.clone())?;
        self.push(ASTType::Factor(factor_56), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// factor: "\(" logical_or "\)";
    ///
    fn factor_57(
        &mut self,
        l_paren_0: &ParseTreeStackEntry,
        _logical_or_1: &ParseTreeStackEntry,
        r_paren_2: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "factor_57";
        trace!("{}", self.trace_item_stack(context));
        let l_paren_0 = l_paren_0.token(parse_tree)?.to_owned();
        let r_paren_2 = r_paren_2.token(parse_tree)?.to_owned();
        let logical_or_1 = if let Some(ASTType::LogicalOr(logical_or_1)) = self.pop(context) {
            logical_or_1
        } else {
            Err(miette!("{}: Expecting ASTType::LogicalOr", context))?
        };
        let factor_57 = Factor57Builder::default()
            .l_paren_0(l_paren_0)
            .logical_or_1(Box::new(logical_or_1))
            .r_paren_2(r_paren_2)
            .build()
            .into_diagnostic()?;
        let factor_57 = Factor::Factor57(factor_57);
        // Calling user action here
        self.user_grammar.factor(factor_57.clone())?;
        self.push(ASTType::Factor(factor_57), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// number: "0|[1-9][0-9]*";
    ///
    fn number_58(
        &mut self,
        number_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "number_58";
        trace!("{}", self.trace_item_stack(context));
        let number_0 = number_0.token(parse_tree)?.to_owned();
        let number_58 = NumberBuilder::default()
            .number_0(number_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.number(number_58.clone())?;
        self.push(ASTType::Number(number_58), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// idref: id;
    ///
    fn idref_59(
        &mut self,
        _id_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "idref_59";
        trace!("{}", self.trace_item_stack(context));
        let id_0 = if let Some(ASTType::Id(id_0)) = self.pop(context) {
            id_0
        } else {
            Err(miette!("{}: Expecting ASTType::Id", context))?
        };
        let idref_59 = IdrefBuilder::default()
            .id_0(Box::new(id_0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.idref(idref_59.clone())?;
        self.push(ASTType::Idref(idref_59), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// id: "[a-zA-Z_][a-zA-Z0-9_]*";
    ///
    fn id_60(
        &mut self,
        id_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "id_60";
        trace!("{}", self.trace_item_stack(context));
        let id_0 = id_0.token(parse_tree)?.to_owned();
        let id_60 = IdBuilder::default().id_0(id_0).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.id(id_60.clone())?;
        self.push(ASTType::Id(id_60), context);
        Ok(())
    }
}

impl UserActionsTrait for CalcGrammarAuto<'_> {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// Is is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, file_name: &Path) {
        self.file_name = file_name.to_owned();
        self.user_grammar.init(file_name);
    }

    ///
    /// This function is implemented automatically for the user's item CalcGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry],
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        match prod_num {
            0 => self.calc_0(&children[0], parse_tree),
            1 => self.calc_list_1(&children[0], &children[1], &children[2], parse_tree),
            2 => self.calc_list_2(parse_tree),
            3 => self.equality_op_3(&children[0], parse_tree),
            4 => self.assign_op_4(&children[0], parse_tree),
            5 => self.logical_or_op_5(&children[0], parse_tree),
            6 => self.logical_and_op_6(&children[0], parse_tree),
            7 => self.bitwise_or_op_7(&children[0], parse_tree),
            8 => self.bitwise_and_op_8(&children[0], parse_tree),
            9 => self.bitwise_shift_op_9(&children[0], parse_tree),
            10 => self.relational_op_10(&children[0], parse_tree),
            11 => self.plus_11(&children[0], parse_tree),
            12 => self.minus_12(&children[0], parse_tree),
            13 => self.pow_op_13(&children[0], parse_tree),
            14 => self.mult_op_14(&children[0], parse_tree),
            15 => self.instruction_15(&children[0], parse_tree),
            16 => self.instruction_16(&children[0], parse_tree),
            17 => self.assign_item_17(&children[0], &children[1], parse_tree),
            18 => self.assignment_18(&children[0], &children[1], &children[2], parse_tree),
            19 => self.assignment_list_19(&children[0], &children[1], parse_tree),
            20 => self.assignment_list_20(parse_tree),
            21 => self.logical_or_21(&children[0], &children[1], parse_tree),
            22 => self.logical_or_list_22(&children[0], &children[1], &children[2], parse_tree),
            23 => self.logical_or_list_23(parse_tree),
            24 => self.logical_and_24(&children[0], &children[1], parse_tree),
            25 => self.logical_and_list_25(&children[0], &children[1], &children[2], parse_tree),
            26 => self.logical_and_list_26(parse_tree),
            27 => self.bitwise_or_27(&children[0], &children[1], parse_tree),
            28 => self.bitwise_or_list_28(&children[0], &children[1], &children[2], parse_tree),
            29 => self.bitwise_or_list_29(parse_tree),
            30 => self.bitwise_and_30(&children[0], &children[1], parse_tree),
            31 => self.bitwise_and_list_31(&children[0], &children[1], &children[2], parse_tree),
            32 => self.bitwise_and_list_32(parse_tree),
            33 => self.equality_33(&children[0], &children[1], parse_tree),
            34 => self.equality_list_34(&children[0], &children[1], &children[2], parse_tree),
            35 => self.equality_list_35(parse_tree),
            36 => self.relational_36(&children[0], &children[1], parse_tree),
            37 => self.relational_list_37(&children[0], &children[1], &children[2], parse_tree),
            38 => self.relational_list_38(parse_tree),
            39 => self.bitwise_shift_39(&children[0], &children[1], parse_tree),
            40 => self.bitwise_shift_list_40(&children[0], &children[1], &children[2], parse_tree),
            41 => self.bitwise_shift_list_41(parse_tree),
            42 => self.add_op_42(&children[0], parse_tree),
            43 => self.add_op_43(&children[0], parse_tree),
            44 => self.summ_44(&children[0], &children[1], parse_tree),
            45 => self.summ_list_45(&children[0], &children[1], &children[2], parse_tree),
            46 => self.summ_list_46(parse_tree),
            47 => self.mult_47(&children[0], &children[1], parse_tree),
            48 => self.mult_list_48(&children[0], &children[1], &children[2], parse_tree),
            49 => self.mult_list_49(parse_tree),
            50 => self.power_50(&children[0], &children[1], parse_tree),
            51 => self.power_list_51(&children[0], &children[1], &children[2], parse_tree),
            52 => self.power_list_52(parse_tree),
            53 => self.negate_53(&children[0], parse_tree),
            54 => self.factor_54(&children[0], parse_tree),
            55 => self.factor_55(&children[0], parse_tree),
            56 => self.factor_56(&children[0], &children[1], parse_tree),
            57 => self.factor_57(&children[0], &children[1], &children[2], parse_tree),
            58 => self.number_58(&children[0], parse_tree),
            59 => self.idref_59(&children[0], parse_tree),
            60 => self.id_60(&children[0], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
