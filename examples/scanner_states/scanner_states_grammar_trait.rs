// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use id_tree::Tree;

use crate::scanner_states_grammar::ScannerStatesGrammar;
use miette::{miette, Result};
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};
use std::path::Path;

///
/// The `ScannerStatesGrammarTrait` trait is automatically generated for the
/// given grammar.
/// All functions have default implementations.
///
pub trait ScannerStatesGrammarTrait {
    ///
    /// Implement this method if you need the provided information
    ///
    fn init(&mut self, _file_name: &Path) {}

    /// Semantic action for production 0:
    ///
    /// Start: StartList /* Vec */;
    ///
    fn start(
        &mut self,
        _start_list: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// StartList: Content StartList; // Vec<T>::Push
    ///
    fn start_list_0(
        &mut self,
        _content: &ParseTreeStackEntry,
        _start_list: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// StartList: ; // Vec<T>::New
    ///
    fn start_list_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// Content: Identifier;
    ///
    fn content_0(
        &mut self,
        _identifier: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// Content: StringDelimiter %push(String) StringContent StringDelimiter %pop();
    ///
    fn content_1(
        &mut self,
        _string_delimiter: &ParseTreeStackEntry,
        _string_content: &ParseTreeStackEntry,
        _string_delimiter0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// StringContent: StringElement StringContent;
    ///
    fn string_content_0(
        &mut self,
        _string_element: &ParseTreeStackEntry,
        _string_content: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// StringContent: ;
    ///
    fn string_content_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// StringElement: Escaped;
    ///
    fn string_element_0(
        &mut self,
        _escaped: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// StringElement: EscapedLineEnd;
    ///
    fn string_element_1(
        &mut self,
        _escaped_line_end: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// StringElement: NoneQuote;
    ///
    fn string_element_2(
        &mut self,
        _none_quote: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// Identifier: "[a-zA-Z_]\w*";
    ///
    fn identifier(
        &mut self,
        _identifier: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// Escaped: <String>"\u{5c}[\u{22}\u{5c}bfnt]";
    ///
    fn escaped(
        &mut self,
        _escaped: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// EscapedLineEnd: <String>"\u{5c}[\s^\n\r]*\r?\n";
    ///
    fn escaped_line_end(
        &mut self,
        _escaped_line_end: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// NoneQuote: <String>"[^\u{22}\u{5c}]+";
    ///
    fn none_quote(
        &mut self,
        _none_quote: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// StringDelimiter: <INITIAL, String>"\u{22}";
    ///
    fn string_delimiter(
        &mut self,
        _string_delimiter: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }
}

impl UserActionsTrait<'_> for ScannerStatesGrammar {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// It is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, _file_name: &Path) {}

    ///
    /// This function is implemented automatically for the user's item ScannerStatesGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry],
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        match prod_num {
            0 => self.start(&children[0], parse_tree),
            1 => self.start_list_0(&children[0], &children[1], parse_tree),
            2 => self.start_list_1(parse_tree),
            3 => self.content_0(&children[0], parse_tree),
            4 => self.content_1(&children[0], &children[1], &children[2], parse_tree),
            5 => self.string_content_0(&children[0], &children[1], parse_tree),
            6 => self.string_content_1(parse_tree),
            7 => self.string_element_0(&children[0], parse_tree),
            8 => self.string_element_1(&children[0], parse_tree),
            9 => self.string_element_2(&children[0], parse_tree),
            10 => self.identifier(&children[0], parse_tree),
            11 => self.escaped(&children[0], parse_tree),
            12 => self.escaped_line_end(&children[0], parse_tree),
            13 => self.none_quote(&children[0], parse_tree),
            14 => self.string_delimiter(&children[0], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
