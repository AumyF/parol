// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

#[allow(unused_imports)]
use crate::list_grammar::ListGrammar;
use id_tree::Tree;
use log::trace;
use miette::{miette, IntoDiagnostic, Result};
use parol_runtime::lexer::OwnedToken;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};
use std::path::{Path, PathBuf};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait ListGrammarTrait {
    fn init(&mut self, _file_name: &Path) {}

    /// Semantic action for user production 0:
    ///
    /// List: [Num {<0>"," Num}];
    ///
    fn list(&mut self, _arg: &List) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 1:
    ///
    /// Num: <0>"0|[1-9][0-9]*";
    ///
    fn num(&mut self, _arg: &Num) -> Result<()> {
        Ok(())
    }
}

//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 0
///
/// List: Num ListList /* Vec */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct List0 {
    pub num_0: Box<Num>,
    pub list_list_1: Vec<ListList>,
}

///
/// Type derived for production 3
///
/// List: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct List3 {}

//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum List {
    List0(List0),
    List3(List3),
}

///
/// Type derived for non-terminal ListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ListList {
    pub comma_0: OwnedToken, /* , */
    pub num_1: Box<Num>,
}

///
/// Type derived for non-terminal Num
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Num {
    pub num_0: OwnedToken, /* 0|[1-9][0-9]* */
}

//
// AST type of the transformed grammar
//

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType {
    List(List),
    ListList(Vec<ListList>),
    Num(Num),
}

/// Auto-implemented adapter grammar
#[allow(dead_code)]
pub struct ListGrammarAuto<'a> {
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'a mut dyn ListGrammarTrait,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType>,
    // Path of the input file. Used for diagnostics.
    file_name: PathBuf,
}

///
/// The `ListGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'a> ListGrammarAuto<'a> {
    pub fn new(user_grammar: &'a mut dyn ListGrammarTrait) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            file_name: PathBuf::default(),
        }
    }

    fn push(&mut self, item: ASTType, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    fn pop(&mut self, context: &str) -> Option<ASTType> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// List: Num ListList /* Vec */;
    ///
    fn list_0(
        &mut self,
        _num_0: &ParseTreeStackEntry,
        _list_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "list_0";
        trace!("{}", self.trace_item_stack(context));
        let list_list_1 = if let Some(ASTType::ListList(mut list_list_1)) = self.pop(context) {
            list_list_1.reverse();
            list_list_1
        } else {
            return Err(miette!("{}: Expecting ASTType::ListList", context));
        };
        let num_0 = if let Some(ASTType::Num(num_0)) = self.pop(context) {
            num_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Num", context));
        };
        let list_0 = List0Builder::default()
            .num_0(Box::new(num_0))
            .list_list_1(list_list_1)
            .build()
            .into_diagnostic()?;
        let list_0 = List::List0(list_0);
        // Calling user action here
        self.user_grammar.list(&list_0)?;
        self.push(ASTType::List(list_0), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// ListList: "," Num ListList; // Vec<T>::Push
    ///
    fn list_list_1(
        &mut self,
        comma_0: &ParseTreeStackEntry,
        _num_1: &ParseTreeStackEntry,
        _list_list_2: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "list_list_1";
        trace!("{}", self.trace_item_stack(context));
        let comma_0 = comma_0.token(parse_tree)?.to_owned();
        let mut list_list_2 = if let Some(ASTType::ListList(list_list_2)) = self.pop(context) {
            list_list_2
        } else {
            return Err(miette!("{}: Expecting ASTType::ListList", context));
        };
        let num_1 = if let Some(ASTType::Num(num_1)) = self.pop(context) {
            num_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Num", context));
        };
        let list_list_1 = ListListBuilder::default()
            .num_1(Box::new(num_1))
            .comma_0(comma_0)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        list_list_2.push(list_list_1);
        self.push(ASTType::ListList(list_list_2), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// ListList: ; // Vec<T>::New
    ///
    fn list_list_2(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        let context = "list_list_2";
        trace!("{}", self.trace_item_stack(context));
        let list_list_2 = Vec::new();
        self.push(ASTType::ListList(list_list_2), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// List: ;
    ///
    fn list_3(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        let context = "list_3";
        trace!("{}", self.trace_item_stack(context));
        let list_3 = List3Builder::default().build().into_diagnostic()?;
        let list_3 = List::List3(list_3);
        // Calling user action here
        self.user_grammar.list(&list_3)?;
        self.push(ASTType::List(list_3), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// Num: "0|[1-9][0-9]*";
    ///
    fn num_4(
        &mut self,
        num_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "num_4";
        trace!("{}", self.trace_item_stack(context));
        let num_0 = num_0.token(parse_tree)?.to_owned();
        let num_4 = NumBuilder::default()
            .num_0(num_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.num(&num_4)?;
        self.push(ASTType::Num(num_4), context);
        Ok(())
    }
}

impl UserActionsTrait for ListGrammarAuto<'_> {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// Is is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, file_name: &Path) {
        self.file_name = file_name.to_owned();
        self.user_grammar.init(file_name);
    }

    ///
    /// This function is implemented automatically for the user's item ListGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry],
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        match prod_num {
            0 => self.list_0(&children[0], &children[1], parse_tree),
            1 => self.list_list_1(&children[0], &children[1], &children[2], parse_tree),
            2 => self.list_list_2(parse_tree),
            3 => self.list_3(parse_tree),
            4 => self.num_4(&children[0], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
