use crate::list_grammar_trait::{List, ListGrammarTrait, ListOpt, ListOptList, TrailingComma};
use miette::Result;
use parol_runtime::lexer::Token;
use std::{
    fmt::{Debug, Display, Error, Formatter},
    marker::PhantomData,
    str::FromStr,
};

///
/// Data structure that implements the semantic actions for our list grammar
///
#[derive(Debug, Default)]
pub struct ListGrammar<'t> {
    pub list: Option<List>,
    phantom: PhantomData<&'t str>, // Just to hold the lifetime generated by parol
}

impl ListGrammar<'_> {
    pub fn new() -> Self {
        ListGrammar::default()
    }
}

impl Display for List {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::result::Result<(), Error> {
        if let Some(list) = &self.list_opt {
            write!(f, "[{}]", list)
        } else {
            write!(f, "[]")
        }
    }
}

impl Display for ListOpt {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::result::Result<(), Error> {
        write!(
            f,
            "{}{}",
            self.num.num.0,
            self.list_opt_list
                .iter()
                .map(|e| format!("{}", e))
                .collect::<Vec<std::string::String>>()
                .join("")
        )
    }
}

impl Display for ListOptList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::result::Result<(), Error> {
        write!(f, ", {}", self.num.num.0)
    }
}

impl Display for TrailingComma<'_> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::result::Result<(), Error> {
        if let Some(comma) = &self.trailing_comma_opt {
            write!(f, "{}", comma.comma.symbol)
        } else {
            Ok(())
        }
    }
}

impl Display for ListGrammar<'_> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::result::Result<(), Error> {
        match &self.list {
            Some(list) => writeln!(f, "{}", list),
            None => write!(f, "No parse result"),
        }
    }
}

impl<'t> ListGrammarTrait<'t> for ListGrammar<'_> {
    /// Semantic action for user production 0:
    ///
    /// List: [Num {<0>"," Num}];
    ///
    fn list(&mut self, arg: &List) -> Result<()> {
        self.list = Some(arg.clone());
        Ok(())
    }
}

#[derive(Clone, Debug, Default)]
pub struct Number(u32);

impl<'t> TryFrom<&Token<'t>> for Number {
    type Error = <u32 as FromStr>::Err;

    fn try_from(number: &Token<'t>) -> Result<Self, Self::Error> {
        Ok(Self(number.symbol.parse::<u32>()?))
    }
}
