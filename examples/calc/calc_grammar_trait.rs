// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use id_tree::Tree;

use miette::{miette, Result};
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

use crate::calc_grammar::CalcGrammar;
use std::path::Path;

///
/// The `CalcGrammarTrait` trait is automatically generated for the
/// given grammar.
/// All functions have default implementations.
///
pub trait CalcGrammarTrait {
    ///
    /// Implement this method if you need the provided information
    ///
    fn init(&mut self, _file_name: &Path) {}

    /// Semantic action for production 0:
    ///
    /// calc: calc_lst1;
    ///
    fn calc_0(
        &mut self,
        _calc_lst1_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// calc_lst1: calc_lst1_itm1 calc_lst1;
    ///
    fn calc_lst1_0(
        &mut self,
        _calc_lst1_itm1_0: &ParseTreeStackEntry,
        _calc_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// calc_lst1_itm1: instruction ";";
    ///
    fn calc_lst1_itm1_0(
        &mut self,
        _instruction_0: &ParseTreeStackEntry,
        _semicolon_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// calc_lst1: ;
    ///
    fn calc_lst1_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// instruction: assignment;
    ///
    fn instruction_0(
        &mut self,
        _assignment_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// instruction: logical_or;
    ///
    fn instruction_1(
        &mut self,
        _logical_or_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// equality_op: "==|!=";
    ///
    fn equality_op_0(
        &mut self,
        _equality_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// assign_op: "(\+|-|\*|/|%|<<|>>|&|\^|\|)?=";
    ///
    fn assign_op_0(
        &mut self,
        _assign_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// assign_item: id assign_op;
    ///
    fn assign_item_0(
        &mut self,
        _id_0: &ParseTreeStackEntry,
        _assign_op_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// assignment: assign_item assignment_lst1 logical_or;
    ///
    fn assignment_0(
        &mut self,
        _assign_item_0: &ParseTreeStackEntry,
        _assignment_lst1_1: &ParseTreeStackEntry,
        _logical_or_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// assignment_lst1: assignment_lst1_itm1 assignment_lst1;
    ///
    fn assignment_lst1_0(
        &mut self,
        _assignment_lst1_itm1_0: &ParseTreeStackEntry,
        _assignment_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// assignment_lst1_itm1: assign_item;
    ///
    fn assignment_lst1_itm1_0(
        &mut self,
        _assign_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// assignment_lst1: ;
    ///
    fn assignment_lst1_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// logical_or: logical_and logical_or_lst1;
    ///
    fn logical_or_0(
        &mut self,
        _logical_and_0: &ParseTreeStackEntry,
        _logical_or_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// logical_or_lst1: logical_or_lst1_itm1 logical_or_lst1;
    ///
    fn logical_or_lst1_0(
        &mut self,
        _logical_or_lst1_itm1_0: &ParseTreeStackEntry,
        _logical_or_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// logical_or_lst1_itm1: logical_or_item;
    ///
    fn logical_or_lst1_itm1_0(
        &mut self,
        _logical_or_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// logical_or_lst1: ;
    ///
    fn logical_or_lst1_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// logical_or_op: "\|\|";
    ///
    fn logical_or_op_0(
        &mut self,
        _logical_or_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// logical_or_item: logical_or_op logical_and;
    ///
    fn logical_or_item_0(
        &mut self,
        _logical_or_op_0: &ParseTreeStackEntry,
        _logical_and_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// logical_and: bitwise_or logical_and_lst1;
    ///
    fn logical_and_0(
        &mut self,
        _bitwise_or_0: &ParseTreeStackEntry,
        _logical_and_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// logical_and_lst1: logical_and_lst1_itm1 logical_and_lst1;
    ///
    fn logical_and_lst1_0(
        &mut self,
        _logical_and_lst1_itm1_0: &ParseTreeStackEntry,
        _logical_and_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// logical_and_lst1_itm1: logical_and_item;
    ///
    fn logical_and_lst1_itm1_0(
        &mut self,
        _logical_and_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// logical_and_lst1: ;
    ///
    fn logical_and_lst1_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// logical_and_op: "&&";
    ///
    fn logical_and_op_0(
        &mut self,
        _logical_and_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// logical_and_item: logical_and_op bitwise_or;
    ///
    fn logical_and_item_0(
        &mut self,
        _logical_and_op_0: &ParseTreeStackEntry,
        _bitwise_or_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// bitwise_or: bitwise_and bitwise_or_lst1;
    ///
    fn bitwise_or_0(
        &mut self,
        _bitwise_and_0: &ParseTreeStackEntry,
        _bitwise_or_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// bitwise_or_lst1: bitwise_or_lst1_itm1 bitwise_or_lst1;
    ///
    fn bitwise_or_lst1_0(
        &mut self,
        _bitwise_or_lst1_itm1_0: &ParseTreeStackEntry,
        _bitwise_or_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// bitwise_or_lst1_itm1: bitwise_or_item;
    ///
    fn bitwise_or_lst1_itm1_0(
        &mut self,
        _bitwise_or_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// bitwise_or_lst1: ;
    ///
    fn bitwise_or_lst1_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// bitwise_or_op: "\|";
    ///
    fn bitwise_or_op_0(
        &mut self,
        _bitwise_or_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// bitwise_or_item: bitwise_or_op bitwise_and;
    ///
    fn bitwise_or_item_0(
        &mut self,
        _bitwise_or_op_0: &ParseTreeStackEntry,
        _bitwise_and_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// bitwise_and: equality bitwise_and_lst1;
    ///
    fn bitwise_and_0(
        &mut self,
        _equality_0: &ParseTreeStackEntry,
        _bitwise_and_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// bitwise_and_lst1: bitwise_and_lst1_itm1 bitwise_and_lst1;
    ///
    fn bitwise_and_lst1_0(
        &mut self,
        _bitwise_and_lst1_itm1_0: &ParseTreeStackEntry,
        _bitwise_and_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// bitwise_and_lst1_itm1: bitwise_and_item;
    ///
    fn bitwise_and_lst1_itm1_0(
        &mut self,
        _bitwise_and_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// bitwise_and_lst1: ;
    ///
    fn bitwise_and_lst1_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// bitwise_and_op: "&";
    ///
    fn bitwise_and_op_0(
        &mut self,
        _bitwise_and_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// bitwise_and_item: bitwise_and_op equality;
    ///
    fn bitwise_and_item_0(
        &mut self,
        _bitwise_and_op_0: &ParseTreeStackEntry,
        _equality_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// equality: relational equality_lst1;
    ///
    fn equality_0(
        &mut self,
        _relational_0: &ParseTreeStackEntry,
        _equality_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// equality_lst1: equality_lst1_itm1 equality_lst1;
    ///
    fn equality_lst1_0(
        &mut self,
        _equality_lst1_itm1_0: &ParseTreeStackEntry,
        _equality_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// equality_lst1_itm1: equality_item;
    ///
    fn equality_lst1_itm1_0(
        &mut self,
        _equality_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// equality_lst1: ;
    ///
    fn equality_lst1_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// equality_item: equality_op relational;
    ///
    fn equality_item_0(
        &mut self,
        _equality_op_0: &ParseTreeStackEntry,
        _relational_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// bitwise_shift_op: "<<|>>";
    ///
    fn bitwise_shift_op_0(
        &mut self,
        _bitwise_shift_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// relational: bitwise_shift relational_lst1;
    ///
    fn relational_0(
        &mut self,
        _bitwise_shift_0: &ParseTreeStackEntry,
        _relational_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// relational_lst1: relational_lst1_itm1 relational_lst1;
    ///
    fn relational_lst1_0(
        &mut self,
        _relational_lst1_itm1_0: &ParseTreeStackEntry,
        _relational_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// relational_lst1_itm1: relational_item;
    ///
    fn relational_lst1_itm1_0(
        &mut self,
        _relational_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// relational_lst1: ;
    ///
    fn relational_lst1_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// relational_op: "<=|<|>=|>";
    ///
    fn relational_op_0(
        &mut self,
        _relational_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// relational_item: relational_op bitwise_shift;
    ///
    fn relational_item_0(
        &mut self,
        _relational_op_0: &ParseTreeStackEntry,
        _bitwise_shift_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// bitwise_shift: summ bitwise_shift_lst1;
    ///
    fn bitwise_shift_0(
        &mut self,
        _summ_0: &ParseTreeStackEntry,
        _bitwise_shift_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// bitwise_shift_lst1: bitwise_shift_lst1_itm1 bitwise_shift_lst1;
    ///
    fn bitwise_shift_lst1_0(
        &mut self,
        _bitwise_shift_lst1_itm1_0: &ParseTreeStackEntry,
        _bitwise_shift_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// bitwise_shift_lst1_itm1: bitwise_shift_item;
    ///
    fn bitwise_shift_lst1_itm1_0(
        &mut self,
        _bitwise_shift_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// bitwise_shift_lst1: ;
    ///
    fn bitwise_shift_lst1_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// bitwise_shift_item: bitwise_shift_op summ;
    ///
    fn bitwise_shift_item_0(
        &mut self,
        _bitwise_shift_op_0: &ParseTreeStackEntry,
        _summ_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// summ: mult summ_lst1;
    ///
    fn summ_0(
        &mut self,
        _mult_0: &ParseTreeStackEntry,
        _summ_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// summ_lst1: summ_lst1_itm1 summ_lst1;
    ///
    fn summ_lst1_0(
        &mut self,
        _summ_lst1_itm1_0: &ParseTreeStackEntry,
        _summ_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// summ_lst1_itm1: summ_item;
    ///
    fn summ_lst1_itm1_0(
        &mut self,
        _summ_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// summ_lst1: ;
    ///
    fn summ_lst1_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// plus: "\+";
    ///
    fn plus_0(
        &mut self,
        _plus_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// minus: "-";
    ///
    fn minus_0(
        &mut self,
        _minus_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// add_op: plus;
    ///
    fn add_op_0(
        &mut self,
        _plus_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// add_op: minus;
    ///
    fn add_op_1(
        &mut self,
        _minus_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// summ_item: add_op mult;
    ///
    fn summ_item_0(
        &mut self,
        _add_op_0: &ParseTreeStackEntry,
        _mult_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// pow_op: "\*\*";
    ///
    fn pow_op_0(
        &mut self,
        _pow_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// mult: power mult_lst1;
    ///
    fn mult_0(
        &mut self,
        _power_0: &ParseTreeStackEntry,
        _mult_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// mult_lst1: mult_lst1_itm1 mult_lst1;
    ///
    fn mult_lst1_0(
        &mut self,
        _mult_lst1_itm1_0: &ParseTreeStackEntry,
        _mult_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// mult_lst1_itm1: mult_item;
    ///
    fn mult_lst1_itm1_0(
        &mut self,
        _mult_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// mult_lst1: ;
    ///
    fn mult_lst1_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// mult_op: "\*|/|%";
    ///
    fn mult_op_0(
        &mut self,
        _mult_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// mult_item: mult_op power;
    ///
    fn mult_item_0(
        &mut self,
        _mult_op_0: &ParseTreeStackEntry,
        _power_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// power: factor power_lst1;
    ///
    fn power_0(
        &mut self,
        _factor_0: &ParseTreeStackEntry,
        _power_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// power_lst1: power_lst1_itm1 power_lst1;
    ///
    fn power_lst1_0(
        &mut self,
        _power_lst1_itm1_0: &ParseTreeStackEntry,
        _power_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// power_lst1_itm1: pow_op factor;
    ///
    fn power_lst1_itm1_0(
        &mut self,
        _pow_op_0: &ParseTreeStackEntry,
        _factor_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// power_lst1: ;
    ///
    fn power_lst1_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// negate: minus;
    ///
    fn negate_0(
        &mut self,
        _minus_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// factor: number;
    ///
    fn factor_0(
        &mut self,
        _number_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// factor: idref;
    ///
    fn factor_1(
        &mut self,
        _idref_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// factor: negate factor;
    ///
    fn factor_2(
        &mut self,
        _negate_0: &ParseTreeStackEntry,
        _factor_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// factor: "\(" logical_or "\)";
    ///
    fn factor_3(
        &mut self,
        _l_paren_0: &ParseTreeStackEntry,
        _logical_or_1: &ParseTreeStackEntry,
        _r_paren_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// number: "0|[1-9][0-9]*";
    ///
    fn number_0(
        &mut self,
        _number_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// idref: id;
    ///
    fn idref_0(
        &mut self,
        _id_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// id: "[a-zA-Z_][a-zA-Z0-9_]*";
    ///
    fn id_0(
        &mut self,
        _id_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }
}

impl UserActionsTrait<'_> for CalcGrammar {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// It is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, _file_name: &Path) {}

    ///
    /// This function is implemented automatically for the user's item CalcGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry],
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        match prod_num {
            0 => self.calc_0(&children[0], parse_tree),
            1 => self.calc_lst1_0(&children[0], &children[1], parse_tree),
            2 => self.calc_lst1_itm1_0(&children[0], &children[1], parse_tree),
            3 => self.calc_lst1_1(parse_tree),
            4 => self.instruction_0(&children[0], parse_tree),
            5 => self.instruction_1(&children[0], parse_tree),
            6 => self.equality_op_0(&children[0], parse_tree),
            7 => self.assign_op_0(&children[0], parse_tree),
            8 => self.assign_item_0(&children[0], &children[1], parse_tree),
            9 => self.assignment_0(&children[0], &children[1], &children[2], parse_tree),
            10 => self.assignment_lst1_0(&children[0], &children[1], parse_tree),
            11 => self.assignment_lst1_itm1_0(&children[0], parse_tree),
            12 => self.assignment_lst1_1(parse_tree),
            13 => self.logical_or_0(&children[0], &children[1], parse_tree),
            14 => self.logical_or_lst1_0(&children[0], &children[1], parse_tree),
            15 => self.logical_or_lst1_itm1_0(&children[0], parse_tree),
            16 => self.logical_or_lst1_1(parse_tree),
            17 => self.logical_or_op_0(&children[0], parse_tree),
            18 => self.logical_or_item_0(&children[0], &children[1], parse_tree),
            19 => self.logical_and_0(&children[0], &children[1], parse_tree),
            20 => self.logical_and_lst1_0(&children[0], &children[1], parse_tree),
            21 => self.logical_and_lst1_itm1_0(&children[0], parse_tree),
            22 => self.logical_and_lst1_1(parse_tree),
            23 => self.logical_and_op_0(&children[0], parse_tree),
            24 => self.logical_and_item_0(&children[0], &children[1], parse_tree),
            25 => self.bitwise_or_0(&children[0], &children[1], parse_tree),
            26 => self.bitwise_or_lst1_0(&children[0], &children[1], parse_tree),
            27 => self.bitwise_or_lst1_itm1_0(&children[0], parse_tree),
            28 => self.bitwise_or_lst1_1(parse_tree),
            29 => self.bitwise_or_op_0(&children[0], parse_tree),
            30 => self.bitwise_or_item_0(&children[0], &children[1], parse_tree),
            31 => self.bitwise_and_0(&children[0], &children[1], parse_tree),
            32 => self.bitwise_and_lst1_0(&children[0], &children[1], parse_tree),
            33 => self.bitwise_and_lst1_itm1_0(&children[0], parse_tree),
            34 => self.bitwise_and_lst1_1(parse_tree),
            35 => self.bitwise_and_op_0(&children[0], parse_tree),
            36 => self.bitwise_and_item_0(&children[0], &children[1], parse_tree),
            37 => self.equality_0(&children[0], &children[1], parse_tree),
            38 => self.equality_lst1_0(&children[0], &children[1], parse_tree),
            39 => self.equality_lst1_itm1_0(&children[0], parse_tree),
            40 => self.equality_lst1_1(parse_tree),
            41 => self.equality_item_0(&children[0], &children[1], parse_tree),
            42 => self.bitwise_shift_op_0(&children[0], parse_tree),
            43 => self.relational_0(&children[0], &children[1], parse_tree),
            44 => self.relational_lst1_0(&children[0], &children[1], parse_tree),
            45 => self.relational_lst1_itm1_0(&children[0], parse_tree),
            46 => self.relational_lst1_1(parse_tree),
            47 => self.relational_op_0(&children[0], parse_tree),
            48 => self.relational_item_0(&children[0], &children[1], parse_tree),
            49 => self.bitwise_shift_0(&children[0], &children[1], parse_tree),
            50 => self.bitwise_shift_lst1_0(&children[0], &children[1], parse_tree),
            51 => self.bitwise_shift_lst1_itm1_0(&children[0], parse_tree),
            52 => self.bitwise_shift_lst1_1(parse_tree),
            53 => self.bitwise_shift_item_0(&children[0], &children[1], parse_tree),
            54 => self.summ_0(&children[0], &children[1], parse_tree),
            55 => self.summ_lst1_0(&children[0], &children[1], parse_tree),
            56 => self.summ_lst1_itm1_0(&children[0], parse_tree),
            57 => self.summ_lst1_1(parse_tree),
            58 => self.plus_0(&children[0], parse_tree),
            59 => self.minus_0(&children[0], parse_tree),
            60 => self.add_op_0(&children[0], parse_tree),
            61 => self.add_op_1(&children[0], parse_tree),
            62 => self.summ_item_0(&children[0], &children[1], parse_tree),
            63 => self.pow_op_0(&children[0], parse_tree),
            64 => self.mult_0(&children[0], &children[1], parse_tree),
            65 => self.mult_lst1_0(&children[0], &children[1], parse_tree),
            66 => self.mult_lst1_itm1_0(&children[0], parse_tree),
            67 => self.mult_lst1_1(parse_tree),
            68 => self.mult_op_0(&children[0], parse_tree),
            69 => self.mult_item_0(&children[0], &children[1], parse_tree),
            70 => self.power_0(&children[0], &children[1], parse_tree),
            71 => self.power_lst1_0(&children[0], &children[1], parse_tree),
            72 => self.power_lst1_itm1_0(&children[0], &children[1], parse_tree),
            73 => self.power_lst1_1(parse_tree),
            74 => self.negate_0(&children[0], parse_tree),
            75 => self.factor_0(&children[0], parse_tree),
            76 => self.factor_1(&children[0], parse_tree),
            77 => self.factor_2(&children[0], &children[1], parse_tree),
            78 => self.factor_3(&children[0], &children[1], &children[2], parse_tree),
            79 => self.number_0(&children[0], parse_tree),
            80 => self.idref_0(&children[0], parse_tree),
            81 => self.id_0(&children[0], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
