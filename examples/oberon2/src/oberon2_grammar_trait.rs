// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

#![allow(unused_imports)]
use crate::oberon2_grammar::Oberon2Grammar;
use id_tree::Tree;
use log::trace;
use miette::{bail, miette, IntoDiagnostic, Result};
use parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::lexer::Token;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait Oberon2GrammarTrait<'t> {
    /// Semantic action for non-terminal 'KwBegin'
    fn kw_begin(&mut self, _arg: &KwBegin) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwCase'
    fn kw_case(&mut self, _arg: &KwCase) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwDo'
    fn kw_do(&mut self, _arg: &KwDo) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwElse'
    fn kw_else(&mut self, _arg: &KwElse) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwElsif'
    fn kw_elsif(&mut self, _arg: &KwElsif) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwEnd'
    fn kw_end(&mut self, _arg: &KwEnd) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwIf'
    fn kw_if(&mut self, _arg: &KwIf) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwOf'
    fn kw_of(&mut self, _arg: &KwOf) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwProcedure'
    fn kw_procedure(&mut self, _arg: &KwProcedure) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwThen'
    fn kw_then(&mut self, _arg: &KwThen) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwTo'
    fn kw_to(&mut self, _arg: &KwTo) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwVar'
    fn kw_var(&mut self, _arg: &KwVar) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Oberon2'
    fn oberon2(&mut self, _arg: &Oberon2<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleHead'
    fn module_head(&mut self, _arg: &ModuleHead<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleBody'
    fn module_body(&mut self, _arg: &ModuleBody<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ImportList'
    fn import_list(&mut self, _arg: &ImportList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DeclSeq'
    fn decl_seq(&mut self, _arg: &DeclSeq<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DeclBlock'
    fn decl_block(&mut self, _arg: &DeclBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstDeclBlock'
    fn const_decl_block(&mut self, _arg: &ConstDeclBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeDeclBlock'
    fn type_decl_block(&mut self, _arg: &TypeDeclBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VarDeclBlock'
    fn var_decl_block(&mut self, _arg: &VarDeclBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstDecl'
    fn const_decl(&mut self, _arg: &ConstDecl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeDecl'
    fn type_decl(&mut self, _arg: &TypeDecl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VarDecl'
    fn var_decl(&mut self, _arg: &VarDecl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProcDecl'
    fn proc_decl(&mut self, _arg: &ProcDecl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProcedureHeading'
    fn procedure_heading(&mut self, _arg: &ProcedureHeading<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProcedureBody'
    fn procedure_body(&mut self, _arg: &ProcedureBody<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StatementBlock'
    fn statement_block(&mut self, _arg: &StatementBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ForwardDecl'
    fn forward_decl(&mut self, _arg: &ForwardDecl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FormalPars'
    fn formal_pars(&mut self, _arg: &FormalPars<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FPSection'
    fn f_p_section(&mut self, _arg: &FPSection<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Receiver'
    fn receiver(&mut self, _arg: &Receiver<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ReceiverVarDecl'
    fn receiver_var_decl(&mut self, _arg: &ReceiverVarDecl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeDef'
    fn type_def(&mut self, _arg: &TypeDef<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FieldList'
    fn field_list(&mut self, _arg: &FieldList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StatementSeq'
    fn statement_seq(&mut self, _arg: &StatementSeq<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Statement'
    fn statement(&mut self, _arg: &Statement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ThenBlock'
    fn then_block(&mut self, _arg: &ThenBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Cases'
    fn cases(&mut self, _arg: &Cases<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ElsifPart'
    fn elsif_part(&mut self, _arg: &ElsifPart<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ElsePart'
    fn else_part(&mut self, _arg: &ElsePart<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OptElsePartEnd'
    fn opt_else_part_end(&mut self, _arg: &OptElsePartEnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DoBlock'
    fn do_block(&mut self, _arg: &DoBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GuardedDoBlock'
    fn guarded_do_block(&mut self, _arg: &GuardedDoBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ForInit'
    fn for_init(&mut self, _arg: &ForInit<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ForStep'
    fn for_step(&mut self, _arg: &ForStep<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Case'
    fn case(&mut self, _arg: &Case<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaseLabels'
    fn case_labels(&mut self, _arg: &CaseLabels<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Guard'
    fn guard(&mut self, _arg: &Guard<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstExpr'
    fn const_expr(&mut self, _arg: &ConstExpr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expr'
    fn expr(&mut self, _arg: &Expr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SimpleExpr'
    fn simple_expr(&mut self, _arg: &SimpleExpr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Term'
    fn term(&mut self, _arg: &Term<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Factor'
    fn factor(&mut self, _arg: &Factor<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Set'
    fn set(&mut self, _arg: &Set<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Element'
    fn element(&mut self, _arg: &Element<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Relation'
    fn relation(&mut self, _arg: &Relation<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AddOp'
    fn add_op(&mut self, _arg: &AddOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MulOp'
    fn mul_op(&mut self, _arg: &MulOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Designator'
    fn designator(&mut self, _arg: &Designator<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DesignatorSuffix'
    fn designator_suffix(&mut self, _arg: &DesignatorSuffix<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExprList'
    fn expr_list(&mut self, _arg: &ExprList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentList'
    fn ident_list(&mut self, _arg: &IdentList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QualIdent'
    fn qual_ident(&mut self, _arg: &QualIdent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentDef'
    fn ident_def(&mut self, _arg: &IdentDef<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Number'
    fn number(&mut self, _arg: &Number<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Real'
    fn real(&mut self, _arg: &Real<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Character'
    fn character(&mut self, _arg: &Character<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Integer'
    fn integer(&mut self, _arg: &Integer<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QIdent'
    fn q_ident(&mut self, _arg: &QIdent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ident'
    fn ident(&mut self, _arg: &Ident<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'String'
    fn string(&mut self, _arg: &String<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InOp'
    fn in_op(&mut self, _arg: &InOp) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 26
///
/// DeclSeqList0Group: ProcDecl ";"^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclSeqList0Group0<'t> {
    pub proc_decl: Box<ProcDecl<'t>>,
}

///
/// Type derived for production 27
///
/// DeclSeqList0Group: ForwardDecl ";"^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclSeqList0Group1<'t> {
    pub forward_decl: Box<ForwardDecl<'t>>,
}

///
/// Type derived for production 31
///
/// DeclBlock: ConstDeclBlock;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclBlock0<'t> {
    pub const_decl_block: Box<ConstDeclBlock<'t>>,
}

///
/// Type derived for production 32
///
/// DeclBlock: TypeDeclBlock;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclBlock1<'t> {
    pub type_decl_block: Box<TypeDeclBlock<'t>>,
}

///
/// Type derived for production 33
///
/// DeclBlock: VarDeclBlock;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclBlock2<'t> {
    pub var_decl_block: Box<VarDeclBlock<'t>>,
}

///
/// Type derived for production 77
///
/// TypeDef: QualIdent;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDef0<'t> {
    pub qual_ident: Box<QualIdent<'t>>,
}

///
/// Type derived for production 78
///
/// TypeDef: "ARRAY"^ /* Clipped */ TypeDefOpt /* Option */ KwOf^ /* Clipped */ TypeDef;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDef1<'t> {
    pub type_def_opt: Option<Box<TypeDefOpt<'t>>>,
    pub type_def: Box<TypeDef<'t>>,
}

///
/// Type derived for production 79
///
/// TypeDef: "RECORD"^ /* Clipped */ TypeDefOpt0 /* Option */ FieldList TypeDefList /* Vec */ KwEnd^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDef2<'t> {
    pub type_def_opt0: Option<Box<TypeDefOpt0<'t>>>,
    pub field_list: Box<FieldList<'t>>,
    pub type_def_list: Vec<TypeDefList<'t>>,
}

///
/// Type derived for production 82
///
/// TypeDef: "POINTER"^ /* Clipped */ KwTo^ /* Clipped */ TypeDef;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDef3<'t> {
    pub type_def: Box<TypeDef<'t>>,
}

///
/// Type derived for production 83
///
/// TypeDef: KwProcedure^ /* Clipped */ TypeDefOpt1 /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDef4<'t> {
    pub type_def_opt1: Option<Box<TypeDefOpt1<'t>>>,
}

///
/// Type derived for production 100
///
/// StatementOptGroup: Designator StatementOptGroupSuffix;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOptGroup0<'t> {
    pub designator: Box<Designator<'t>>,
    pub statement_opt_group_suffix: Box<StatementOptGroupSuffix<'t>>,
}

///
/// Type derived for production 101
///
/// StatementOptGroupSuffix: ":="^ /* Clipped */ Expr;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOptGroupSuffix0<'t> {
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for production 102
///
/// StatementOptGroupSuffix: StatementOpt0 /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOptGroupSuffix1<'t> {
    pub statement_opt0: Option<Box<StatementOpt0<'t>>>,
}

///
/// Type derived for production 103
///
/// StatementOptGroup: KwIf^ /* Clipped */ Expr ThenBlock StatementOptGroupList /* Vec */ OptElsePartEnd;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOptGroup1<'t> {
    pub expr: Box<Expr<'t>>,
    pub then_block: Box<ThenBlock<'t>>,
    pub statement_opt_group_list: Vec<StatementOptGroupList<'t>>,
    pub opt_else_part_end: Box<OptElsePartEnd<'t>>,
}

///
/// Type derived for production 104
///
/// StatementOptGroup: KwCase^ /* Clipped */ Expr KwOf^ /* Clipped */ Cases OptElsePartEnd;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOptGroup2<'t> {
    pub expr: Box<Expr<'t>>,
    pub cases: Box<Cases<'t>>,
    pub opt_else_part_end: Box<OptElsePartEnd<'t>>,
}

///
/// Type derived for production 105
///
/// StatementOptGroup: "WHILE"^ /* Clipped */ Expr DoBlock;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOptGroup3<'t> {
    pub expr: Box<Expr<'t>>,
    pub do_block: Box<DoBlock<'t>>,
}

///
/// Type derived for production 106
///
/// StatementOptGroup: "REPEAT"^ /* Clipped */ StatementSeq "UNTIL"^ /* Clipped */ Expr;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOptGroup4<'t> {
    pub statement_seq: Box<StatementSeq<'t>>,
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for production 107
///
/// StatementOptGroup: "FOR"^ /* Clipped */ ForInit StatementOpt1 /* Option */ DoBlock;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOptGroup5<'t> {
    pub for_init: Box<ForInit<'t>>,
    pub statement_opt1: Option<Box<StatementOpt1<'t>>>,
    pub do_block: Box<DoBlock<'t>>,
}

///
/// Type derived for production 108
///
/// StatementOptGroup: "LOOP"^ /* Clipped */ StatementSeq KwEnd^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOptGroup6<'t> {
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for production 109
///
/// StatementOptGroup: "WITH"^ /* Clipped */ GuardedDoBlock StatementOptGroupList0 /* Vec */ OptElsePartEnd;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOptGroup7<'t> {
    pub guarded_do_block: Box<GuardedDoBlock<'t>>,
    pub statement_opt_group_list0: Vec<StatementOptGroupList0<'t>>,
    pub opt_else_part_end: Box<OptElsePartEnd<'t>>,
}

///
/// Type derived for production 110
///
/// StatementOptGroup: "EXIT"^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOptGroup8 {}

///
/// Type derived for production 111
///
/// StatementOptGroup: "RETURN"^ /* Clipped */ StatementOpt2 /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOptGroup9<'t> {
    pub statement_opt2: Option<Box<StatementOpt2<'t>>>,
}

///
/// Type derived for production 155
///
/// SimpleExprOptGroup: "\+";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SimpleExprOptGroup0<'t> {
    pub plus: Token<'t>, /* \+ */
}

///
/// Type derived for production 156
///
/// SimpleExprOptGroup: "-";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SimpleExprOptGroup1<'t> {
    pub minus: Token<'t>, /* - */
}

///
/// Type derived for production 161
///
/// Factor: Designator FactorOpt /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor0<'t> {
    pub designator: Box<Designator<'t>>,
    pub factor_opt: Option<Box<FactorOpt<'t>>>,
}

///
/// Type derived for production 162
///
/// Factor: Number;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor1<'t> {
    pub number: Box<Number<'t>>,
}

///
/// Type derived for production 163
///
/// Factor: Character;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor2<'t> {
    pub character: Box<Character<'t>>,
}

///
/// Type derived for production 164
///
/// Factor: String;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor3<'t> {
    pub string: Box<String<'t>>,
}

///
/// Type derived for production 165
///
/// Factor: "NIL"^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor4 {}

///
/// Type derived for production 166
///
/// Factor: Set;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor5<'t> {
    pub set: Box<Set<'t>>,
}

///
/// Type derived for production 167
///
/// Factor: "\("^ /* Clipped */ Expr "\)"^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor6<'t> {
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for production 168
///
/// Factor: "~"^ /* Clipped */ Factor;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor7<'t> {
    pub factor: Box<Factor<'t>>,
}

///
/// Type derived for production 181
///
/// Relation: "="^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relation0 {}

///
/// Type derived for production 182
///
/// Relation: "#";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relation1<'t> {
    pub hash: Token<'t>, /* # */
}

///
/// Type derived for production 183
///
/// Relation: "<";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relation2<'t> {
    pub l_t: Token<'t>, /* < */
}

///
/// Type derived for production 184
///
/// Relation: "<=";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relation3<'t> {
    pub l_t_equ: Token<'t>, /* <= */
}

///
/// Type derived for production 185
///
/// Relation: ">";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relation4<'t> {
    pub g_t: Token<'t>, /* > */
}

///
/// Type derived for production 186
///
/// Relation: ">=";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relation5<'t> {
    pub g_t_equ: Token<'t>, /* >= */
}

///
/// Type derived for production 187
///
/// Relation: InOp;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relation6 {
    pub in_op: Box<InOp>,
}

///
/// Type derived for production 188
///
/// Relation: "IS";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relation7<'t> {
    pub i_s: Token<'t>, /* IS */
}

///
/// Type derived for production 189
///
/// AddOp: "\+";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AddOp0<'t> {
    pub plus: Token<'t>, /* \+ */
}

///
/// Type derived for production 190
///
/// AddOp: "-";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AddOp1<'t> {
    pub minus: Token<'t>, /* - */
}

///
/// Type derived for production 191
///
/// AddOp: "OR";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AddOp2<'t> {
    pub o_r: Token<'t>, /* OR */
}

///
/// Type derived for production 192
///
/// MulOp: "\*";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MulOp0<'t> {
    pub star: Token<'t>, /* \* */
}

///
/// Type derived for production 193
///
/// MulOp: "/";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MulOp1<'t> {
    pub slash: Token<'t>, /* / */
}

///
/// Type derived for production 194
///
/// MulOp: "DIV";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MulOp2<'t> {
    pub d_i_v: Token<'t>, /* DIV */
}

///
/// Type derived for production 195
///
/// MulOp: "MOD";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MulOp3<'t> {
    pub m_o_d: Token<'t>, /* MOD */
}

///
/// Type derived for production 196
///
/// MulOp: "&";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MulOp4<'t> {
    pub amp: Token<'t>, /* & */
}

///
/// Type derived for production 200
///
/// DesignatorSuffix: "\."^ /* Clipped */ Ident;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DesignatorSuffix0<'t> {
    pub ident: Box<Ident<'t>>,
}

///
/// Type derived for production 201
///
/// DesignatorSuffix: "\["^ /* Clipped */ ExprList "\]"^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DesignatorSuffix1<'t> {
    pub expr_list: Box<ExprList<'t>>,
}

///
/// Type derived for production 202
///
/// DesignatorSuffix: "\^"^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DesignatorSuffix2 {}

///
/// Type derived for production 209
///
/// QualIdent: Ident;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct QualIdent0<'t> {
    pub ident: Box<Ident<'t>>,
}

///
/// Type derived for production 210
///
/// QualIdent: QIdent;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct QualIdent1<'t> {
    pub q_ident: Box<QIdent<'t>>,
}

///
/// Type derived for production 213
///
/// IdentDefOptGroup: "\*";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IdentDefOptGroup0<'t> {
    pub star: Token<'t>, /* \* */
}

///
/// Type derived for production 214
///
/// IdentDefOptGroup: "-";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IdentDefOptGroup1<'t> {
    pub minus: Token<'t>, /* - */
}

///
/// Type derived for production 216
///
/// Number: Integer;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number0<'t> {
    pub integer: Box<Integer<'t>>,
}

///
/// Type derived for production 217
///
/// Number: Real;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number1<'t> {
    pub real: Box<Real<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal AddOp
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AddOp<'t> {
    AddOp0(AddOp0<'t>),
    AddOp1(AddOp1<'t>),
    AddOp2(AddOp2<'t>),
}

///
/// Type derived for non-terminal Case
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Case<'t> {
    pub case_opt: Option<Box<CaseOpt<'t>>>,
}

///
/// Type derived for non-terminal CaseLabels
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CaseLabels<'t> {
    pub const_expr: Box<ConstExpr<'t>>,
    pub case_labels_opt: Option<Box<CaseLabelsOpt<'t>>>,
}

///
/// Type derived for non-terminal CaseLabelsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CaseLabelsOpt<'t> {
    pub dot_dot: Token<'t>, /* \.\. */
    pub const_expr: Box<ConstExpr<'t>>,
}

///
/// Type derived for non-terminal CaseOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CaseOpt<'t> {
    pub case_labels: Box<CaseLabels<'t>>,
    pub case_opt_list: Vec<CaseOptList<'t>>,
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal CaseOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CaseOptList<'t> {
    pub case_labels: Box<CaseLabels<'t>>,
}

///
/// Type derived for non-terminal Cases
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Cases<'t> {
    pub case: Box<Case<'t>>,
    pub cases_list: Vec<CasesList<'t>>,
}

///
/// Type derived for non-terminal CasesList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CasesList<'t> {
    pub case: Box<Case<'t>>,
}

///
/// Type derived for non-terminal Character
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Character<'t> {
    pub character: Token<'t>, /* [0-9][0-9A-F]*X */
}

///
/// Type derived for non-terminal ConstDecl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ConstDecl<'t> {
    pub ident_def: Box<IdentDef<'t>>,
    pub const_expr: Box<ConstExpr<'t>>,
}

///
/// Type derived for non-terminal ConstDeclBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ConstDeclBlock<'t> {
    pub const_decl_block_list: Vec<ConstDeclBlockList<'t>>,
}

///
/// Type derived for non-terminal ConstDeclBlockList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ConstDeclBlockList<'t> {
    pub const_decl: Box<ConstDecl<'t>>,
}

///
/// Type derived for non-terminal ConstExpr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ConstExpr<'t> {
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for non-terminal DeclBlock
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DeclBlock<'t> {
    DeclBlock0(DeclBlock0<'t>),
    DeclBlock1(DeclBlock1<'t>),
    DeclBlock2(DeclBlock2<'t>),
}

///
/// Type derived for non-terminal DeclSeq
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclSeq<'t> {
    pub decl_seq_list: Vec<DeclSeqList<'t>>,
    pub decl_seq_list0: Vec<DeclSeqList0<'t>>,
}

///
/// Type derived for non-terminal DeclSeqList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclSeqList<'t> {
    pub decl_block: Box<DeclBlock<'t>>,
}

///
/// Type derived for non-terminal DeclSeqList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclSeqList0<'t> {
    pub decl_seq_list0_group: Box<DeclSeqList0Group<'t>>,
}

///
/// Type derived for non-terminal DeclSeqList0Group
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DeclSeqList0Group<'t> {
    DeclSeqList0Group0(DeclSeqList0Group0<'t>),
    DeclSeqList0Group1(DeclSeqList0Group1<'t>),
}

///
/// Type derived for non-terminal Designator
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Designator<'t> {
    pub qual_ident: Box<QualIdent<'t>>,
    pub designator_list: Vec<DesignatorList<'t>>,
}

///
/// Type derived for non-terminal DesignatorList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DesignatorList<'t> {
    pub designator_suffix: Box<DesignatorSuffix<'t>>,
}

///
/// Type derived for non-terminal DesignatorSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DesignatorSuffix<'t> {
    DesignatorSuffix0(DesignatorSuffix0<'t>),
    DesignatorSuffix1(DesignatorSuffix1<'t>),
    DesignatorSuffix2(DesignatorSuffix2),
}

///
/// Type derived for non-terminal DoBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DoBlock<'t> {
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal Element
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Element<'t> {
    pub expr: Box<Expr<'t>>,
    pub element_opt: Option<Box<ElementOpt<'t>>>,
}

///
/// Type derived for non-terminal ElementOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ElementOpt<'t> {
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for non-terminal ElsePart
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ElsePart<'t> {
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal ElsifPart
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ElsifPart<'t> {
    pub expr: Box<Expr<'t>>,
    pub then_block: Box<ThenBlock<'t>>,
}

///
/// Type derived for non-terminal Expr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expr<'t> {
    pub simple_expr: Box<SimpleExpr<'t>>,
    pub expr_opt: Option<Box<ExprOpt<'t>>>,
}

///
/// Type derived for non-terminal ExprList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ExprList<'t> {
    pub expr: Box<Expr<'t>>,
    pub expr_list_list: Vec<ExprListList<'t>>,
}

///
/// Type derived for non-terminal ExprListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ExprListList<'t> {
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for non-terminal ExprOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ExprOpt<'t> {
    pub relation: Box<Relation<'t>>,
    pub simple_expr: Box<SimpleExpr<'t>>,
}

///
/// Type derived for non-terminal FPSection
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FPSection<'t> {
    pub f_p_section_opt: Option<Box<FPSectionOpt>>,
    pub ident: Box<Ident<'t>>,
    pub f_p_section_list: Vec<FPSectionList<'t>>,
    pub type_def: Box<TypeDef<'t>>,
}

///
/// Type derived for non-terminal FPSectionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FPSectionList<'t> {
    pub ident: Box<Ident<'t>>,
}

///
/// Type derived for non-terminal FPSectionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FPSectionOpt {}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor<'t> {
    Factor0(Factor0<'t>),
    Factor1(Factor1<'t>),
    Factor2(Factor2<'t>),
    Factor3(Factor3<'t>),
    Factor4(Factor4),
    Factor5(Factor5<'t>),
    Factor6(Factor6<'t>),
    Factor7(Factor7<'t>),
}

///
/// Type derived for non-terminal FactorOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FactorOpt<'t> {
    pub factor_opt0: Option<Box<FactorOpt0<'t>>>,
}

///
/// Type derived for non-terminal FactorOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FactorOpt0<'t> {
    pub expr_list: Box<ExprList<'t>>,
}

///
/// Type derived for non-terminal FieldList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FieldList<'t> {
    pub field_list_opt: Option<Box<FieldListOpt<'t>>>,
}

///
/// Type derived for non-terminal FieldListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FieldListOpt<'t> {
    pub ident_list: Box<IdentList<'t>>,
    pub type_def: Box<TypeDef<'t>>,
}

///
/// Type derived for non-terminal ForInit
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ForInit<'t> {
    pub ident: Box<Ident<'t>>,
    pub expr: Box<Expr<'t>>,
    pub expr0: Box<Expr<'t>>,
}

///
/// Type derived for non-terminal ForStep
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ForStep<'t> {
    pub const_expr: Box<ConstExpr<'t>>,
}

///
/// Type derived for non-terminal FormalPars
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FormalPars<'t> {
    pub formal_pars_opt: Option<Box<FormalParsOpt<'t>>>,
    pub formal_pars_opt0: Option<Box<FormalParsOpt0<'t>>>,
}

///
/// Type derived for non-terminal FormalParsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FormalParsOpt<'t> {
    pub f_p_section: Box<FPSection<'t>>,
    pub formal_pars_opt_list: Vec<FormalParsOptList<'t>>,
}

///
/// Type derived for non-terminal FormalParsOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FormalParsOpt0<'t> {
    pub qual_ident: Box<QualIdent<'t>>,
}

///
/// Type derived for non-terminal FormalParsOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FormalParsOptList<'t> {
    pub f_p_section: Box<FPSection<'t>>,
}

///
/// Type derived for non-terminal ForwardDecl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ForwardDecl<'t> {
    pub circumflex: Token<'t>, /* \^ */
    pub forward_decl_opt: Option<Box<ForwardDeclOpt<'t>>>,
    pub ident_def: Box<IdentDef<'t>>,
    pub forward_decl_opt0: Option<Box<ForwardDeclOpt0<'t>>>,
}

///
/// Type derived for non-terminal ForwardDeclOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ForwardDeclOpt<'t> {
    pub receiver: Box<Receiver<'t>>,
}

///
/// Type derived for non-terminal ForwardDeclOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ForwardDeclOpt0<'t> {
    pub formal_pars: Box<FormalPars<'t>>,
}

///
/// Type derived for non-terminal Guard
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Guard<'t> {
    pub qual_ident: Box<QualIdent<'t>>,
    pub qual_ident0: Box<QualIdent<'t>>,
}

///
/// Type derived for non-terminal GuardedDoBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct GuardedDoBlock<'t> {
    pub guard: Box<Guard<'t>>,
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal Ident
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Ident<'t> {
    pub ident: Token<'t>, /* [a-zA-Z_]\w* */
}

///
/// Type derived for non-terminal IdentDef
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IdentDef<'t> {
    pub ident: Box<Ident<'t>>,
    pub ident_def_opt: Option<Box<IdentDefOpt<'t>>>,
}

///
/// Type derived for non-terminal IdentDefOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IdentDefOpt<'t> {
    pub ident_def_opt_group: Box<IdentDefOptGroup<'t>>,
}

///
/// Type derived for non-terminal IdentDefOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IdentDefOptGroup<'t> {
    IdentDefOptGroup0(IdentDefOptGroup0<'t>),
    IdentDefOptGroup1(IdentDefOptGroup1<'t>),
}

///
/// Type derived for non-terminal IdentList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IdentList<'t> {
    pub ident_def: Box<IdentDef<'t>>,
    pub ident_list_list: Vec<IdentListList<'t>>,
}

///
/// Type derived for non-terminal IdentListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IdentListList<'t> {
    pub ident_def: Box<IdentDef<'t>>,
}

///
/// Type derived for non-terminal ImportList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ImportList<'t> {
    pub import_list_opt: Option<Box<ImportListOpt<'t>>>,
    pub ident: Box<Ident<'t>>,
    pub import_list_list: Vec<ImportListList<'t>>,
}

///
/// Type derived for non-terminal ImportListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ImportListList<'t> {
    pub import_list_opt0: Option<Box<ImportListOpt0<'t>>>,
    pub ident: Box<Ident<'t>>,
}

///
/// Type derived for non-terminal ImportListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ImportListOpt<'t> {
    pub ident: Box<Ident<'t>>,
}

///
/// Type derived for non-terminal ImportListOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ImportListOpt0<'t> {
    pub ident: Box<Ident<'t>>,
}

///
/// Type derived for non-terminal InOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InOp {}

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Integer<'t> {
    pub integer: Token<'t>, /* [0-9][0-9]*|[0-9][0-9A-F]*H */
}

///
/// Type derived for non-terminal KwBegin
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct KwBegin {}

///
/// Type derived for non-terminal KwCase
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct KwCase {}

///
/// Type derived for non-terminal KwDo
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct KwDo {}

///
/// Type derived for non-terminal KwElse
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct KwElse {}

///
/// Type derived for non-terminal KwElsif
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct KwElsif {}

///
/// Type derived for non-terminal KwEnd
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct KwEnd {}

///
/// Type derived for non-terminal KwIf
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct KwIf {}

///
/// Type derived for non-terminal KwOf
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct KwOf {}

///
/// Type derived for non-terminal KwProcedure
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct KwProcedure {}

///
/// Type derived for non-terminal KwThen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct KwThen {}

///
/// Type derived for non-terminal KwTo
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct KwTo {}

///
/// Type derived for non-terminal KwVar
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct KwVar {}

///
/// Type derived for non-terminal ModuleBody
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleBody<'t> {
    pub statement_block: Box<StatementBlock<'t>>,
}

///
/// Type derived for non-terminal ModuleHead
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleHead<'t> {
    pub ident: Box<Ident<'t>>,
}

///
/// Type derived for non-terminal MulOp
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MulOp<'t> {
    MulOp0(MulOp0<'t>),
    MulOp1(MulOp1<'t>),
    MulOp2(MulOp2<'t>),
    MulOp3(MulOp3<'t>),
    MulOp4(MulOp4<'t>),
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Number<'t> {
    Number0(Number0<'t>),
    Number1(Number1<'t>),
}

///
/// Type derived for non-terminal Oberon2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Oberon2<'t> {
    pub module_head: Box<ModuleHead<'t>>,
    pub oberon2_opt: Option<Box<Oberon2Opt<'t>>>,
    pub decl_seq: Box<DeclSeq<'t>>,
    pub module_body: Box<ModuleBody<'t>>,
}

///
/// Type derived for non-terminal Oberon2Opt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Oberon2Opt<'t> {
    pub import_list: Box<ImportList<'t>>,
}

///
/// Type derived for non-terminal OptElsePartEnd
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OptElsePartEnd<'t> {
    pub opt_else_part_end_opt: Option<Box<OptElsePartEndOpt<'t>>>,
}

///
/// Type derived for non-terminal OptElsePartEndOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OptElsePartEndOpt<'t> {
    pub else_part: Box<ElsePart<'t>>,
}

///
/// Type derived for non-terminal ProcDecl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ProcDecl<'t> {
    pub procedure_heading: Box<ProcedureHeading<'t>>,
    pub procedure_body: Box<ProcedureBody<'t>>,
}

///
/// Type derived for non-terminal ProcedureBody
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ProcedureBody<'t> {
    pub decl_seq: Box<DeclSeq<'t>>,
    pub statement_block: Box<StatementBlock<'t>>,
}

///
/// Type derived for non-terminal ProcedureHeading
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ProcedureHeading<'t> {
    pub procedure_heading_opt: Option<Box<ProcedureHeadingOpt<'t>>>,
    pub ident_def: Box<IdentDef<'t>>,
    pub procedure_heading_opt0: Option<Box<ProcedureHeadingOpt0<'t>>>,
}

///
/// Type derived for non-terminal ProcedureHeadingOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ProcedureHeadingOpt<'t> {
    pub receiver: Box<Receiver<'t>>,
}

///
/// Type derived for non-terminal ProcedureHeadingOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ProcedureHeadingOpt0<'t> {
    pub formal_pars: Box<FormalPars<'t>>,
}

///
/// Type derived for non-terminal QIdent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct QIdent<'t> {
    pub q_ident: Token<'t>, /* [a-zA-Z_]\w*\.[a-zA-Z_]\w* */
}

///
/// Type derived for non-terminal QualIdent
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum QualIdent<'t> {
    QualIdent0(QualIdent0<'t>),
    QualIdent1(QualIdent1<'t>),
}

///
/// Type derived for non-terminal Real
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Real<'t> {
    pub real: Token<'t>, /* [0-9][0-9]*\.[0-9]*(ED[+-]?[0-9][0-9]*)? */
}

///
/// Type derived for non-terminal Receiver
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Receiver<'t> {
    pub receiver_opt: Option<Box<ReceiverOpt>>,
    pub receiver_var_decl: Box<ReceiverVarDecl<'t>>,
}

///
/// Type derived for non-terminal ReceiverOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ReceiverOpt {}

///
/// Type derived for non-terminal ReceiverVarDecl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ReceiverVarDecl<'t> {
    pub ident: Box<Ident<'t>>,
    pub ident0: Box<Ident<'t>>,
}

///
/// Type derived for non-terminal Relation
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Relation<'t> {
    Relation0(Relation0),
    Relation1(Relation1<'t>),
    Relation2(Relation2<'t>),
    Relation3(Relation3<'t>),
    Relation4(Relation4<'t>),
    Relation5(Relation5<'t>),
    Relation6(Relation6),
    Relation7(Relation7<'t>),
}

///
/// Type derived for non-terminal Set
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Set<'t> {
    pub set_opt: Option<Box<SetOpt<'t>>>,
}

///
/// Type derived for non-terminal SetOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SetOpt<'t> {
    pub element: Box<Element<'t>>,
    pub set_opt_list: Vec<SetOptList<'t>>,
}

///
/// Type derived for non-terminal SetOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SetOptList<'t> {
    pub element: Box<Element<'t>>,
}

///
/// Type derived for non-terminal SimpleExpr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SimpleExpr<'t> {
    pub simple_expr_opt: Option<Box<SimpleExprOpt<'t>>>,
    pub term: Box<Term<'t>>,
    pub simple_expr_list: Vec<SimpleExprList<'t>>,
}

///
/// Type derived for non-terminal SimpleExprList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SimpleExprList<'t> {
    pub add_op: Box<AddOp<'t>>,
    pub term: Box<Term<'t>>,
}

///
/// Type derived for non-terminal SimpleExprOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SimpleExprOpt<'t> {
    pub simple_expr_opt_group: Box<SimpleExprOptGroup<'t>>,
}

///
/// Type derived for non-terminal SimpleExprOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SimpleExprOptGroup<'t> {
    SimpleExprOptGroup0(SimpleExprOptGroup0<'t>),
    SimpleExprOptGroup1(SimpleExprOptGroup1<'t>),
}

///
/// Type derived for non-terminal Statement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement<'t> {
    pub statement_opt: Option<Box<StatementOpt<'t>>>,
}

///
/// Type derived for non-terminal StatementBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementBlock<'t> {
    pub statement_block_opt: Option<Box<StatementBlockOpt<'t>>>,
    pub ident: Box<Ident<'t>>,
}

///
/// Type derived for non-terminal StatementBlockOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementBlockOpt<'t> {
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal StatementOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOpt<'t> {
    pub statement_opt_group: Box<StatementOptGroup<'t>>,
}

///
/// Type derived for non-terminal StatementOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOpt0<'t> {
    pub statement_opt3: Option<Box<StatementOpt3<'t>>>,
}

///
/// Type derived for non-terminal StatementOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOpt1<'t> {
    pub for_step: Box<ForStep<'t>>,
}

///
/// Type derived for non-terminal StatementOpt2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOpt2<'t> {
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for non-terminal StatementOpt3
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOpt3<'t> {
    pub expr_list: Box<ExprList<'t>>,
}

///
/// Type derived for non-terminal StatementOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StatementOptGroup<'t> {
    StatementOptGroup0(StatementOptGroup0<'t>),
    StatementOptGroup1(StatementOptGroup1<'t>),
    StatementOptGroup2(StatementOptGroup2<'t>),
    StatementOptGroup3(StatementOptGroup3<'t>),
    StatementOptGroup4(StatementOptGroup4<'t>),
    StatementOptGroup5(StatementOptGroup5<'t>),
    StatementOptGroup6(StatementOptGroup6<'t>),
    StatementOptGroup7(StatementOptGroup7<'t>),
    StatementOptGroup8(StatementOptGroup8),
    StatementOptGroup9(StatementOptGroup9<'t>),
}

///
/// Type derived for non-terminal StatementOptGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOptGroupList<'t> {
    pub elsif_part: Box<ElsifPart<'t>>,
}

///
/// Type derived for non-terminal StatementOptGroupList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOptGroupList0<'t> {
    pub guarded_do_block: Box<GuardedDoBlock<'t>>,
}

///
/// Type derived for non-terminal StatementOptGroupSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StatementOptGroupSuffix<'t> {
    StatementOptGroupSuffix0(StatementOptGroupSuffix0<'t>),
    StatementOptGroupSuffix1(StatementOptGroupSuffix1<'t>),
}

///
/// Type derived for non-terminal StatementSeq
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementSeq<'t> {
    pub statement: Box<Statement<'t>>,
    pub statement_seq_list: Vec<StatementSeqList<'t>>,
}

///
/// Type derived for non-terminal StatementSeqList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementSeqList<'t> {
    pub statement: Box<Statement<'t>>,
}

///
/// Type derived for non-terminal String
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct String<'t> {
    pub string: Token<'t>, /* \u{0022}[^\u{0022}]*\u{0022}|'[^']*' */
}

///
/// Type derived for non-terminal Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Term<'t> {
    pub factor: Box<Factor<'t>>,
    pub term_list: Vec<TermList<'t>>,
}

///
/// Type derived for non-terminal TermList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TermList<'t> {
    pub mul_op: Box<MulOp<'t>>,
    pub factor: Box<Factor<'t>>,
}

///
/// Type derived for non-terminal ThenBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ThenBlock<'t> {
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal TypeDecl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDecl<'t> {
    pub ident_def: Box<IdentDef<'t>>,
    pub type_def: Box<TypeDef<'t>>,
}

///
/// Type derived for non-terminal TypeDeclBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDeclBlock<'t> {
    pub type_decl_block_list: Vec<TypeDeclBlockList<'t>>,
}

///
/// Type derived for non-terminal TypeDeclBlockList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDeclBlockList<'t> {
    pub type_decl: Box<TypeDecl<'t>>,
}

///
/// Type derived for non-terminal TypeDef
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TypeDef<'t> {
    TypeDef0(TypeDef0<'t>),
    TypeDef1(TypeDef1<'t>),
    TypeDef2(TypeDef2<'t>),
    TypeDef3(TypeDef3<'t>),
    TypeDef4(TypeDef4<'t>),
}

///
/// Type derived for non-terminal TypeDefList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDefList<'t> {
    pub field_list: Box<FieldList<'t>>,
}

///
/// Type derived for non-terminal TypeDefOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDefOpt<'t> {
    pub const_expr: Box<ConstExpr<'t>>,
    pub type_def_opt_list: Vec<TypeDefOptList<'t>>,
}

///
/// Type derived for non-terminal TypeDefOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDefOpt0<'t> {
    pub qual_ident: Box<QualIdent<'t>>,
}

///
/// Type derived for non-terminal TypeDefOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDefOpt1<'t> {
    pub formal_pars: Box<FormalPars<'t>>,
}

///
/// Type derived for non-terminal TypeDefOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDefOptList<'t> {
    pub const_expr: Box<ConstExpr<'t>>,
}

///
/// Type derived for non-terminal VarDecl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct VarDecl<'t> {
    pub ident_list: Box<IdentList<'t>>,
    pub type_def: Box<TypeDef<'t>>,
}

///
/// Type derived for non-terminal VarDeclBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct VarDeclBlock<'t> {
    pub var_decl_block_list: Vec<VarDeclBlockList<'t>>,
}

///
/// Type derived for non-terminal VarDeclBlockList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct VarDeclBlockList<'t> {
    pub var_decl: Box<VarDecl<'t>>,
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    AddOp(AddOp<'t>),
    Case(Case<'t>),
    CaseLabels(CaseLabels<'t>),
    CaseLabelsOpt(Option<Box<CaseLabelsOpt<'t>>>),
    CaseOpt(Option<Box<CaseOpt<'t>>>),
    CaseOptList(Vec<CaseOptList<'t>>),
    Cases(Cases<'t>),
    CasesList(Vec<CasesList<'t>>),
    Character(Character<'t>),
    ConstDecl(ConstDecl<'t>),
    ConstDeclBlock(ConstDeclBlock<'t>),
    ConstDeclBlockList(Vec<ConstDeclBlockList<'t>>),
    ConstExpr(ConstExpr<'t>),
    DeclBlock(DeclBlock<'t>),
    DeclSeq(DeclSeq<'t>),
    DeclSeqList(Vec<DeclSeqList<'t>>),
    DeclSeqList0(Vec<DeclSeqList0<'t>>),
    DeclSeqList0Group(DeclSeqList0Group<'t>),
    Designator(Designator<'t>),
    DesignatorList(Vec<DesignatorList<'t>>),
    DesignatorSuffix(DesignatorSuffix<'t>),
    DoBlock(DoBlock<'t>),
    Element(Element<'t>),
    ElementOpt(Option<Box<ElementOpt<'t>>>),
    ElsePart(ElsePart<'t>),
    ElsifPart(ElsifPart<'t>),
    Expr(Expr<'t>),
    ExprList(ExprList<'t>),
    ExprListList(Vec<ExprListList<'t>>),
    ExprOpt(Option<Box<ExprOpt<'t>>>),
    FPSection(FPSection<'t>),
    FPSectionList(Vec<FPSectionList<'t>>),
    FPSectionOpt(Option<Box<FPSectionOpt>>),
    Factor(Factor<'t>),
    FactorOpt(Option<Box<FactorOpt<'t>>>),
    FactorOpt0(Option<Box<FactorOpt0<'t>>>),
    FieldList(FieldList<'t>),
    FieldListOpt(Option<Box<FieldListOpt<'t>>>),
    ForInit(ForInit<'t>),
    ForStep(ForStep<'t>),
    FormalPars(FormalPars<'t>),
    FormalParsOpt(Option<Box<FormalParsOpt<'t>>>),
    FormalParsOpt0(Option<Box<FormalParsOpt0<'t>>>),
    FormalParsOptList(Vec<FormalParsOptList<'t>>),
    ForwardDecl(ForwardDecl<'t>),
    ForwardDeclOpt(Option<Box<ForwardDeclOpt<'t>>>),
    ForwardDeclOpt0(Option<Box<ForwardDeclOpt0<'t>>>),
    Guard(Guard<'t>),
    GuardedDoBlock(GuardedDoBlock<'t>),
    Ident(Ident<'t>),
    IdentDef(IdentDef<'t>),
    IdentDefOpt(Option<Box<IdentDefOpt<'t>>>),
    IdentDefOptGroup(IdentDefOptGroup<'t>),
    IdentList(IdentList<'t>),
    IdentListList(Vec<IdentListList<'t>>),
    ImportList(ImportList<'t>),
    ImportListList(Vec<ImportListList<'t>>),
    ImportListOpt(Option<Box<ImportListOpt<'t>>>),
    ImportListOpt0(Option<Box<ImportListOpt0<'t>>>),
    InOp(InOp),
    Integer(Integer<'t>),
    KwBegin(KwBegin),
    KwCase(KwCase),
    KwDo(KwDo),
    KwElse(KwElse),
    KwElsif(KwElsif),
    KwEnd(KwEnd),
    KwIf(KwIf),
    KwOf(KwOf),
    KwProcedure(KwProcedure),
    KwThen(KwThen),
    KwTo(KwTo),
    KwVar(KwVar),
    ModuleBody(ModuleBody<'t>),
    ModuleHead(ModuleHead<'t>),
    MulOp(MulOp<'t>),
    Number(Number<'t>),
    Oberon2(Oberon2<'t>),
    Oberon2Opt(Option<Box<Oberon2Opt<'t>>>),
    OptElsePartEnd(OptElsePartEnd<'t>),
    OptElsePartEndOpt(Option<Box<OptElsePartEndOpt<'t>>>),
    ProcDecl(ProcDecl<'t>),
    ProcedureBody(ProcedureBody<'t>),
    ProcedureHeading(ProcedureHeading<'t>),
    ProcedureHeadingOpt(Option<Box<ProcedureHeadingOpt<'t>>>),
    ProcedureHeadingOpt0(Option<Box<ProcedureHeadingOpt0<'t>>>),
    QIdent(QIdent<'t>),
    QualIdent(QualIdent<'t>),
    Real(Real<'t>),
    Receiver(Receiver<'t>),
    ReceiverOpt(Option<Box<ReceiverOpt>>),
    ReceiverVarDecl(ReceiverVarDecl<'t>),
    Relation(Relation<'t>),
    Set(Set<'t>),
    SetOpt(Option<Box<SetOpt<'t>>>),
    SetOptList(Vec<SetOptList<'t>>),
    SimpleExpr(SimpleExpr<'t>),
    SimpleExprList(Vec<SimpleExprList<'t>>),
    SimpleExprOpt(Option<Box<SimpleExprOpt<'t>>>),
    SimpleExprOptGroup(SimpleExprOptGroup<'t>),
    Statement(Statement<'t>),
    StatementBlock(StatementBlock<'t>),
    StatementBlockOpt(Option<Box<StatementBlockOpt<'t>>>),
    StatementOpt(Option<Box<StatementOpt<'t>>>),
    StatementOpt0(Option<Box<StatementOpt0<'t>>>),
    StatementOpt1(Option<Box<StatementOpt1<'t>>>),
    StatementOpt2(Option<Box<StatementOpt2<'t>>>),
    StatementOpt3(Option<Box<StatementOpt3<'t>>>),
    StatementOptGroup(StatementOptGroup<'t>),
    StatementOptGroupList(Vec<StatementOptGroupList<'t>>),
    StatementOptGroupList0(Vec<StatementOptGroupList0<'t>>),
    StatementOptGroupSuffix(StatementOptGroupSuffix<'t>),
    StatementSeq(StatementSeq<'t>),
    StatementSeqList(Vec<StatementSeqList<'t>>),
    String(String<'t>),
    Term(Term<'t>),
    TermList(Vec<TermList<'t>>),
    ThenBlock(ThenBlock<'t>),
    TypeDecl(TypeDecl<'t>),
    TypeDeclBlock(TypeDeclBlock<'t>),
    TypeDeclBlockList(Vec<TypeDeclBlockList<'t>>),
    TypeDef(TypeDef<'t>),
    TypeDefList(Vec<TypeDefList<'t>>),
    TypeDefOpt(Option<Box<TypeDefOpt<'t>>>),
    TypeDefOpt0(Option<Box<TypeDefOpt0<'t>>>),
    TypeDefOpt1(Option<Box<TypeDefOpt1<'t>>>),
    TypeDefOptList(Vec<TypeDefOptList<'t>>),
    VarDecl(VarDecl<'t>),
    VarDeclBlock(VarDeclBlock<'t>),
    VarDeclBlockList(Vec<VarDeclBlockList<'t>>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct Oberon2GrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn Oberon2GrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `Oberon2GrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> Oberon2GrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn Oberon2GrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// KwBegin: "BEGIN"^ /* Clipped */;
    ///
    #[named]
    fn kw_begin(
        &mut self,
        _kw_begin: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_begin_built = KwBeginBuilder::default()
            // Ignore clipped member 'kw_begin'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.kw_begin(&kw_begin_built)?;
        self.push(ASTType::KwBegin(kw_begin_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// KwCase: "CASE"^ /* Clipped */;
    ///
    #[named]
    fn kw_case(
        &mut self,
        _kw_case: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_case_built = KwCaseBuilder::default()
            // Ignore clipped member 'kw_case'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.kw_case(&kw_case_built)?;
        self.push(ASTType::KwCase(kw_case_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// KwDo: "DO"^ /* Clipped */;
    ///
    #[named]
    fn kw_do(
        &mut self,
        _kw_do: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_do_built = KwDoBuilder::default()
            // Ignore clipped member 'kw_do'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.kw_do(&kw_do_built)?;
        self.push(ASTType::KwDo(kw_do_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// KwElse: "ELSE"^ /* Clipped */;
    ///
    #[named]
    fn kw_else(
        &mut self,
        _kw_else: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_else_built = KwElseBuilder::default()
            // Ignore clipped member 'kw_else'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.kw_else(&kw_else_built)?;
        self.push(ASTType::KwElse(kw_else_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// KwElsif: "ELSIF"^ /* Clipped */;
    ///
    #[named]
    fn kw_elsif(
        &mut self,
        _kw_elsif: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_elsif_built = KwElsifBuilder::default()
            // Ignore clipped member 'kw_elsif'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.kw_elsif(&kw_elsif_built)?;
        self.push(ASTType::KwElsif(kw_elsif_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// KwEnd: "END"^ /* Clipped */;
    ///
    #[named]
    fn kw_end(
        &mut self,
        _kw_end: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_end_built = KwEndBuilder::default()
            // Ignore clipped member 'kw_end'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.kw_end(&kw_end_built)?;
        self.push(ASTType::KwEnd(kw_end_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// KwIf: "IF"^ /* Clipped */;
    ///
    #[named]
    fn kw_if(
        &mut self,
        _kw_if: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_if_built = KwIfBuilder::default()
            // Ignore clipped member 'kw_if'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.kw_if(&kw_if_built)?;
        self.push(ASTType::KwIf(kw_if_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// KwOf: "OF"^ /* Clipped */;
    ///
    #[named]
    fn kw_of(
        &mut self,
        _kw_of: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_of_built = KwOfBuilder::default()
            // Ignore clipped member 'kw_of'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.kw_of(&kw_of_built)?;
        self.push(ASTType::KwOf(kw_of_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// KwProcedure: "PROCEDURE"^ /* Clipped */;
    ///
    #[named]
    fn kw_procedure(
        &mut self,
        _kw_procedure: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_procedure_built = KwProcedureBuilder::default()
            // Ignore clipped member 'kw_procedure'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.kw_procedure(&kw_procedure_built)?;
        self.push(ASTType::KwProcedure(kw_procedure_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// KwThen: "THEN"^ /* Clipped */;
    ///
    #[named]
    fn kw_then(
        &mut self,
        _kw_then: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_then_built = KwThenBuilder::default()
            // Ignore clipped member 'kw_then'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.kw_then(&kw_then_built)?;
        self.push(ASTType::KwThen(kw_then_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// KwTo: "TO"^ /* Clipped */;
    ///
    #[named]
    fn kw_to(
        &mut self,
        _kw_to: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_to_built = KwToBuilder::default()
            // Ignore clipped member 'kw_to'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.kw_to(&kw_to_built)?;
        self.push(ASTType::KwTo(kw_to_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// KwVar: "VAR"^ /* Clipped */;
    ///
    #[named]
    fn kw_var(
        &mut self,
        _kw_var: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_var_built = KwVarBuilder::default()
            // Ignore clipped member 'kw_var'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.kw_var(&kw_var_built)?;
        self.push(ASTType::KwVar(kw_var_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// Oberon2: ModuleHead Oberon2Opt /* Option */ DeclSeq ModuleBody;
    ///
    #[named]
    fn oberon2(
        &mut self,
        _module_head: &ParseTreeStackEntry<'t>,
        _oberon2_opt: &ParseTreeStackEntry<'t>,
        _decl_seq: &ParseTreeStackEntry<'t>,
        _module_body: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_body = pop_item!(self, module_body, ModuleBody, context);
        let decl_seq = pop_item!(self, decl_seq, DeclSeq, context);
        let oberon2_opt = pop_item!(self, oberon2_opt, Oberon2Opt, context);
        let module_head = pop_item!(self, module_head, ModuleHead, context);
        let oberon2_built = Oberon2Builder::default()
            .module_head(Box::new(module_head))
            .oberon2_opt(oberon2_opt)
            .decl_seq(Box::new(decl_seq))
            .module_body(Box::new(module_body))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.oberon2(&oberon2_built)?;
        self.push(ASTType::Oberon2(oberon2_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// Oberon2Opt /* Option<T>::Some */: ImportList;
    ///
    #[named]
    fn oberon2_opt_0(
        &mut self,
        _import_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_list = pop_item!(self, import_list, ImportList, context);
        let oberon2_opt_0_built = Oberon2OptBuilder::default()
            .import_list(Box::new(import_list))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::Oberon2Opt(Some(Box::new(oberon2_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// Oberon2Opt /* Option<T>::None */: ;
    ///
    #[named]
    fn oberon2_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::Oberon2Opt(None), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// ModuleHead: "MODULE"^ /* Clipped */ Ident ";"^ /* Clipped */;
    ///
    #[named]
    fn module_head(
        &mut self,
        _m_o_d_u_l_e: &ParseTreeStackEntry<'t>,
        _ident: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let module_head_built = ModuleHeadBuilder::default()
            // Ignore clipped member 'm_o_d_u_l_e'
            .ident(Box::new(ident))
            // Ignore clipped member 'semicolon'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.module_head(&module_head_built)?;
        self.push(ASTType::ModuleHead(module_head_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// ModuleBody: StatementBlock "\."^ /* Clipped */;
    ///
    #[named]
    fn module_body(
        &mut self,
        _statement_block: &ParseTreeStackEntry<'t>,
        _dot: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block = pop_item!(self, statement_block, StatementBlock, context);
        let module_body_built = ModuleBodyBuilder::default()
            .statement_block(Box::new(statement_block))
            // Ignore clipped member 'dot'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.module_body(&module_body_built)?;
        self.push(ASTType::ModuleBody(module_body_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// ImportList: "IMPORT"^ /* Clipped */ ImportListOpt /* Option */ Ident ImportListList /* Vec */ ";"^ /* Clipped */;
    ///
    #[named]
    fn import_list(
        &mut self,
        _i_m_p_o_r_t: &ParseTreeStackEntry<'t>,
        _import_list_opt: &ParseTreeStackEntry<'t>,
        _ident: &ParseTreeStackEntry<'t>,
        _import_list_list: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_list_list =
            pop_and_reverse_item!(self, import_list_list, ImportListList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let import_list_opt = pop_item!(self, import_list_opt, ImportListOpt, context);
        let import_list_built = ImportListBuilder::default()
            // Ignore clipped member 'i_m_p_o_r_t'
            .import_list_opt(import_list_opt)
            .ident(Box::new(ident))
            .import_list_list(import_list_list)
            // Ignore clipped member 'semicolon'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.import_list(&import_list_built)?;
        self.push(ASTType::ImportList(import_list_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// ImportListList /* Vec<T>::Push */: ","^ /* Clipped */ ImportListOpt0 /* Option */ Ident ImportListList;
    ///
    #[named]
    fn import_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _import_list_opt0: &ParseTreeStackEntry<'t>,
        _ident: &ParseTreeStackEntry<'t>,
        _import_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut import_list_list = pop_item!(self, import_list_list, ImportListList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let import_list_opt0 = pop_item!(self, import_list_opt0, ImportListOpt0, context);
        let import_list_list_0_built = ImportListListBuilder::default()
            .ident(Box::new(ident))
            .import_list_opt0(import_list_opt0)
            // Ignore clipped member 'comma'
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        import_list_list.push(import_list_list_0_built);
        self.push(ASTType::ImportListList(import_list_list), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// ImportListList /* Vec<T>::New */: ;
    ///
    #[named]
    fn import_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_list_list_1_built = Vec::new();
        self.push(ASTType::ImportListList(import_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// ImportListOpt0 /* Option<T>::Some */: Ident ":="^ /* Clipped */;
    ///
    #[named]
    fn import_list_opt0_0(
        &mut self,
        _ident: &ParseTreeStackEntry<'t>,
        _colon_equ: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let import_list_opt0_0_built = ImportListOpt0Builder::default()
            .ident(Box::new(ident))
            // Ignore clipped member 'colon_equ'
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ImportListOpt0(Some(Box::new(import_list_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// ImportListOpt0 /* Option<T>::None */: ;
    ///
    #[named]
    fn import_list_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ImportListOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// ImportListOpt /* Option<T>::Some */: Ident ":="^ /* Clipped */;
    ///
    #[named]
    fn import_list_opt_0(
        &mut self,
        _ident: &ParseTreeStackEntry<'t>,
        _colon_equ: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let import_list_opt_0_built = ImportListOptBuilder::default()
            .ident(Box::new(ident))
            // Ignore clipped member 'colon_equ'
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ImportListOpt(Some(Box::new(import_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// ImportListOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn import_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ImportListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// DeclSeq: DeclSeqList /* Vec */ DeclSeqList0 /* Vec */;
    ///
    #[named]
    fn decl_seq(
        &mut self,
        _decl_seq_list: &ParseTreeStackEntry<'t>,
        _decl_seq_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let decl_seq_list0 = pop_and_reverse_item!(self, decl_seq_list0, DeclSeqList0, context);
        let decl_seq_list = pop_and_reverse_item!(self, decl_seq_list, DeclSeqList, context);
        let decl_seq_built = DeclSeqBuilder::default()
            .decl_seq_list(decl_seq_list)
            .decl_seq_list0(decl_seq_list0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.decl_seq(&decl_seq_built)?;
        self.push(ASTType::DeclSeq(decl_seq_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// DeclSeqList0 /* Vec<T>::Push */: DeclSeqList0Group DeclSeqList0;
    ///
    #[named]
    fn decl_seq_list0_0(
        &mut self,
        _decl_seq_list0_group: &ParseTreeStackEntry<'t>,
        _decl_seq_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut decl_seq_list0 = pop_item!(self, decl_seq_list0, DeclSeqList0, context);
        let decl_seq_list0_group =
            pop_item!(self, decl_seq_list0_group, DeclSeqList0Group, context);
        let decl_seq_list0_0_built = DeclSeqList0Builder::default()
            .decl_seq_list0_group(Box::new(decl_seq_list0_group))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        decl_seq_list0.push(decl_seq_list0_0_built);
        self.push(ASTType::DeclSeqList0(decl_seq_list0), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// DeclSeqList0Group: ProcDecl ";"^ /* Clipped */;
    ///
    #[named]
    fn decl_seq_list0_group_0(
        &mut self,
        _proc_decl: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proc_decl = pop_item!(self, proc_decl, ProcDecl, context);
        let decl_seq_list0_group_0_built = DeclSeqList0Group0Builder::default()
            .proc_decl(Box::new(proc_decl))
            // Ignore clipped member 'semicolon'
            .build()
            .into_diagnostic()?;
        let decl_seq_list0_group_0_built =
            DeclSeqList0Group::DeclSeqList0Group0(decl_seq_list0_group_0_built);
        self.push(
            ASTType::DeclSeqList0Group(decl_seq_list0_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// DeclSeqList0Group: ForwardDecl ";"^ /* Clipped */;
    ///
    #[named]
    fn decl_seq_list0_group_1(
        &mut self,
        _forward_decl: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let forward_decl = pop_item!(self, forward_decl, ForwardDecl, context);
        let decl_seq_list0_group_1_built = DeclSeqList0Group1Builder::default()
            .forward_decl(Box::new(forward_decl))
            // Ignore clipped member 'semicolon'
            .build()
            .into_diagnostic()?;
        let decl_seq_list0_group_1_built =
            DeclSeqList0Group::DeclSeqList0Group1(decl_seq_list0_group_1_built);
        self.push(
            ASTType::DeclSeqList0Group(decl_seq_list0_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// DeclSeqList0 /* Vec<T>::New */: ;
    ///
    #[named]
    fn decl_seq_list0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let decl_seq_list0_1_built = Vec::new();
        self.push(ASTType::DeclSeqList0(decl_seq_list0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// DeclSeqList /* Vec<T>::Push */: DeclBlock DeclSeqList;
    ///
    #[named]
    fn decl_seq_list_0(
        &mut self,
        _decl_block: &ParseTreeStackEntry<'t>,
        _decl_seq_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut decl_seq_list = pop_item!(self, decl_seq_list, DeclSeqList, context);
        let decl_block = pop_item!(self, decl_block, DeclBlock, context);
        let decl_seq_list_0_built = DeclSeqListBuilder::default()
            .decl_block(Box::new(decl_block))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        decl_seq_list.push(decl_seq_list_0_built);
        self.push(ASTType::DeclSeqList(decl_seq_list), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// DeclSeqList /* Vec<T>::New */: ;
    ///
    #[named]
    fn decl_seq_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let decl_seq_list_1_built = Vec::new();
        self.push(ASTType::DeclSeqList(decl_seq_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// DeclBlock: ConstDeclBlock;
    ///
    #[named]
    fn decl_block_0(
        &mut self,
        _const_decl_block: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_decl_block = pop_item!(self, const_decl_block, ConstDeclBlock, context);
        let decl_block_0_built = DeclBlock0Builder::default()
            .const_decl_block(Box::new(const_decl_block))
            .build()
            .into_diagnostic()?;
        let decl_block_0_built = DeclBlock::DeclBlock0(decl_block_0_built);
        // Calling user action here
        self.user_grammar.decl_block(&decl_block_0_built)?;
        self.push(ASTType::DeclBlock(decl_block_0_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// DeclBlock: TypeDeclBlock;
    ///
    #[named]
    fn decl_block_1(
        &mut self,
        _type_decl_block: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_decl_block = pop_item!(self, type_decl_block, TypeDeclBlock, context);
        let decl_block_1_built = DeclBlock1Builder::default()
            .type_decl_block(Box::new(type_decl_block))
            .build()
            .into_diagnostic()?;
        let decl_block_1_built = DeclBlock::DeclBlock1(decl_block_1_built);
        // Calling user action here
        self.user_grammar.decl_block(&decl_block_1_built)?;
        self.push(ASTType::DeclBlock(decl_block_1_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// DeclBlock: VarDeclBlock;
    ///
    #[named]
    fn decl_block_2(
        &mut self,
        _var_decl_block: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_decl_block = pop_item!(self, var_decl_block, VarDeclBlock, context);
        let decl_block_2_built = DeclBlock2Builder::default()
            .var_decl_block(Box::new(var_decl_block))
            .build()
            .into_diagnostic()?;
        let decl_block_2_built = DeclBlock::DeclBlock2(decl_block_2_built);
        // Calling user action here
        self.user_grammar.decl_block(&decl_block_2_built)?;
        self.push(ASTType::DeclBlock(decl_block_2_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// ConstDeclBlock: "CONST"^ /* Clipped */ ConstDeclBlockList /* Vec */;
    ///
    #[named]
    fn const_decl_block(
        &mut self,
        _c_o_n_s_t: &ParseTreeStackEntry<'t>,
        _const_decl_block_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_decl_block_list =
            pop_and_reverse_item!(self, const_decl_block_list, ConstDeclBlockList, context);
        let const_decl_block_built = ConstDeclBlockBuilder::default()
            // Ignore clipped member 'c_o_n_s_t'
            .const_decl_block_list(const_decl_block_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .const_decl_block(&const_decl_block_built)?;
        self.push(ASTType::ConstDeclBlock(const_decl_block_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// ConstDeclBlockList /* Vec<T>::Push */: ConstDecl ";"^ /* Clipped */ ConstDeclBlockList;
    ///
    #[named]
    fn const_decl_block_list_0(
        &mut self,
        _const_decl: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _const_decl_block_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut const_decl_block_list =
            pop_item!(self, const_decl_block_list, ConstDeclBlockList, context);
        let const_decl = pop_item!(self, const_decl, ConstDecl, context);
        let const_decl_block_list_0_built = ConstDeclBlockListBuilder::default()
            // Ignore clipped member 'semicolon'
            .const_decl(Box::new(const_decl))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        const_decl_block_list.push(const_decl_block_list_0_built);
        self.push(ASTType::ConstDeclBlockList(const_decl_block_list), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// ConstDeclBlockList /* Vec<T>::New */: ;
    ///
    #[named]
    fn const_decl_block_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_decl_block_list_1_built = Vec::new();
        self.push(
            ASTType::ConstDeclBlockList(const_decl_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// TypeDeclBlock: "TYPE"^ /* Clipped */ TypeDeclBlockList /* Vec */;
    ///
    #[named]
    fn type_decl_block(
        &mut self,
        _t_y_p_e: &ParseTreeStackEntry<'t>,
        _type_decl_block_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_decl_block_list =
            pop_and_reverse_item!(self, type_decl_block_list, TypeDeclBlockList, context);
        let type_decl_block_built = TypeDeclBlockBuilder::default()
            // Ignore clipped member 't_y_p_e'
            .type_decl_block_list(type_decl_block_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.type_decl_block(&type_decl_block_built)?;
        self.push(ASTType::TypeDeclBlock(type_decl_block_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// TypeDeclBlockList /* Vec<T>::Push */: TypeDecl ";"^ /* Clipped */ TypeDeclBlockList;
    ///
    #[named]
    fn type_decl_block_list_0(
        &mut self,
        _type_decl: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _type_decl_block_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut type_decl_block_list =
            pop_item!(self, type_decl_block_list, TypeDeclBlockList, context);
        let type_decl = pop_item!(self, type_decl, TypeDecl, context);
        let type_decl_block_list_0_built = TypeDeclBlockListBuilder::default()
            // Ignore clipped member 'semicolon'
            .type_decl(Box::new(type_decl))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        type_decl_block_list.push(type_decl_block_list_0_built);
        self.push(ASTType::TypeDeclBlockList(type_decl_block_list), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// TypeDeclBlockList /* Vec<T>::New */: ;
    ///
    #[named]
    fn type_decl_block_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_decl_block_list_1_built = Vec::new();
        self.push(
            ASTType::TypeDeclBlockList(type_decl_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// VarDeclBlock: KwVar^ /* Clipped */ VarDeclBlockList /* Vec */;
    ///
    #[named]
    fn var_decl_block(
        &mut self,
        _kw_var: &ParseTreeStackEntry<'t>,
        _var_decl_block_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_decl_block_list =
            pop_and_reverse_item!(self, var_decl_block_list, VarDeclBlockList, context);
        // Ignore clipped member 'kw_var'
        self.pop(context);
        let var_decl_block_built = VarDeclBlockBuilder::default()
            // Ignore clipped member 'kw_var'
            .var_decl_block_list(var_decl_block_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.var_decl_block(&var_decl_block_built)?;
        self.push(ASTType::VarDeclBlock(var_decl_block_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// VarDeclBlockList /* Vec<T>::Push */: VarDecl ";"^ /* Clipped */ VarDeclBlockList;
    ///
    #[named]
    fn var_decl_block_list_0(
        &mut self,
        _var_decl: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _var_decl_block_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut var_decl_block_list =
            pop_item!(self, var_decl_block_list, VarDeclBlockList, context);
        let var_decl = pop_item!(self, var_decl, VarDecl, context);
        let var_decl_block_list_0_built = VarDeclBlockListBuilder::default()
            // Ignore clipped member 'semicolon'
            .var_decl(Box::new(var_decl))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        var_decl_block_list.push(var_decl_block_list_0_built);
        self.push(ASTType::VarDeclBlockList(var_decl_block_list), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// VarDeclBlockList /* Vec<T>::New */: ;
    ///
    #[named]
    fn var_decl_block_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_decl_block_list_1_built = Vec::new();
        self.push(
            ASTType::VarDeclBlockList(var_decl_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// ConstDecl: IdentDef "="^ /* Clipped */ ConstExpr;
    ///
    #[named]
    fn const_decl(
        &mut self,
        _ident_def: &ParseTreeStackEntry<'t>,
        _equ: &ParseTreeStackEntry<'t>,
        _const_expr: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_expr = pop_item!(self, const_expr, ConstExpr, context);
        let ident_def = pop_item!(self, ident_def, IdentDef, context);
        let const_decl_built = ConstDeclBuilder::default()
            .ident_def(Box::new(ident_def))
            // Ignore clipped member 'equ'
            .const_expr(Box::new(const_expr))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.const_decl(&const_decl_built)?;
        self.push(ASTType::ConstDecl(const_decl_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// TypeDecl: IdentDef "="^ /* Clipped */ TypeDef;
    ///
    #[named]
    fn type_decl(
        &mut self,
        _ident_def: &ParseTreeStackEntry<'t>,
        _equ: &ParseTreeStackEntry<'t>,
        _type_def: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def = pop_item!(self, type_def, TypeDef, context);
        let ident_def = pop_item!(self, ident_def, IdentDef, context);
        let type_decl_built = TypeDeclBuilder::default()
            .ident_def(Box::new(ident_def))
            // Ignore clipped member 'equ'
            .type_def(Box::new(type_def))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.type_decl(&type_decl_built)?;
        self.push(ASTType::TypeDecl(type_decl_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// VarDecl: IdentList ":"^ /* Clipped */ TypeDef;
    ///
    #[named]
    fn var_decl(
        &mut self,
        _ident_list: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type_def: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def = pop_item!(self, type_def, TypeDef, context);
        let ident_list = pop_item!(self, ident_list, IdentList, context);
        let var_decl_built = VarDeclBuilder::default()
            .ident_list(Box::new(ident_list))
            // Ignore clipped member 'colon'
            .type_def(Box::new(type_def))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.var_decl(&var_decl_built)?;
        self.push(ASTType::VarDecl(var_decl_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// ProcDecl: ProcedureHeading ";"^ /* Clipped */ ProcedureBody;
    ///
    #[named]
    fn proc_decl(
        &mut self,
        _procedure_heading: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _procedure_body: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let procedure_body = pop_item!(self, procedure_body, ProcedureBody, context);
        let procedure_heading = pop_item!(self, procedure_heading, ProcedureHeading, context);
        let proc_decl_built = ProcDeclBuilder::default()
            .procedure_heading(Box::new(procedure_heading))
            // Ignore clipped member 'semicolon'
            .procedure_body(Box::new(procedure_body))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.proc_decl(&proc_decl_built)?;
        self.push(ASTType::ProcDecl(proc_decl_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// ProcedureHeading: KwProcedure^ /* Clipped */ ProcedureHeadingOpt /* Option */ IdentDef ProcedureHeadingOpt0 /* Option */;
    ///
    #[named]
    fn procedure_heading(
        &mut self,
        _kw_procedure: &ParseTreeStackEntry<'t>,
        _procedure_heading_opt: &ParseTreeStackEntry<'t>,
        _ident_def: &ParseTreeStackEntry<'t>,
        _procedure_heading_opt0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let procedure_heading_opt0 =
            pop_item!(self, procedure_heading_opt0, ProcedureHeadingOpt0, context);
        let ident_def = pop_item!(self, ident_def, IdentDef, context);
        let procedure_heading_opt =
            pop_item!(self, procedure_heading_opt, ProcedureHeadingOpt, context);
        // Ignore clipped member 'kw_procedure'
        self.pop(context);
        let procedure_heading_built = ProcedureHeadingBuilder::default()
            // Ignore clipped member 'kw_procedure'
            .procedure_heading_opt(procedure_heading_opt)
            .ident_def(Box::new(ident_def))
            .procedure_heading_opt0(procedure_heading_opt0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .procedure_heading(&procedure_heading_built)?;
        self.push(ASTType::ProcedureHeading(procedure_heading_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// ProcedureHeadingOpt0 /* Option<T>::Some */: FormalPars;
    ///
    #[named]
    fn procedure_heading_opt0_0(
        &mut self,
        _formal_pars: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let formal_pars = pop_item!(self, formal_pars, FormalPars, context);
        let procedure_heading_opt0_0_built = ProcedureHeadingOpt0Builder::default()
            .formal_pars(Box::new(formal_pars))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ProcedureHeadingOpt0(Some(Box::new(procedure_heading_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// ProcedureHeadingOpt0 /* Option<T>::None */: ;
    ///
    #[named]
    fn procedure_heading_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ProcedureHeadingOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// ProcedureHeadingOpt /* Option<T>::Some */: Receiver;
    ///
    #[named]
    fn procedure_heading_opt_0(
        &mut self,
        _receiver: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let receiver = pop_item!(self, receiver, Receiver, context);
        let procedure_heading_opt_0_built = ProcedureHeadingOptBuilder::default()
            .receiver(Box::new(receiver))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ProcedureHeadingOpt(Some(Box::new(procedure_heading_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// ProcedureHeadingOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn procedure_heading_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ProcedureHeadingOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// ProcedureBody: DeclSeq StatementBlock;
    ///
    #[named]
    fn procedure_body(
        &mut self,
        _decl_seq: &ParseTreeStackEntry<'t>,
        _statement_block: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block = pop_item!(self, statement_block, StatementBlock, context);
        let decl_seq = pop_item!(self, decl_seq, DeclSeq, context);
        let procedure_body_built = ProcedureBodyBuilder::default()
            .decl_seq(Box::new(decl_seq))
            .statement_block(Box::new(statement_block))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.procedure_body(&procedure_body_built)?;
        self.push(ASTType::ProcedureBody(procedure_body_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// StatementBlock: StatementBlockOpt /* Option */ KwEnd^ /* Clipped */ Ident;
    ///
    #[named]
    fn statement_block(
        &mut self,
        _statement_block_opt: &ParseTreeStackEntry<'t>,
        _kw_end: &ParseTreeStackEntry<'t>,
        _ident: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        // Ignore clipped member 'kw_end'
        self.pop(context);
        let statement_block_opt = pop_item!(self, statement_block_opt, StatementBlockOpt, context);
        let statement_block_built = StatementBlockBuilder::default()
            .statement_block_opt(statement_block_opt)
            // Ignore clipped member 'kw_end'
            .ident(Box::new(ident))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.statement_block(&statement_block_built)?;
        self.push(ASTType::StatementBlock(statement_block_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// StatementBlockOpt /* Option<T>::Some */: KwBegin^ /* Clipped */ StatementSeq;
    ///
    #[named]
    fn statement_block_opt_0(
        &mut self,
        _kw_begin: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq = pop_item!(self, statement_seq, StatementSeq, context);
        // Ignore clipped member 'kw_begin'
        self.pop(context);
        let statement_block_opt_0_built = StatementBlockOptBuilder::default()
            // Ignore clipped member 'kw_begin'
            .statement_seq(Box::new(statement_seq))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::StatementBlockOpt(Some(Box::new(statement_block_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// StatementBlockOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn statement_block_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementBlockOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// ForwardDecl: KwProcedure^ /* Clipped */ "\^" ForwardDeclOpt /* Option */ IdentDef ForwardDeclOpt0 /* Option */;
    ///
    #[named]
    fn forward_decl(
        &mut self,
        _kw_procedure: &ParseTreeStackEntry<'t>,
        circumflex: &ParseTreeStackEntry<'t>,
        _forward_decl_opt: &ParseTreeStackEntry<'t>,
        _ident_def: &ParseTreeStackEntry<'t>,
        _forward_decl_opt0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let circumflex = circumflex.token(parse_tree)?.clone();
        let forward_decl_opt0 = pop_item!(self, forward_decl_opt0, ForwardDeclOpt0, context);
        let ident_def = pop_item!(self, ident_def, IdentDef, context);
        let forward_decl_opt = pop_item!(self, forward_decl_opt, ForwardDeclOpt, context);
        // Ignore clipped member 'kw_procedure'
        self.pop(context);
        let forward_decl_built = ForwardDeclBuilder::default()
            // Ignore clipped member 'kw_procedure'
            .circumflex(circumflex)
            .forward_decl_opt(forward_decl_opt)
            .ident_def(Box::new(ident_def))
            .forward_decl_opt0(forward_decl_opt0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.forward_decl(&forward_decl_built)?;
        self.push(ASTType::ForwardDecl(forward_decl_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// ForwardDeclOpt0 /* Option<T>::Some */: FormalPars;
    ///
    #[named]
    fn forward_decl_opt0_0(
        &mut self,
        _formal_pars: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let formal_pars = pop_item!(self, formal_pars, FormalPars, context);
        let forward_decl_opt0_0_built = ForwardDeclOpt0Builder::default()
            .formal_pars(Box::new(formal_pars))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ForwardDeclOpt0(Some(Box::new(forward_decl_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// ForwardDeclOpt0 /* Option<T>::None */: ;
    ///
    #[named]
    fn forward_decl_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ForwardDeclOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// ForwardDeclOpt /* Option<T>::Some */: Receiver;
    ///
    #[named]
    fn forward_decl_opt_0(
        &mut self,
        _receiver: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let receiver = pop_item!(self, receiver, Receiver, context);
        let forward_decl_opt_0_built = ForwardDeclOptBuilder::default()
            .receiver(Box::new(receiver))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ForwardDeclOpt(Some(Box::new(forward_decl_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// ForwardDeclOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn forward_decl_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ForwardDeclOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// FormalPars: "\("^ /* Clipped */ FormalParsOpt /* Option */ "\)"^ /* Clipped */ FormalParsOpt0 /* Option */;
    ///
    #[named]
    fn formal_pars(
        &mut self,
        _l_paren: &ParseTreeStackEntry<'t>,
        _formal_pars_opt: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _formal_pars_opt0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let formal_pars_opt0 = pop_item!(self, formal_pars_opt0, FormalParsOpt0, context);
        let formal_pars_opt = pop_item!(self, formal_pars_opt, FormalParsOpt, context);
        let formal_pars_built = FormalParsBuilder::default()
            // Ignore clipped member 'l_paren'
            .formal_pars_opt(formal_pars_opt)
            // Ignore clipped member 'r_paren'
            .formal_pars_opt0(formal_pars_opt0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.formal_pars(&formal_pars_built)?;
        self.push(ASTType::FormalPars(formal_pars_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// FormalParsOpt0 /* Option<T>::Some */: ":"^ /* Clipped */ QualIdent;
    ///
    #[named]
    fn formal_pars_opt0_0(
        &mut self,
        _colon: &ParseTreeStackEntry<'t>,
        _qual_ident: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qual_ident = pop_item!(self, qual_ident, QualIdent, context);
        let formal_pars_opt0_0_built = FormalParsOpt0Builder::default()
            // Ignore clipped member 'colon'
            .qual_ident(Box::new(qual_ident))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FormalParsOpt0(Some(Box::new(formal_pars_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// FormalParsOpt0 /* Option<T>::None */: ;
    ///
    #[named]
    fn formal_pars_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FormalParsOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// FormalParsOpt /* Option<T>::Some */: FPSection FormalParsOptList /* Vec */;
    ///
    #[named]
    fn formal_pars_opt_0(
        &mut self,
        _f_p_section: &ParseTreeStackEntry<'t>,
        _formal_pars_opt_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let formal_pars_opt_list =
            pop_and_reverse_item!(self, formal_pars_opt_list, FormalParsOptList, context);
        let f_p_section = pop_item!(self, f_p_section, FPSection, context);
        let formal_pars_opt_0_built = FormalParsOptBuilder::default()
            .f_p_section(Box::new(f_p_section))
            .formal_pars_opt_list(formal_pars_opt_list)
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FormalParsOpt(Some(Box::new(formal_pars_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// FormalParsOptList /* Vec<T>::Push */: ";"^ /* Clipped */ FPSection FormalParsOptList;
    ///
    #[named]
    fn formal_pars_opt_list_0(
        &mut self,
        _semicolon: &ParseTreeStackEntry<'t>,
        _f_p_section: &ParseTreeStackEntry<'t>,
        _formal_pars_opt_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut formal_pars_opt_list =
            pop_item!(self, formal_pars_opt_list, FormalParsOptList, context);
        let f_p_section = pop_item!(self, f_p_section, FPSection, context);
        let formal_pars_opt_list_0_built = FormalParsOptListBuilder::default()
            .f_p_section(Box::new(f_p_section))
            // Ignore clipped member 'semicolon'
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        formal_pars_opt_list.push(formal_pars_opt_list_0_built);
        self.push(ASTType::FormalParsOptList(formal_pars_opt_list), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// FormalParsOptList /* Vec<T>::New */: ;
    ///
    #[named]
    fn formal_pars_opt_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let formal_pars_opt_list_1_built = Vec::new();
        self.push(
            ASTType::FormalParsOptList(formal_pars_opt_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// FormalParsOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn formal_pars_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FormalParsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// FPSection: FPSectionOpt /* Option */ Ident FPSectionList /* Vec */ ":"^ /* Clipped */ TypeDef;
    ///
    #[named]
    fn f_p_section(
        &mut self,
        _f_p_section_opt: &ParseTreeStackEntry<'t>,
        _ident: &ParseTreeStackEntry<'t>,
        _f_p_section_list: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type_def: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def = pop_item!(self, type_def, TypeDef, context);
        let f_p_section_list =
            pop_and_reverse_item!(self, f_p_section_list, FPSectionList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let f_p_section_opt = pop_item!(self, f_p_section_opt, FPSectionOpt, context);
        let f_p_section_built = FPSectionBuilder::default()
            .f_p_section_opt(f_p_section_opt)
            .ident(Box::new(ident))
            .f_p_section_list(f_p_section_list)
            // Ignore clipped member 'colon'
            .type_def(Box::new(type_def))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.f_p_section(&f_p_section_built)?;
        self.push(ASTType::FPSection(f_p_section_built), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// FPSectionList /* Vec<T>::Push */: ","^ /* Clipped */ Ident FPSectionList;
    ///
    #[named]
    fn f_p_section_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _ident: &ParseTreeStackEntry<'t>,
        _f_p_section_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut f_p_section_list = pop_item!(self, f_p_section_list, FPSectionList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let f_p_section_list_0_built = FPSectionListBuilder::default()
            .ident(Box::new(ident))
            // Ignore clipped member 'comma'
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        f_p_section_list.push(f_p_section_list_0_built);
        self.push(ASTType::FPSectionList(f_p_section_list), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// FPSectionList /* Vec<T>::New */: ;
    ///
    #[named]
    fn f_p_section_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f_p_section_list_1_built = Vec::new();
        self.push(ASTType::FPSectionList(f_p_section_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// FPSectionOpt /* Option<T>::Some */: KwVar^ /* Clipped */;
    ///
    #[named]
    fn f_p_section_opt_0(
        &mut self,
        _kw_var: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'kw_var'
        self.pop(context);
        let f_p_section_opt_0_built = FPSectionOptBuilder::default()
            // Ignore clipped member 'kw_var'
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FPSectionOpt(Some(Box::new(f_p_section_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// FPSectionOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn f_p_section_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FPSectionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// Receiver: "\("^ /* Clipped */ ReceiverOpt /* Option */ ReceiverVarDecl "\)"^ /* Clipped */;
    ///
    #[named]
    fn receiver(
        &mut self,
        _l_paren: &ParseTreeStackEntry<'t>,
        _receiver_opt: &ParseTreeStackEntry<'t>,
        _receiver_var_decl: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let receiver_var_decl = pop_item!(self, receiver_var_decl, ReceiverVarDecl, context);
        let receiver_opt = pop_item!(self, receiver_opt, ReceiverOpt, context);
        let receiver_built = ReceiverBuilder::default()
            // Ignore clipped member 'l_paren'
            .receiver_opt(receiver_opt)
            .receiver_var_decl(Box::new(receiver_var_decl))
            // Ignore clipped member 'r_paren'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.receiver(&receiver_built)?;
        self.push(ASTType::Receiver(receiver_built), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// ReceiverOpt /* Option<T>::Some */: KwVar^ /* Clipped */;
    ///
    #[named]
    fn receiver_opt_0(
        &mut self,
        _kw_var: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'kw_var'
        self.pop(context);
        let receiver_opt_0_built = ReceiverOptBuilder::default()
            // Ignore clipped member 'kw_var'
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ReceiverOpt(Some(Box::new(receiver_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// ReceiverOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn receiver_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ReceiverOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// ReceiverVarDecl: Ident ":"^ /* Clipped */ Ident;
    ///
    #[named]
    fn receiver_var_decl(
        &mut self,
        _ident: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _ident0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident0 = pop_item!(self, ident0, Ident, context);
        let ident = pop_item!(self, ident, Ident, context);
        let receiver_var_decl_built = ReceiverVarDeclBuilder::default()
            .ident(Box::new(ident))
            // Ignore clipped member 'colon'
            .ident0(Box::new(ident0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .receiver_var_decl(&receiver_var_decl_built)?;
        self.push(ASTType::ReceiverVarDecl(receiver_var_decl_built), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// TypeDef: QualIdent;
    ///
    #[named]
    fn type_def_0(
        &mut self,
        _qual_ident: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qual_ident = pop_item!(self, qual_ident, QualIdent, context);
        let type_def_0_built = TypeDef0Builder::default()
            .qual_ident(Box::new(qual_ident))
            .build()
            .into_diagnostic()?;
        let type_def_0_built = TypeDef::TypeDef0(type_def_0_built);
        // Calling user action here
        self.user_grammar.type_def(&type_def_0_built)?;
        self.push(ASTType::TypeDef(type_def_0_built), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// TypeDef: "ARRAY"^ /* Clipped */ TypeDefOpt /* Option */ KwOf^ /* Clipped */ TypeDef;
    ///
    #[named]
    fn type_def_1(
        &mut self,
        _a_r_r_a_y: &ParseTreeStackEntry<'t>,
        _type_def_opt: &ParseTreeStackEntry<'t>,
        _kw_of: &ParseTreeStackEntry<'t>,
        _type_def: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def = pop_item!(self, type_def, TypeDef, context);
        // Ignore clipped member 'kw_of'
        self.pop(context);
        let type_def_opt = pop_item!(self, type_def_opt, TypeDefOpt, context);
        let type_def_1_built = TypeDef1Builder::default()
            // Ignore clipped member 'a_r_r_a_y'
            .type_def_opt(type_def_opt)
            // Ignore clipped member 'kw_of'
            .type_def(Box::new(type_def))
            .build()
            .into_diagnostic()?;
        let type_def_1_built = TypeDef::TypeDef1(type_def_1_built);
        // Calling user action here
        self.user_grammar.type_def(&type_def_1_built)?;
        self.push(ASTType::TypeDef(type_def_1_built), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// TypeDef: "RECORD"^ /* Clipped */ TypeDefOpt0 /* Option */ FieldList TypeDefList /* Vec */ KwEnd^ /* Clipped */;
    ///
    #[named]
    fn type_def_2(
        &mut self,
        _r_e_c_o_r_d: &ParseTreeStackEntry<'t>,
        _type_def_opt0: &ParseTreeStackEntry<'t>,
        _field_list: &ParseTreeStackEntry<'t>,
        _type_def_list: &ParseTreeStackEntry<'t>,
        _kw_end: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'kw_end'
        self.pop(context);
        let type_def_list = pop_and_reverse_item!(self, type_def_list, TypeDefList, context);
        let field_list = pop_item!(self, field_list, FieldList, context);
        let type_def_opt0 = pop_item!(self, type_def_opt0, TypeDefOpt0, context);
        let type_def_2_built = TypeDef2Builder::default()
            // Ignore clipped member 'r_e_c_o_r_d'
            .type_def_opt0(type_def_opt0)
            .field_list(Box::new(field_list))
            .type_def_list(type_def_list)
            // Ignore clipped member 'kw_end'
            .build()
            .into_diagnostic()?;
        let type_def_2_built = TypeDef::TypeDef2(type_def_2_built);
        // Calling user action here
        self.user_grammar.type_def(&type_def_2_built)?;
        self.push(ASTType::TypeDef(type_def_2_built), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// TypeDefList /* Vec<T>::Push */: ";"^ /* Clipped */ FieldList TypeDefList;
    ///
    #[named]
    fn type_def_list_0(
        &mut self,
        _semicolon: &ParseTreeStackEntry<'t>,
        _field_list: &ParseTreeStackEntry<'t>,
        _type_def_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut type_def_list = pop_item!(self, type_def_list, TypeDefList, context);
        let field_list = pop_item!(self, field_list, FieldList, context);
        let type_def_list_0_built = TypeDefListBuilder::default()
            .field_list(Box::new(field_list))
            // Ignore clipped member 'semicolon'
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        type_def_list.push(type_def_list_0_built);
        self.push(ASTType::TypeDefList(type_def_list), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// TypeDefList /* Vec<T>::New */: ;
    ///
    #[named]
    fn type_def_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def_list_1_built = Vec::new();
        self.push(ASTType::TypeDefList(type_def_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// TypeDef: "POINTER"^ /* Clipped */ KwTo^ /* Clipped */ TypeDef;
    ///
    #[named]
    fn type_def_3(
        &mut self,
        _p_o_i_n_t_e_r: &ParseTreeStackEntry<'t>,
        _kw_to: &ParseTreeStackEntry<'t>,
        _type_def: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def = pop_item!(self, type_def, TypeDef, context);
        // Ignore clipped member 'kw_to'
        self.pop(context);
        let type_def_3_built = TypeDef3Builder::default()
            // Ignore clipped member 'p_o_i_n_t_e_r'
            // Ignore clipped member 'kw_to'
            .type_def(Box::new(type_def))
            .build()
            .into_diagnostic()?;
        let type_def_3_built = TypeDef::TypeDef3(type_def_3_built);
        // Calling user action here
        self.user_grammar.type_def(&type_def_3_built)?;
        self.push(ASTType::TypeDef(type_def_3_built), context);
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// TypeDef: KwProcedure^ /* Clipped */ TypeDefOpt1 /* Option */;
    ///
    #[named]
    fn type_def_4(
        &mut self,
        _kw_procedure: &ParseTreeStackEntry<'t>,
        _type_def_opt1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def_opt1 = pop_item!(self, type_def_opt1, TypeDefOpt1, context);
        // Ignore clipped member 'kw_procedure'
        self.pop(context);
        let type_def_4_built = TypeDef4Builder::default()
            // Ignore clipped member 'kw_procedure'
            .type_def_opt1(type_def_opt1)
            .build()
            .into_diagnostic()?;
        let type_def_4_built = TypeDef::TypeDef4(type_def_4_built);
        // Calling user action here
        self.user_grammar.type_def(&type_def_4_built)?;
        self.push(ASTType::TypeDef(type_def_4_built), context);
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// TypeDefOpt1 /* Option<T>::Some */: FormalPars;
    ///
    #[named]
    fn type_def_opt1_0(
        &mut self,
        _formal_pars: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let formal_pars = pop_item!(self, formal_pars, FormalPars, context);
        let type_def_opt1_0_built = TypeDefOpt1Builder::default()
            .formal_pars(Box::new(formal_pars))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::TypeDefOpt1(Some(Box::new(type_def_opt1_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// TypeDefOpt1 /* Option<T>::None */: ;
    ///
    #[named]
    fn type_def_opt1_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypeDefOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// TypeDefOpt0 /* Option<T>::Some */: "\("^ /* Clipped */ QualIdent "\)"^ /* Clipped */;
    ///
    #[named]
    fn type_def_opt0_0(
        &mut self,
        _l_paren: &ParseTreeStackEntry<'t>,
        _qual_ident: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qual_ident = pop_item!(self, qual_ident, QualIdent, context);
        let type_def_opt0_0_built = TypeDefOpt0Builder::default()
            // Ignore clipped member 'l_paren'
            .qual_ident(Box::new(qual_ident))
            // Ignore clipped member 'r_paren'
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::TypeDefOpt0(Some(Box::new(type_def_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// TypeDefOpt0 /* Option<T>::None */: ;
    ///
    #[named]
    fn type_def_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypeDefOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// TypeDefOpt /* Option<T>::Some */: ConstExpr TypeDefOptList /* Vec */;
    ///
    #[named]
    fn type_def_opt_0(
        &mut self,
        _const_expr: &ParseTreeStackEntry<'t>,
        _type_def_opt_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def_opt_list =
            pop_and_reverse_item!(self, type_def_opt_list, TypeDefOptList, context);
        let const_expr = pop_item!(self, const_expr, ConstExpr, context);
        let type_def_opt_0_built = TypeDefOptBuilder::default()
            .const_expr(Box::new(const_expr))
            .type_def_opt_list(type_def_opt_list)
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::TypeDefOpt(Some(Box::new(type_def_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// TypeDefOptList /* Vec<T>::Push */: ","^ /* Clipped */ ConstExpr TypeDefOptList;
    ///
    #[named]
    fn type_def_opt_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _const_expr: &ParseTreeStackEntry<'t>,
        _type_def_opt_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut type_def_opt_list = pop_item!(self, type_def_opt_list, TypeDefOptList, context);
        let const_expr = pop_item!(self, const_expr, ConstExpr, context);
        let type_def_opt_list_0_built = TypeDefOptListBuilder::default()
            .const_expr(Box::new(const_expr))
            // Ignore clipped member 'comma'
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        type_def_opt_list.push(type_def_opt_list_0_built);
        self.push(ASTType::TypeDefOptList(type_def_opt_list), context);
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// TypeDefOptList /* Vec<T>::New */: ;
    ///
    #[named]
    fn type_def_opt_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def_opt_list_1_built = Vec::new();
        self.push(ASTType::TypeDefOptList(type_def_opt_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// TypeDefOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn type_def_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypeDefOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// FieldList: FieldListOpt /* Option */;
    ///
    #[named]
    fn field_list(
        &mut self,
        _field_list_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let field_list_opt = pop_item!(self, field_list_opt, FieldListOpt, context);
        let field_list_built = FieldListBuilder::default()
            .field_list_opt(field_list_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.field_list(&field_list_built)?;
        self.push(ASTType::FieldList(field_list_built), context);
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// FieldListOpt /* Option<T>::Some */: IdentList ":"^ /* Clipped */ TypeDef;
    ///
    #[named]
    fn field_list_opt_0(
        &mut self,
        _ident_list: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type_def: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def = pop_item!(self, type_def, TypeDef, context);
        let ident_list = pop_item!(self, ident_list, IdentList, context);
        let field_list_opt_0_built = FieldListOptBuilder::default()
            .ident_list(Box::new(ident_list))
            // Ignore clipped member 'colon'
            .type_def(Box::new(type_def))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FieldListOpt(Some(Box::new(field_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// FieldListOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn field_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FieldListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// StatementSeq: Statement StatementSeqList /* Vec */;
    ///
    #[named]
    fn statement_seq(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _statement_seq_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq_list =
            pop_and_reverse_item!(self, statement_seq_list, StatementSeqList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let statement_seq_built = StatementSeqBuilder::default()
            .statement(Box::new(statement))
            .statement_seq_list(statement_seq_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.statement_seq(&statement_seq_built)?;
        self.push(ASTType::StatementSeq(statement_seq_built), context);
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// StatementSeqList /* Vec<T>::Push */: ";"^ /* Clipped */ Statement StatementSeqList;
    ///
    #[named]
    fn statement_seq_list_0(
        &mut self,
        _semicolon: &ParseTreeStackEntry<'t>,
        _statement: &ParseTreeStackEntry<'t>,
        _statement_seq_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut statement_seq_list = pop_item!(self, statement_seq_list, StatementSeqList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let statement_seq_list_0_built = StatementSeqListBuilder::default()
            .statement(Box::new(statement))
            // Ignore clipped member 'semicolon'
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        statement_seq_list.push(statement_seq_list_0_built);
        self.push(ASTType::StatementSeqList(statement_seq_list), context);
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// StatementSeqList /* Vec<T>::New */: ;
    ///
    #[named]
    fn statement_seq_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq_list_1_built = Vec::new();
        self.push(
            ASTType::StatementSeqList(statement_seq_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// Statement: StatementOpt /* Option */;
    ///
    #[named]
    fn statement(
        &mut self,
        _statement_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt = pop_item!(self, statement_opt, StatementOpt, context);
        let statement_built = StatementBuilder::default()
            .statement_opt(statement_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.statement(&statement_built)?;
        self.push(ASTType::Statement(statement_built), context);
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// StatementOpt /* Option<T>::Some */: StatementOptGroup;
    ///
    #[named]
    fn statement_opt_0(
        &mut self,
        _statement_opt_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt_group = pop_item!(self, statement_opt_group, StatementOptGroup, context);
        let statement_opt_0_built = StatementOptBuilder::default()
            .statement_opt_group(Box::new(statement_opt_group))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::StatementOpt(Some(Box::new(statement_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// StatementOptGroup: Designator StatementOptGroupSuffix;
    ///
    #[named]
    fn statement_opt_group_0(
        &mut self,
        _designator: &ParseTreeStackEntry<'t>,
        _statement_opt_group_suffix: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt_group_suffix = pop_item!(
            self,
            statement_opt_group_suffix,
            StatementOptGroupSuffix,
            context
        );
        let designator = pop_item!(self, designator, Designator, context);
        let statement_opt_group_0_built = StatementOptGroup0Builder::default()
            .designator(Box::new(designator))
            .statement_opt_group_suffix(Box::new(statement_opt_group_suffix))
            .build()
            .into_diagnostic()?;
        let statement_opt_group_0_built =
            StatementOptGroup::StatementOptGroup0(statement_opt_group_0_built);
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// StatementOptGroupSuffix: ":="^ /* Clipped */ Expr;
    ///
    #[named]
    fn statement_opt_group_suffix_0(
        &mut self,
        _colon_equ: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr = pop_item!(self, expr, Expr, context);
        let statement_opt_group_suffix_0_built = StatementOptGroupSuffix0Builder::default()
            // Ignore clipped member 'colon_equ'
            .expr(Box::new(expr))
            .build()
            .into_diagnostic()?;
        let statement_opt_group_suffix_0_built =
            StatementOptGroupSuffix::StatementOptGroupSuffix0(statement_opt_group_suffix_0_built);
        self.push(
            ASTType::StatementOptGroupSuffix(statement_opt_group_suffix_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// StatementOptGroupSuffix: StatementOpt0 /* Option */;
    ///
    #[named]
    fn statement_opt_group_suffix_1(
        &mut self,
        _statement_opt0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt0 = pop_item!(self, statement_opt0, StatementOpt0, context);
        let statement_opt_group_suffix_1_built = StatementOptGroupSuffix1Builder::default()
            .statement_opt0(statement_opt0)
            .build()
            .into_diagnostic()?;
        let statement_opt_group_suffix_1_built =
            StatementOptGroupSuffix::StatementOptGroupSuffix1(statement_opt_group_suffix_1_built);
        self.push(
            ASTType::StatementOptGroupSuffix(statement_opt_group_suffix_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// StatementOptGroup: KwIf^ /* Clipped */ Expr ThenBlock StatementOptGroupList /* Vec */ OptElsePartEnd;
    ///
    #[named]
    fn statement_opt_group_1(
        &mut self,
        _kw_if: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        _then_block: &ParseTreeStackEntry<'t>,
        _statement_opt_group_list: &ParseTreeStackEntry<'t>,
        _opt_else_part_end: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let opt_else_part_end = pop_item!(self, opt_else_part_end, OptElsePartEnd, context);
        let statement_opt_group_list = pop_and_reverse_item!(
            self,
            statement_opt_group_list,
            StatementOptGroupList,
            context
        );
        let then_block = pop_item!(self, then_block, ThenBlock, context);
        let expr = pop_item!(self, expr, Expr, context);
        // Ignore clipped member 'kw_if'
        self.pop(context);
        let statement_opt_group_1_built = StatementOptGroup1Builder::default()
            // Ignore clipped member 'kw_if'
            .expr(Box::new(expr))
            .then_block(Box::new(then_block))
            .statement_opt_group_list(statement_opt_group_list)
            .opt_else_part_end(Box::new(opt_else_part_end))
            .build()
            .into_diagnostic()?;
        let statement_opt_group_1_built =
            StatementOptGroup::StatementOptGroup1(statement_opt_group_1_built);
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// StatementOptGroup: KwCase^ /* Clipped */ Expr KwOf^ /* Clipped */ Cases OptElsePartEnd;
    ///
    #[named]
    fn statement_opt_group_2(
        &mut self,
        _kw_case: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        _kw_of: &ParseTreeStackEntry<'t>,
        _cases: &ParseTreeStackEntry<'t>,
        _opt_else_part_end: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let opt_else_part_end = pop_item!(self, opt_else_part_end, OptElsePartEnd, context);
        let cases = pop_item!(self, cases, Cases, context);
        // Ignore clipped member 'kw_of'
        self.pop(context);
        let expr = pop_item!(self, expr, Expr, context);
        // Ignore clipped member 'kw_case'
        self.pop(context);
        let statement_opt_group_2_built = StatementOptGroup2Builder::default()
            // Ignore clipped member 'kw_case'
            .expr(Box::new(expr))
            // Ignore clipped member 'kw_of'
            .cases(Box::new(cases))
            .opt_else_part_end(Box::new(opt_else_part_end))
            .build()
            .into_diagnostic()?;
        let statement_opt_group_2_built =
            StatementOptGroup::StatementOptGroup2(statement_opt_group_2_built);
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// StatementOptGroup: "WHILE"^ /* Clipped */ Expr DoBlock;
    ///
    #[named]
    fn statement_opt_group_3(
        &mut self,
        _w_h_i_l_e: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        _do_block: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let do_block = pop_item!(self, do_block, DoBlock, context);
        let expr = pop_item!(self, expr, Expr, context);
        let statement_opt_group_3_built = StatementOptGroup3Builder::default()
            // Ignore clipped member 'w_h_i_l_e'
            .expr(Box::new(expr))
            .do_block(Box::new(do_block))
            .build()
            .into_diagnostic()?;
        let statement_opt_group_3_built =
            StatementOptGroup::StatementOptGroup3(statement_opt_group_3_built);
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// StatementOptGroup: "REPEAT"^ /* Clipped */ StatementSeq "UNTIL"^ /* Clipped */ Expr;
    ///
    #[named]
    fn statement_opt_group_4(
        &mut self,
        _r_e_p_e_a_t: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _u_n_t_i_l: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr = pop_item!(self, expr, Expr, context);
        let statement_seq = pop_item!(self, statement_seq, StatementSeq, context);
        let statement_opt_group_4_built = StatementOptGroup4Builder::default()
            // Ignore clipped member 'r_e_p_e_a_t'
            .statement_seq(Box::new(statement_seq))
            // Ignore clipped member 'u_n_t_i_l'
            .expr(Box::new(expr))
            .build()
            .into_diagnostic()?;
        let statement_opt_group_4_built =
            StatementOptGroup::StatementOptGroup4(statement_opt_group_4_built);
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_4_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// StatementOptGroup: "FOR"^ /* Clipped */ ForInit StatementOpt1 /* Option */ DoBlock;
    ///
    #[named]
    fn statement_opt_group_5(
        &mut self,
        _f_o_r: &ParseTreeStackEntry<'t>,
        _for_init: &ParseTreeStackEntry<'t>,
        _statement_opt1: &ParseTreeStackEntry<'t>,
        _do_block: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let do_block = pop_item!(self, do_block, DoBlock, context);
        let statement_opt1 = pop_item!(self, statement_opt1, StatementOpt1, context);
        let for_init = pop_item!(self, for_init, ForInit, context);
        let statement_opt_group_5_built = StatementOptGroup5Builder::default()
            // Ignore clipped member 'f_o_r'
            .for_init(Box::new(for_init))
            .statement_opt1(statement_opt1)
            .do_block(Box::new(do_block))
            .build()
            .into_diagnostic()?;
        let statement_opt_group_5_built =
            StatementOptGroup::StatementOptGroup5(statement_opt_group_5_built);
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_5_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// StatementOptGroup: "LOOP"^ /* Clipped */ StatementSeq KwEnd^ /* Clipped */;
    ///
    #[named]
    fn statement_opt_group_6(
        &mut self,
        _l_o_o_p: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _kw_end: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'kw_end'
        self.pop(context);
        let statement_seq = pop_item!(self, statement_seq, StatementSeq, context);
        let statement_opt_group_6_built = StatementOptGroup6Builder::default()
            // Ignore clipped member 'l_o_o_p'
            .statement_seq(Box::new(statement_seq))
            // Ignore clipped member 'kw_end'
            .build()
            .into_diagnostic()?;
        let statement_opt_group_6_built =
            StatementOptGroup::StatementOptGroup6(statement_opt_group_6_built);
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_6_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// StatementOptGroup: "WITH"^ /* Clipped */ GuardedDoBlock StatementOptGroupList0 /* Vec */ OptElsePartEnd;
    ///
    #[named]
    fn statement_opt_group_7(
        &mut self,
        _w_i_t_h: &ParseTreeStackEntry<'t>,
        _guarded_do_block: &ParseTreeStackEntry<'t>,
        _statement_opt_group_list0: &ParseTreeStackEntry<'t>,
        _opt_else_part_end: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let opt_else_part_end = pop_item!(self, opt_else_part_end, OptElsePartEnd, context);
        let statement_opt_group_list0 = pop_and_reverse_item!(
            self,
            statement_opt_group_list0,
            StatementOptGroupList0,
            context
        );
        let guarded_do_block = pop_item!(self, guarded_do_block, GuardedDoBlock, context);
        let statement_opt_group_7_built = StatementOptGroup7Builder::default()
            // Ignore clipped member 'w_i_t_h'
            .guarded_do_block(Box::new(guarded_do_block))
            .statement_opt_group_list0(statement_opt_group_list0)
            .opt_else_part_end(Box::new(opt_else_part_end))
            .build()
            .into_diagnostic()?;
        let statement_opt_group_7_built =
            StatementOptGroup::StatementOptGroup7(statement_opt_group_7_built);
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_7_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// StatementOptGroup: "EXIT"^ /* Clipped */;
    ///
    #[named]
    fn statement_opt_group_8(
        &mut self,
        _e_x_i_t: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt_group_8_built = StatementOptGroup8Builder::default()
            // Ignore clipped member 'e_x_i_t'
            .build()
            .into_diagnostic()?;
        let statement_opt_group_8_built =
            StatementOptGroup::StatementOptGroup8(statement_opt_group_8_built);
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_8_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// StatementOptGroup: "RETURN"^ /* Clipped */ StatementOpt2 /* Option */;
    ///
    #[named]
    fn statement_opt_group_9(
        &mut self,
        _r_e_t_u_r_n: &ParseTreeStackEntry<'t>,
        _statement_opt2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt2 = pop_item!(self, statement_opt2, StatementOpt2, context);
        let statement_opt_group_9_built = StatementOptGroup9Builder::default()
            // Ignore clipped member 'r_e_t_u_r_n'
            .statement_opt2(statement_opt2)
            .build()
            .into_diagnostic()?;
        let statement_opt_group_9_built =
            StatementOptGroup::StatementOptGroup9(statement_opt_group_9_built);
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_9_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 112:
    ///
    /// StatementOptGroupList /* Vec<T>::Push */: ElsifPart StatementOptGroupList;
    ///
    #[named]
    fn statement_opt_group_list_0(
        &mut self,
        _elsif_part: &ParseTreeStackEntry<'t>,
        _statement_opt_group_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut statement_opt_group_list = pop_item!(
            self,
            statement_opt_group_list,
            StatementOptGroupList,
            context
        );
        let elsif_part = pop_item!(self, elsif_part, ElsifPart, context);
        let statement_opt_group_list_0_built = StatementOptGroupListBuilder::default()
            .elsif_part(Box::new(elsif_part))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        statement_opt_group_list.push(statement_opt_group_list_0_built);
        self.push(
            ASTType::StatementOptGroupList(statement_opt_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 113:
    ///
    /// StatementOptGroupList /* Vec<T>::New */: ;
    ///
    #[named]
    fn statement_opt_group_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt_group_list_1_built = Vec::new();
        self.push(
            ASTType::StatementOptGroupList(statement_opt_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 114:
    ///
    /// StatementOptGroupList0 /* Vec<T>::Push */: "\|"^ /* Clipped */ GuardedDoBlock StatementOptGroupList0;
    ///
    #[named]
    fn statement_opt_group_list0_0(
        &mut self,
        _or: &ParseTreeStackEntry<'t>,
        _guarded_do_block: &ParseTreeStackEntry<'t>,
        _statement_opt_group_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut statement_opt_group_list0 = pop_item!(
            self,
            statement_opt_group_list0,
            StatementOptGroupList0,
            context
        );
        let guarded_do_block = pop_item!(self, guarded_do_block, GuardedDoBlock, context);
        let statement_opt_group_list0_0_built = StatementOptGroupList0Builder::default()
            .guarded_do_block(Box::new(guarded_do_block))
            // Ignore clipped member 'or'
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        statement_opt_group_list0.push(statement_opt_group_list0_0_built);
        self.push(
            ASTType::StatementOptGroupList0(statement_opt_group_list0),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 115:
    ///
    /// StatementOptGroupList0 /* Vec<T>::New */: ;
    ///
    #[named]
    fn statement_opt_group_list0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt_group_list0_1_built = Vec::new();
        self.push(
            ASTType::StatementOptGroupList0(statement_opt_group_list0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 116:
    ///
    /// StatementOpt2 /* Option<T>::Some */: Expr;
    ///
    #[named]
    fn statement_opt2_0(
        &mut self,
        _expr: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr = pop_item!(self, expr, Expr, context);
        let statement_opt2_0_built = StatementOpt2Builder::default()
            .expr(Box::new(expr))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::StatementOpt2(Some(Box::new(statement_opt2_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 117:
    ///
    /// StatementOpt2 /* Option<T>::None */: ;
    ///
    #[named]
    fn statement_opt2_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementOpt2(None), context);
        Ok(())
    }

    /// Semantic action for production 118:
    ///
    /// StatementOpt1 /* Option<T>::Some */: ForStep;
    ///
    #[named]
    fn statement_opt1_0(
        &mut self,
        _for_step: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_step = pop_item!(self, for_step, ForStep, context);
        let statement_opt1_0_built = StatementOpt1Builder::default()
            .for_step(Box::new(for_step))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::StatementOpt1(Some(Box::new(statement_opt1_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 119:
    ///
    /// StatementOpt1 /* Option<T>::None */: ;
    ///
    #[named]
    fn statement_opt1_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 120:
    ///
    /// StatementOpt0 /* Option<T>::Some */: "\("^ /* Clipped */ StatementOpt3 /* Option */ "\)"^ /* Clipped */;
    ///
    #[named]
    fn statement_opt0_0(
        &mut self,
        _l_paren: &ParseTreeStackEntry<'t>,
        _statement_opt3: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt3 = pop_item!(self, statement_opt3, StatementOpt3, context);
        let statement_opt0_0_built = StatementOpt0Builder::default()
            // Ignore clipped member 'l_paren'
            .statement_opt3(statement_opt3)
            // Ignore clipped member 'r_paren'
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::StatementOpt0(Some(Box::new(statement_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 121:
    ///
    /// StatementOpt3 /* Option<T>::Some */: ExprList;
    ///
    #[named]
    fn statement_opt3_0(
        &mut self,
        _expr_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr_list = pop_item!(self, expr_list, ExprList, context);
        let statement_opt3_0_built = StatementOpt3Builder::default()
            .expr_list(Box::new(expr_list))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::StatementOpt3(Some(Box::new(statement_opt3_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 122:
    ///
    /// StatementOpt3 /* Option<T>::None */: ;
    ///
    #[named]
    fn statement_opt3_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementOpt3(None), context);
        Ok(())
    }

    /// Semantic action for production 123:
    ///
    /// StatementOpt0 /* Option<T>::None */: ;
    ///
    #[named]
    fn statement_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 124:
    ///
    /// StatementOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn statement_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 125:
    ///
    /// ThenBlock: KwThen^ /* Clipped */ StatementSeq;
    ///
    #[named]
    fn then_block(
        &mut self,
        _kw_then: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq = pop_item!(self, statement_seq, StatementSeq, context);
        // Ignore clipped member 'kw_then'
        self.pop(context);
        let then_block_built = ThenBlockBuilder::default()
            // Ignore clipped member 'kw_then'
            .statement_seq(Box::new(statement_seq))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.then_block(&then_block_built)?;
        self.push(ASTType::ThenBlock(then_block_built), context);
        Ok(())
    }

    /// Semantic action for production 126:
    ///
    /// Cases: Case CasesList /* Vec */;
    ///
    #[named]
    fn cases(
        &mut self,
        _case: &ParseTreeStackEntry<'t>,
        _cases_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let cases_list = pop_and_reverse_item!(self, cases_list, CasesList, context);
        let case = pop_item!(self, case, Case, context);
        let cases_built = CasesBuilder::default()
            .case(Box::new(case))
            .cases_list(cases_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.cases(&cases_built)?;
        self.push(ASTType::Cases(cases_built), context);
        Ok(())
    }

    /// Semantic action for production 127:
    ///
    /// CasesList /* Vec<T>::Push */: "\|"^ /* Clipped */ Case CasesList;
    ///
    #[named]
    fn cases_list_0(
        &mut self,
        _or: &ParseTreeStackEntry<'t>,
        _case: &ParseTreeStackEntry<'t>,
        _cases_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut cases_list = pop_item!(self, cases_list, CasesList, context);
        let case = pop_item!(self, case, Case, context);
        let cases_list_0_built = CasesListBuilder::default()
            .case(Box::new(case))
            // Ignore clipped member 'or'
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        cases_list.push(cases_list_0_built);
        self.push(ASTType::CasesList(cases_list), context);
        Ok(())
    }

    /// Semantic action for production 128:
    ///
    /// CasesList /* Vec<T>::New */: ;
    ///
    #[named]
    fn cases_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let cases_list_1_built = Vec::new();
        self.push(ASTType::CasesList(cases_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 129:
    ///
    /// ElsifPart: KwElsif^ /* Clipped */ Expr ThenBlock;
    ///
    #[named]
    fn elsif_part(
        &mut self,
        _kw_elsif: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        _then_block: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let then_block = pop_item!(self, then_block, ThenBlock, context);
        let expr = pop_item!(self, expr, Expr, context);
        // Ignore clipped member 'kw_elsif'
        self.pop(context);
        let elsif_part_built = ElsifPartBuilder::default()
            // Ignore clipped member 'kw_elsif'
            .expr(Box::new(expr))
            .then_block(Box::new(then_block))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.elsif_part(&elsif_part_built)?;
        self.push(ASTType::ElsifPart(elsif_part_built), context);
        Ok(())
    }

    /// Semantic action for production 130:
    ///
    /// ElsePart: KwElse^ /* Clipped */ StatementSeq;
    ///
    #[named]
    fn else_part(
        &mut self,
        _kw_else: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq = pop_item!(self, statement_seq, StatementSeq, context);
        // Ignore clipped member 'kw_else'
        self.pop(context);
        let else_part_built = ElsePartBuilder::default()
            // Ignore clipped member 'kw_else'
            .statement_seq(Box::new(statement_seq))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.else_part(&else_part_built)?;
        self.push(ASTType::ElsePart(else_part_built), context);
        Ok(())
    }

    /// Semantic action for production 131:
    ///
    /// OptElsePartEnd: OptElsePartEndOpt /* Option */ KwEnd^ /* Clipped */;
    ///
    #[named]
    fn opt_else_part_end(
        &mut self,
        _opt_else_part_end_opt: &ParseTreeStackEntry<'t>,
        _kw_end: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'kw_end'
        self.pop(context);
        let opt_else_part_end_opt =
            pop_item!(self, opt_else_part_end_opt, OptElsePartEndOpt, context);
        let opt_else_part_end_built = OptElsePartEndBuilder::default()
            .opt_else_part_end_opt(opt_else_part_end_opt)
            // Ignore clipped member 'kw_end'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .opt_else_part_end(&opt_else_part_end_built)?;
        self.push(ASTType::OptElsePartEnd(opt_else_part_end_built), context);
        Ok(())
    }

    /// Semantic action for production 132:
    ///
    /// OptElsePartEndOpt /* Option<T>::Some */: ElsePart;
    ///
    #[named]
    fn opt_else_part_end_opt_0(
        &mut self,
        _else_part: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let else_part = pop_item!(self, else_part, ElsePart, context);
        let opt_else_part_end_opt_0_built = OptElsePartEndOptBuilder::default()
            .else_part(Box::new(else_part))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::OptElsePartEndOpt(Some(Box::new(opt_else_part_end_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 133:
    ///
    /// OptElsePartEndOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn opt_else_part_end_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::OptElsePartEndOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 134:
    ///
    /// DoBlock: KwDo^ /* Clipped */ StatementSeq KwEnd^ /* Clipped */;
    ///
    #[named]
    fn do_block(
        &mut self,
        _kw_do: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _kw_end: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'kw_end'
        self.pop(context);
        let statement_seq = pop_item!(self, statement_seq, StatementSeq, context);
        // Ignore clipped member 'kw_do'
        self.pop(context);
        let do_block_built = DoBlockBuilder::default()
            // Ignore clipped member 'kw_do'
            .statement_seq(Box::new(statement_seq))
            // Ignore clipped member 'kw_end'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.do_block(&do_block_built)?;
        self.push(ASTType::DoBlock(do_block_built), context);
        Ok(())
    }

    /// Semantic action for production 135:
    ///
    /// GuardedDoBlock: Guard KwDo^ /* Clipped */ StatementSeq;
    ///
    #[named]
    fn guarded_do_block(
        &mut self,
        _guard: &ParseTreeStackEntry<'t>,
        _kw_do: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq = pop_item!(self, statement_seq, StatementSeq, context);
        // Ignore clipped member 'kw_do'
        self.pop(context);
        let guard = pop_item!(self, guard, Guard, context);
        let guarded_do_block_built = GuardedDoBlockBuilder::default()
            .guard(Box::new(guard))
            // Ignore clipped member 'kw_do'
            .statement_seq(Box::new(statement_seq))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .guarded_do_block(&guarded_do_block_built)?;
        self.push(ASTType::GuardedDoBlock(guarded_do_block_built), context);
        Ok(())
    }

    /// Semantic action for production 136:
    ///
    /// ForInit: Ident ":="^ /* Clipped */ Expr KwTo^ /* Clipped */ Expr;
    ///
    #[named]
    fn for_init(
        &mut self,
        _ident: &ParseTreeStackEntry<'t>,
        _colon_equ: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        _kw_to: &ParseTreeStackEntry<'t>,
        _expr0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr0 = pop_item!(self, expr0, Expr, context);
        // Ignore clipped member 'kw_to'
        self.pop(context);
        let expr = pop_item!(self, expr, Expr, context);
        let ident = pop_item!(self, ident, Ident, context);
        let for_init_built = ForInitBuilder::default()
            .ident(Box::new(ident))
            // Ignore clipped member 'colon_equ'
            .expr(Box::new(expr))
            // Ignore clipped member 'kw_to'
            .expr0(Box::new(expr0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.for_init(&for_init_built)?;
        self.push(ASTType::ForInit(for_init_built), context);
        Ok(())
    }

    /// Semantic action for production 137:
    ///
    /// ForStep: "BY"^ /* Clipped */ ConstExpr;
    ///
    #[named]
    fn for_step(
        &mut self,
        _b_y: &ParseTreeStackEntry<'t>,
        _const_expr: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_expr = pop_item!(self, const_expr, ConstExpr, context);
        let for_step_built = ForStepBuilder::default()
            // Ignore clipped member 'b_y'
            .const_expr(Box::new(const_expr))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.for_step(&for_step_built)?;
        self.push(ASTType::ForStep(for_step_built), context);
        Ok(())
    }

    /// Semantic action for production 138:
    ///
    /// Case: CaseOpt /* Option */;
    ///
    #[named]
    fn case(
        &mut self,
        _case_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_opt = pop_item!(self, case_opt, CaseOpt, context);
        let case_built = CaseBuilder::default()
            .case_opt(case_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.case(&case_built)?;
        self.push(ASTType::Case(case_built), context);
        Ok(())
    }

    /// Semantic action for production 139:
    ///
    /// CaseOpt /* Option<T>::Some */: CaseLabels CaseOptList /* Vec */ ":"^ /* Clipped */ StatementSeq;
    ///
    #[named]
    fn case_opt_0(
        &mut self,
        _case_labels: &ParseTreeStackEntry<'t>,
        _case_opt_list: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq = pop_item!(self, statement_seq, StatementSeq, context);
        let case_opt_list = pop_and_reverse_item!(self, case_opt_list, CaseOptList, context);
        let case_labels = pop_item!(self, case_labels, CaseLabels, context);
        let case_opt_0_built = CaseOptBuilder::default()
            .case_labels(Box::new(case_labels))
            .case_opt_list(case_opt_list)
            // Ignore clipped member 'colon'
            .statement_seq(Box::new(statement_seq))
            .build()
            .into_diagnostic()?;
        self.push(ASTType::CaseOpt(Some(Box::new(case_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 140:
    ///
    /// CaseOptList /* Vec<T>::Push */: ","^ /* Clipped */ CaseLabels CaseOptList;
    ///
    #[named]
    fn case_opt_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _case_labels: &ParseTreeStackEntry<'t>,
        _case_opt_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut case_opt_list = pop_item!(self, case_opt_list, CaseOptList, context);
        let case_labels = pop_item!(self, case_labels, CaseLabels, context);
        let case_opt_list_0_built = CaseOptListBuilder::default()
            .case_labels(Box::new(case_labels))
            // Ignore clipped member 'comma'
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        case_opt_list.push(case_opt_list_0_built);
        self.push(ASTType::CaseOptList(case_opt_list), context);
        Ok(())
    }

    /// Semantic action for production 141:
    ///
    /// CaseOptList /* Vec<T>::New */: ;
    ///
    #[named]
    fn case_opt_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_opt_list_1_built = Vec::new();
        self.push(ASTType::CaseOptList(case_opt_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 142:
    ///
    /// CaseOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn case_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CaseOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 143:
    ///
    /// CaseLabels: ConstExpr CaseLabelsOpt /* Option */;
    ///
    #[named]
    fn case_labels(
        &mut self,
        _const_expr: &ParseTreeStackEntry<'t>,
        _case_labels_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_labels_opt = pop_item!(self, case_labels_opt, CaseLabelsOpt, context);
        let const_expr = pop_item!(self, const_expr, ConstExpr, context);
        let case_labels_built = CaseLabelsBuilder::default()
            .const_expr(Box::new(const_expr))
            .case_labels_opt(case_labels_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.case_labels(&case_labels_built)?;
        self.push(ASTType::CaseLabels(case_labels_built), context);
        Ok(())
    }

    /// Semantic action for production 144:
    ///
    /// CaseLabelsOpt /* Option<T>::Some */: "\.\." ConstExpr;
    ///
    #[named]
    fn case_labels_opt_0(
        &mut self,
        dot_dot: &ParseTreeStackEntry<'t>,
        _const_expr: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_dot = dot_dot.token(parse_tree)?.clone();
        let const_expr = pop_item!(self, const_expr, ConstExpr, context);
        let case_labels_opt_0_built = CaseLabelsOptBuilder::default()
            .dot_dot(dot_dot)
            .const_expr(Box::new(const_expr))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::CaseLabelsOpt(Some(Box::new(case_labels_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 145:
    ///
    /// CaseLabelsOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn case_labels_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CaseLabelsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 146:
    ///
    /// Guard: QualIdent ":"^ /* Clipped */ QualIdent;
    ///
    #[named]
    fn guard(
        &mut self,
        _qual_ident: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _qual_ident0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qual_ident0 = pop_item!(self, qual_ident0, QualIdent, context);
        let qual_ident = pop_item!(self, qual_ident, QualIdent, context);
        let guard_built = GuardBuilder::default()
            .qual_ident(Box::new(qual_ident))
            // Ignore clipped member 'colon'
            .qual_ident0(Box::new(qual_ident0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.guard(&guard_built)?;
        self.push(ASTType::Guard(guard_built), context);
        Ok(())
    }

    /// Semantic action for production 147:
    ///
    /// ConstExpr: Expr;
    ///
    #[named]
    fn const_expr(
        &mut self,
        _expr: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr = pop_item!(self, expr, Expr, context);
        let const_expr_built = ConstExprBuilder::default()
            .expr(Box::new(expr))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.const_expr(&const_expr_built)?;
        self.push(ASTType::ConstExpr(const_expr_built), context);
        Ok(())
    }

    /// Semantic action for production 148:
    ///
    /// Expr: SimpleExpr ExprOpt /* Option */;
    ///
    #[named]
    fn expr(
        &mut self,
        _simple_expr: &ParseTreeStackEntry<'t>,
        _expr_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr_opt = pop_item!(self, expr_opt, ExprOpt, context);
        let simple_expr = pop_item!(self, simple_expr, SimpleExpr, context);
        let expr_built = ExprBuilder::default()
            .simple_expr(Box::new(simple_expr))
            .expr_opt(expr_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expr(&expr_built)?;
        self.push(ASTType::Expr(expr_built), context);
        Ok(())
    }

    /// Semantic action for production 149:
    ///
    /// ExprOpt /* Option<T>::Some */: Relation SimpleExpr;
    ///
    #[named]
    fn expr_opt_0(
        &mut self,
        _relation: &ParseTreeStackEntry<'t>,
        _simple_expr: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_expr = pop_item!(self, simple_expr, SimpleExpr, context);
        let relation = pop_item!(self, relation, Relation, context);
        let expr_opt_0_built = ExprOptBuilder::default()
            .relation(Box::new(relation))
            .simple_expr(Box::new(simple_expr))
            .build()
            .into_diagnostic()?;
        self.push(ASTType::ExprOpt(Some(Box::new(expr_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 150:
    ///
    /// ExprOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn expr_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ExprOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 151:
    ///
    /// SimpleExpr: SimpleExprOpt /* Option */ Term SimpleExprList /* Vec */;
    ///
    #[named]
    fn simple_expr(
        &mut self,
        _simple_expr_opt: &ParseTreeStackEntry<'t>,
        _term: &ParseTreeStackEntry<'t>,
        _simple_expr_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_expr_list =
            pop_and_reverse_item!(self, simple_expr_list, SimpleExprList, context);
        let term = pop_item!(self, term, Term, context);
        let simple_expr_opt = pop_item!(self, simple_expr_opt, SimpleExprOpt, context);
        let simple_expr_built = SimpleExprBuilder::default()
            .simple_expr_opt(simple_expr_opt)
            .term(Box::new(term))
            .simple_expr_list(simple_expr_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.simple_expr(&simple_expr_built)?;
        self.push(ASTType::SimpleExpr(simple_expr_built), context);
        Ok(())
    }

    /// Semantic action for production 152:
    ///
    /// SimpleExprList /* Vec<T>::Push */: AddOp Term SimpleExprList;
    ///
    #[named]
    fn simple_expr_list_0(
        &mut self,
        _add_op: &ParseTreeStackEntry<'t>,
        _term: &ParseTreeStackEntry<'t>,
        _simple_expr_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut simple_expr_list = pop_item!(self, simple_expr_list, SimpleExprList, context);
        let term = pop_item!(self, term, Term, context);
        let add_op = pop_item!(self, add_op, AddOp, context);
        let simple_expr_list_0_built = SimpleExprListBuilder::default()
            .term(Box::new(term))
            .add_op(Box::new(add_op))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        simple_expr_list.push(simple_expr_list_0_built);
        self.push(ASTType::SimpleExprList(simple_expr_list), context);
        Ok(())
    }

    /// Semantic action for production 153:
    ///
    /// SimpleExprList /* Vec<T>::New */: ;
    ///
    #[named]
    fn simple_expr_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_expr_list_1_built = Vec::new();
        self.push(ASTType::SimpleExprList(simple_expr_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 154:
    ///
    /// SimpleExprOpt /* Option<T>::Some */: SimpleExprOptGroup;
    ///
    #[named]
    fn simple_expr_opt_0(
        &mut self,
        _simple_expr_opt_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_expr_opt_group =
            pop_item!(self, simple_expr_opt_group, SimpleExprOptGroup, context);
        let simple_expr_opt_0_built = SimpleExprOptBuilder::default()
            .simple_expr_opt_group(Box::new(simple_expr_opt_group))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::SimpleExprOpt(Some(Box::new(simple_expr_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 155:
    ///
    /// SimpleExprOptGroup: "\+";
    ///
    #[named]
    fn simple_expr_opt_group_0(
        &mut self,
        plus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = plus.token(parse_tree)?.clone();
        let simple_expr_opt_group_0_built = SimpleExprOptGroup0Builder::default()
            .plus(plus)
            .build()
            .into_diagnostic()?;
        let simple_expr_opt_group_0_built =
            SimpleExprOptGroup::SimpleExprOptGroup0(simple_expr_opt_group_0_built);
        self.push(
            ASTType::SimpleExprOptGroup(simple_expr_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 156:
    ///
    /// SimpleExprOptGroup: "-";
    ///
    #[named]
    fn simple_expr_opt_group_1(
        &mut self,
        minus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = minus.token(parse_tree)?.clone();
        let simple_expr_opt_group_1_built = SimpleExprOptGroup1Builder::default()
            .minus(minus)
            .build()
            .into_diagnostic()?;
        let simple_expr_opt_group_1_built =
            SimpleExprOptGroup::SimpleExprOptGroup1(simple_expr_opt_group_1_built);
        self.push(
            ASTType::SimpleExprOptGroup(simple_expr_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 157:
    ///
    /// SimpleExprOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn simple_expr_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SimpleExprOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 158:
    ///
    /// Term: Factor TermList /* Vec */;
    ///
    #[named]
    fn term(
        &mut self,
        _factor: &ParseTreeStackEntry<'t>,
        _term_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_list = pop_and_reverse_item!(self, term_list, TermList, context);
        let factor = pop_item!(self, factor, Factor, context);
        let term_built = TermBuilder::default()
            .factor(Box::new(factor))
            .term_list(term_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.term(&term_built)?;
        self.push(ASTType::Term(term_built), context);
        Ok(())
    }

    /// Semantic action for production 159:
    ///
    /// TermList /* Vec<T>::Push */: MulOp Factor TermList;
    ///
    #[named]
    fn term_list_0(
        &mut self,
        _mul_op: &ParseTreeStackEntry<'t>,
        _factor: &ParseTreeStackEntry<'t>,
        _term_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut term_list = pop_item!(self, term_list, TermList, context);
        let factor = pop_item!(self, factor, Factor, context);
        let mul_op = pop_item!(self, mul_op, MulOp, context);
        let term_list_0_built = TermListBuilder::default()
            .factor(Box::new(factor))
            .mul_op(Box::new(mul_op))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        term_list.push(term_list_0_built);
        self.push(ASTType::TermList(term_list), context);
        Ok(())
    }

    /// Semantic action for production 160:
    ///
    /// TermList /* Vec<T>::New */: ;
    ///
    #[named]
    fn term_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_list_1_built = Vec::new();
        self.push(ASTType::TermList(term_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 161:
    ///
    /// Factor: Designator FactorOpt /* Option */;
    ///
    #[named]
    fn factor_0(
        &mut self,
        _designator: &ParseTreeStackEntry<'t>,
        _factor_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_opt = pop_item!(self, factor_opt, FactorOpt, context);
        let designator = pop_item!(self, designator, Designator, context);
        let factor_0_built = Factor0Builder::default()
            .designator(Box::new(designator))
            .factor_opt(factor_opt)
            .build()
            .into_diagnostic()?;
        let factor_0_built = Factor::Factor0(factor_0_built);
        // Calling user action here
        self.user_grammar.factor(&factor_0_built)?;
        self.push(ASTType::Factor(factor_0_built), context);
        Ok(())
    }

    /// Semantic action for production 162:
    ///
    /// Factor: Number;
    ///
    #[named]
    fn factor_1(
        &mut self,
        _number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = pop_item!(self, number, Number, context);
        let factor_1_built = Factor1Builder::default()
            .number(Box::new(number))
            .build()
            .into_diagnostic()?;
        let factor_1_built = Factor::Factor1(factor_1_built);
        // Calling user action here
        self.user_grammar.factor(&factor_1_built)?;
        self.push(ASTType::Factor(factor_1_built), context);
        Ok(())
    }

    /// Semantic action for production 163:
    ///
    /// Factor: Character;
    ///
    #[named]
    fn factor_2(
        &mut self,
        _character: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let character = pop_item!(self, character, Character, context);
        let factor_2_built = Factor2Builder::default()
            .character(Box::new(character))
            .build()
            .into_diagnostic()?;
        let factor_2_built = Factor::Factor2(factor_2_built);
        // Calling user action here
        self.user_grammar.factor(&factor_2_built)?;
        self.push(ASTType::Factor(factor_2_built), context);
        Ok(())
    }

    /// Semantic action for production 164:
    ///
    /// Factor: String;
    ///
    #[named]
    fn factor_3(
        &mut self,
        _string: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let factor_3_built = Factor3Builder::default()
            .string(Box::new(string))
            .build()
            .into_diagnostic()?;
        let factor_3_built = Factor::Factor3(factor_3_built);
        // Calling user action here
        self.user_grammar.factor(&factor_3_built)?;
        self.push(ASTType::Factor(factor_3_built), context);
        Ok(())
    }

    /// Semantic action for production 165:
    ///
    /// Factor: "NIL"^ /* Clipped */;
    ///
    #[named]
    fn factor_4(
        &mut self,
        _n_i_l: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_4_built = Factor4Builder::default()
            // Ignore clipped member 'n_i_l'
            .build()
            .into_diagnostic()?;
        let factor_4_built = Factor::Factor4(factor_4_built);
        // Calling user action here
        self.user_grammar.factor(&factor_4_built)?;
        self.push(ASTType::Factor(factor_4_built), context);
        Ok(())
    }

    /// Semantic action for production 166:
    ///
    /// Factor: Set;
    ///
    #[named]
    fn factor_5(
        &mut self,
        _set: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let set = pop_item!(self, set, Set, context);
        let factor_5_built = Factor5Builder::default()
            .set(Box::new(set))
            .build()
            .into_diagnostic()?;
        let factor_5_built = Factor::Factor5(factor_5_built);
        // Calling user action here
        self.user_grammar.factor(&factor_5_built)?;
        self.push(ASTType::Factor(factor_5_built), context);
        Ok(())
    }

    /// Semantic action for production 167:
    ///
    /// Factor: "\("^ /* Clipped */ Expr "\)"^ /* Clipped */;
    ///
    #[named]
    fn factor_6(
        &mut self,
        _l_paren: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr = pop_item!(self, expr, Expr, context);
        let factor_6_built = Factor6Builder::default()
            // Ignore clipped member 'l_paren'
            .expr(Box::new(expr))
            // Ignore clipped member 'r_paren'
            .build()
            .into_diagnostic()?;
        let factor_6_built = Factor::Factor6(factor_6_built);
        // Calling user action here
        self.user_grammar.factor(&factor_6_built)?;
        self.push(ASTType::Factor(factor_6_built), context);
        Ok(())
    }

    /// Semantic action for production 168:
    ///
    /// Factor: "~"^ /* Clipped */ Factor;
    ///
    #[named]
    fn factor_7(
        &mut self,
        _tilde: &ParseTreeStackEntry<'t>,
        _factor: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor = pop_item!(self, factor, Factor, context);
        let factor_7_built = Factor7Builder::default()
            // Ignore clipped member 'tilde'
            .factor(Box::new(factor))
            .build()
            .into_diagnostic()?;
        let factor_7_built = Factor::Factor7(factor_7_built);
        // Calling user action here
        self.user_grammar.factor(&factor_7_built)?;
        self.push(ASTType::Factor(factor_7_built), context);
        Ok(())
    }

    /// Semantic action for production 169:
    ///
    /// FactorOpt /* Option<T>::Some */: "\("^ /* Clipped */ FactorOpt0 /* Option */ "\)"^ /* Clipped */;
    ///
    #[named]
    fn factor_opt_0(
        &mut self,
        _l_paren: &ParseTreeStackEntry<'t>,
        _factor_opt0: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_opt0 = pop_item!(self, factor_opt0, FactorOpt0, context);
        let factor_opt_0_built = FactorOptBuilder::default()
            // Ignore clipped member 'l_paren'
            .factor_opt0(factor_opt0)
            // Ignore clipped member 'r_paren'
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FactorOpt(Some(Box::new(factor_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 170:
    ///
    /// FactorOpt0 /* Option<T>::Some */: ExprList;
    ///
    #[named]
    fn factor_opt0_0(
        &mut self,
        _expr_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr_list = pop_item!(self, expr_list, ExprList, context);
        let factor_opt0_0_built = FactorOpt0Builder::default()
            .expr_list(Box::new(expr_list))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FactorOpt0(Some(Box::new(factor_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 171:
    ///
    /// FactorOpt0 /* Option<T>::None */: ;
    ///
    #[named]
    fn factor_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FactorOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 172:
    ///
    /// FactorOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn factor_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FactorOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 173:
    ///
    /// Set: "\{"^ /* Clipped */ SetOpt /* Option */ "\}"^ /* Clipped */;
    ///
    #[named]
    fn set(
        &mut self,
        _l_brace: &ParseTreeStackEntry<'t>,
        _set_opt: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let set_opt = pop_item!(self, set_opt, SetOpt, context);
        let set_built = SetBuilder::default()
            // Ignore clipped member 'l_brace'
            .set_opt(set_opt)
            // Ignore clipped member 'r_brace'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.set(&set_built)?;
        self.push(ASTType::Set(set_built), context);
        Ok(())
    }

    /// Semantic action for production 174:
    ///
    /// SetOpt /* Option<T>::Some */: Element SetOptList /* Vec */;
    ///
    #[named]
    fn set_opt_0(
        &mut self,
        _element: &ParseTreeStackEntry<'t>,
        _set_opt_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let set_opt_list = pop_and_reverse_item!(self, set_opt_list, SetOptList, context);
        let element = pop_item!(self, element, Element, context);
        let set_opt_0_built = SetOptBuilder::default()
            .element(Box::new(element))
            .set_opt_list(set_opt_list)
            .build()
            .into_diagnostic()?;
        self.push(ASTType::SetOpt(Some(Box::new(set_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 175:
    ///
    /// SetOptList /* Vec<T>::Push */: ","^ /* Clipped */ Element SetOptList;
    ///
    #[named]
    fn set_opt_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _element: &ParseTreeStackEntry<'t>,
        _set_opt_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut set_opt_list = pop_item!(self, set_opt_list, SetOptList, context);
        let element = pop_item!(self, element, Element, context);
        let set_opt_list_0_built = SetOptListBuilder::default()
            .element(Box::new(element))
            // Ignore clipped member 'comma'
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        set_opt_list.push(set_opt_list_0_built);
        self.push(ASTType::SetOptList(set_opt_list), context);
        Ok(())
    }

    /// Semantic action for production 176:
    ///
    /// SetOptList /* Vec<T>::New */: ;
    ///
    #[named]
    fn set_opt_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let set_opt_list_1_built = Vec::new();
        self.push(ASTType::SetOptList(set_opt_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 177:
    ///
    /// SetOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn set_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SetOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 178:
    ///
    /// Element: Expr ElementOpt /* Option */;
    ///
    #[named]
    fn element(
        &mut self,
        _expr: &ParseTreeStackEntry<'t>,
        _element_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_opt = pop_item!(self, element_opt, ElementOpt, context);
        let expr = pop_item!(self, expr, Expr, context);
        let element_built = ElementBuilder::default()
            .expr(Box::new(expr))
            .element_opt(element_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.element(&element_built)?;
        self.push(ASTType::Element(element_built), context);
        Ok(())
    }

    /// Semantic action for production 179:
    ///
    /// ElementOpt /* Option<T>::Some */: "\.\."^ /* Clipped */ Expr;
    ///
    #[named]
    fn element_opt_0(
        &mut self,
        _dot_dot: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr = pop_item!(self, expr, Expr, context);
        let element_opt_0_built = ElementOptBuilder::default()
            // Ignore clipped member 'dot_dot'
            .expr(Box::new(expr))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ElementOpt(Some(Box::new(element_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 180:
    ///
    /// ElementOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn element_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ElementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 181:
    ///
    /// Relation: "="^ /* Clipped */;
    ///
    #[named]
    fn relation_0(
        &mut self,
        _equ: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relation_0_built = Relation0Builder::default()
            // Ignore clipped member 'equ'
            .build()
            .into_diagnostic()?;
        let relation_0_built = Relation::Relation0(relation_0_built);
        // Calling user action here
        self.user_grammar.relation(&relation_0_built)?;
        self.push(ASTType::Relation(relation_0_built), context);
        Ok(())
    }

    /// Semantic action for production 182:
    ///
    /// Relation: "#";
    ///
    #[named]
    fn relation_1(
        &mut self,
        hash: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash = hash.token(parse_tree)?.clone();
        let relation_1_built = Relation1Builder::default()
            .hash(hash)
            .build()
            .into_diagnostic()?;
        let relation_1_built = Relation::Relation1(relation_1_built);
        // Calling user action here
        self.user_grammar.relation(&relation_1_built)?;
        self.push(ASTType::Relation(relation_1_built), context);
        Ok(())
    }

    /// Semantic action for production 183:
    ///
    /// Relation: "<";
    ///
    #[named]
    fn relation_2(
        &mut self,
        l_t: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t = l_t.token(parse_tree)?.clone();
        let relation_2_built = Relation2Builder::default()
            .l_t(l_t)
            .build()
            .into_diagnostic()?;
        let relation_2_built = Relation::Relation2(relation_2_built);
        // Calling user action here
        self.user_grammar.relation(&relation_2_built)?;
        self.push(ASTType::Relation(relation_2_built), context);
        Ok(())
    }

    /// Semantic action for production 184:
    ///
    /// Relation: "<=";
    ///
    #[named]
    fn relation_3(
        &mut self,
        l_t_equ: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_equ = l_t_equ.token(parse_tree)?.clone();
        let relation_3_built = Relation3Builder::default()
            .l_t_equ(l_t_equ)
            .build()
            .into_diagnostic()?;
        let relation_3_built = Relation::Relation3(relation_3_built);
        // Calling user action here
        self.user_grammar.relation(&relation_3_built)?;
        self.push(ASTType::Relation(relation_3_built), context);
        Ok(())
    }

    /// Semantic action for production 185:
    ///
    /// Relation: ">";
    ///
    #[named]
    fn relation_4(
        &mut self,
        g_t: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t = g_t.token(parse_tree)?.clone();
        let relation_4_built = Relation4Builder::default()
            .g_t(g_t)
            .build()
            .into_diagnostic()?;
        let relation_4_built = Relation::Relation4(relation_4_built);
        // Calling user action here
        self.user_grammar.relation(&relation_4_built)?;
        self.push(ASTType::Relation(relation_4_built), context);
        Ok(())
    }

    /// Semantic action for production 186:
    ///
    /// Relation: ">=";
    ///
    #[named]
    fn relation_5(
        &mut self,
        g_t_equ: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t_equ = g_t_equ.token(parse_tree)?.clone();
        let relation_5_built = Relation5Builder::default()
            .g_t_equ(g_t_equ)
            .build()
            .into_diagnostic()?;
        let relation_5_built = Relation::Relation5(relation_5_built);
        // Calling user action here
        self.user_grammar.relation(&relation_5_built)?;
        self.push(ASTType::Relation(relation_5_built), context);
        Ok(())
    }

    /// Semantic action for production 187:
    ///
    /// Relation: InOp;
    ///
    #[named]
    fn relation_6(
        &mut self,
        _in_op: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let in_op = pop_item!(self, in_op, InOp, context);
        let relation_6_built = Relation6Builder::default()
            .in_op(Box::new(in_op))
            .build()
            .into_diagnostic()?;
        let relation_6_built = Relation::Relation6(relation_6_built);
        // Calling user action here
        self.user_grammar.relation(&relation_6_built)?;
        self.push(ASTType::Relation(relation_6_built), context);
        Ok(())
    }

    /// Semantic action for production 188:
    ///
    /// Relation: "IS";
    ///
    #[named]
    fn relation_7(
        &mut self,
        i_s: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i_s = i_s.token(parse_tree)?.clone();
        let relation_7_built = Relation7Builder::default()
            .i_s(i_s)
            .build()
            .into_diagnostic()?;
        let relation_7_built = Relation::Relation7(relation_7_built);
        // Calling user action here
        self.user_grammar.relation(&relation_7_built)?;
        self.push(ASTType::Relation(relation_7_built), context);
        Ok(())
    }

    /// Semantic action for production 189:
    ///
    /// AddOp: "\+";
    ///
    #[named]
    fn add_op_0(
        &mut self,
        plus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = plus.token(parse_tree)?.clone();
        let add_op_0_built = AddOp0Builder::default()
            .plus(plus)
            .build()
            .into_diagnostic()?;
        let add_op_0_built = AddOp::AddOp0(add_op_0_built);
        // Calling user action here
        self.user_grammar.add_op(&add_op_0_built)?;
        self.push(ASTType::AddOp(add_op_0_built), context);
        Ok(())
    }

    /// Semantic action for production 190:
    ///
    /// AddOp: "-";
    ///
    #[named]
    fn add_op_1(
        &mut self,
        minus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = minus.token(parse_tree)?.clone();
        let add_op_1_built = AddOp1Builder::default()
            .minus(minus)
            .build()
            .into_diagnostic()?;
        let add_op_1_built = AddOp::AddOp1(add_op_1_built);
        // Calling user action here
        self.user_grammar.add_op(&add_op_1_built)?;
        self.push(ASTType::AddOp(add_op_1_built), context);
        Ok(())
    }

    /// Semantic action for production 191:
    ///
    /// AddOp: "OR";
    ///
    #[named]
    fn add_op_2(
        &mut self,
        o_r: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let o_r = o_r.token(parse_tree)?.clone();
        let add_op_2_built = AddOp2Builder::default()
            .o_r(o_r)
            .build()
            .into_diagnostic()?;
        let add_op_2_built = AddOp::AddOp2(add_op_2_built);
        // Calling user action here
        self.user_grammar.add_op(&add_op_2_built)?;
        self.push(ASTType::AddOp(add_op_2_built), context);
        Ok(())
    }

    /// Semantic action for production 192:
    ///
    /// MulOp: "\*";
    ///
    #[named]
    fn mul_op_0(
        &mut self,
        star: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = star.token(parse_tree)?.clone();
        let mul_op_0_built = MulOp0Builder::default()
            .star(star)
            .build()
            .into_diagnostic()?;
        let mul_op_0_built = MulOp::MulOp0(mul_op_0_built);
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_0_built)?;
        self.push(ASTType::MulOp(mul_op_0_built), context);
        Ok(())
    }

    /// Semantic action for production 193:
    ///
    /// MulOp: "/";
    ///
    #[named]
    fn mul_op_1(
        &mut self,
        slash: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let slash = slash.token(parse_tree)?.clone();
        let mul_op_1_built = MulOp1Builder::default()
            .slash(slash)
            .build()
            .into_diagnostic()?;
        let mul_op_1_built = MulOp::MulOp1(mul_op_1_built);
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_1_built)?;
        self.push(ASTType::MulOp(mul_op_1_built), context);
        Ok(())
    }

    /// Semantic action for production 194:
    ///
    /// MulOp: "DIV";
    ///
    #[named]
    fn mul_op_2(
        &mut self,
        d_i_v: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let d_i_v = d_i_v.token(parse_tree)?.clone();
        let mul_op_2_built = MulOp2Builder::default()
            .d_i_v(d_i_v)
            .build()
            .into_diagnostic()?;
        let mul_op_2_built = MulOp::MulOp2(mul_op_2_built);
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_2_built)?;
        self.push(ASTType::MulOp(mul_op_2_built), context);
        Ok(())
    }

    /// Semantic action for production 195:
    ///
    /// MulOp: "MOD";
    ///
    #[named]
    fn mul_op_3(
        &mut self,
        m_o_d: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_o_d = m_o_d.token(parse_tree)?.clone();
        let mul_op_3_built = MulOp3Builder::default()
            .m_o_d(m_o_d)
            .build()
            .into_diagnostic()?;
        let mul_op_3_built = MulOp::MulOp3(mul_op_3_built);
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_3_built)?;
        self.push(ASTType::MulOp(mul_op_3_built), context);
        Ok(())
    }

    /// Semantic action for production 196:
    ///
    /// MulOp: "&";
    ///
    #[named]
    fn mul_op_4(
        &mut self,
        amp: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let amp = amp.token(parse_tree)?.clone();
        let mul_op_4_built = MulOp4Builder::default()
            .amp(amp)
            .build()
            .into_diagnostic()?;
        let mul_op_4_built = MulOp::MulOp4(mul_op_4_built);
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_4_built)?;
        self.push(ASTType::MulOp(mul_op_4_built), context);
        Ok(())
    }

    /// Semantic action for production 197:
    ///
    /// Designator: QualIdent DesignatorList /* Vec */;
    ///
    #[named]
    fn designator(
        &mut self,
        _qual_ident: &ParseTreeStackEntry<'t>,
        _designator_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let designator_list = pop_and_reverse_item!(self, designator_list, DesignatorList, context);
        let qual_ident = pop_item!(self, qual_ident, QualIdent, context);
        let designator_built = DesignatorBuilder::default()
            .qual_ident(Box::new(qual_ident))
            .designator_list(designator_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.designator(&designator_built)?;
        self.push(ASTType::Designator(designator_built), context);
        Ok(())
    }

    /// Semantic action for production 198:
    ///
    /// DesignatorList /* Vec<T>::Push */: DesignatorSuffix DesignatorList;
    ///
    #[named]
    fn designator_list_0(
        &mut self,
        _designator_suffix: &ParseTreeStackEntry<'t>,
        _designator_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut designator_list = pop_item!(self, designator_list, DesignatorList, context);
        let designator_suffix = pop_item!(self, designator_suffix, DesignatorSuffix, context);
        let designator_list_0_built = DesignatorListBuilder::default()
            .designator_suffix(Box::new(designator_suffix))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        designator_list.push(designator_list_0_built);
        self.push(ASTType::DesignatorList(designator_list), context);
        Ok(())
    }

    /// Semantic action for production 199:
    ///
    /// DesignatorList /* Vec<T>::New */: ;
    ///
    #[named]
    fn designator_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let designator_list_1_built = Vec::new();
        self.push(ASTType::DesignatorList(designator_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 200:
    ///
    /// DesignatorSuffix: "\."^ /* Clipped */ Ident;
    ///
    #[named]
    fn designator_suffix_0(
        &mut self,
        _dot: &ParseTreeStackEntry<'t>,
        _ident: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let designator_suffix_0_built = DesignatorSuffix0Builder::default()
            // Ignore clipped member 'dot'
            .ident(Box::new(ident))
            .build()
            .into_diagnostic()?;
        let designator_suffix_0_built =
            DesignatorSuffix::DesignatorSuffix0(designator_suffix_0_built);
        // Calling user action here
        self.user_grammar
            .designator_suffix(&designator_suffix_0_built)?;
        self.push(
            ASTType::DesignatorSuffix(designator_suffix_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 201:
    ///
    /// DesignatorSuffix: "\["^ /* Clipped */ ExprList "\]"^ /* Clipped */;
    ///
    #[named]
    fn designator_suffix_1(
        &mut self,
        _l_bracket: &ParseTreeStackEntry<'t>,
        _expr_list: &ParseTreeStackEntry<'t>,
        _r_bracket: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr_list = pop_item!(self, expr_list, ExprList, context);
        let designator_suffix_1_built = DesignatorSuffix1Builder::default()
            // Ignore clipped member 'l_bracket'
            .expr_list(Box::new(expr_list))
            // Ignore clipped member 'r_bracket'
            .build()
            .into_diagnostic()?;
        let designator_suffix_1_built =
            DesignatorSuffix::DesignatorSuffix1(designator_suffix_1_built);
        // Calling user action here
        self.user_grammar
            .designator_suffix(&designator_suffix_1_built)?;
        self.push(
            ASTType::DesignatorSuffix(designator_suffix_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 202:
    ///
    /// DesignatorSuffix: "\^"^ /* Clipped */;
    ///
    #[named]
    fn designator_suffix_2(
        &mut self,
        _circumflex: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let designator_suffix_2_built = DesignatorSuffix2Builder::default()
            // Ignore clipped member 'circumflex'
            .build()
            .into_diagnostic()?;
        let designator_suffix_2_built =
            DesignatorSuffix::DesignatorSuffix2(designator_suffix_2_built);
        // Calling user action here
        self.user_grammar
            .designator_suffix(&designator_suffix_2_built)?;
        self.push(
            ASTType::DesignatorSuffix(designator_suffix_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 203:
    ///
    /// ExprList: Expr ExprListList /* Vec */;
    ///
    #[named]
    fn expr_list(
        &mut self,
        _expr: &ParseTreeStackEntry<'t>,
        _expr_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr_list_list = pop_and_reverse_item!(self, expr_list_list, ExprListList, context);
        let expr = pop_item!(self, expr, Expr, context);
        let expr_list_built = ExprListBuilder::default()
            .expr(Box::new(expr))
            .expr_list_list(expr_list_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expr_list(&expr_list_built)?;
        self.push(ASTType::ExprList(expr_list_built), context);
        Ok(())
    }

    /// Semantic action for production 204:
    ///
    /// ExprListList /* Vec<T>::Push */: ","^ /* Clipped */ Expr ExprListList;
    ///
    #[named]
    fn expr_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        _expr_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expr_list_list = pop_item!(self, expr_list_list, ExprListList, context);
        let expr = pop_item!(self, expr, Expr, context);
        let expr_list_list_0_built = ExprListListBuilder::default()
            .expr(Box::new(expr))
            // Ignore clipped member 'comma'
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expr_list_list.push(expr_list_list_0_built);
        self.push(ASTType::ExprListList(expr_list_list), context);
        Ok(())
    }

    /// Semantic action for production 205:
    ///
    /// ExprListList /* Vec<T>::New */: ;
    ///
    #[named]
    fn expr_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr_list_list_1_built = Vec::new();
        self.push(ASTType::ExprListList(expr_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 206:
    ///
    /// IdentList: IdentDef IdentListList /* Vec */;
    ///
    #[named]
    fn ident_list(
        &mut self,
        _ident_def: &ParseTreeStackEntry<'t>,
        _ident_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident_list_list = pop_and_reverse_item!(self, ident_list_list, IdentListList, context);
        let ident_def = pop_item!(self, ident_def, IdentDef, context);
        let ident_list_built = IdentListBuilder::default()
            .ident_def(Box::new(ident_def))
            .ident_list_list(ident_list_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.ident_list(&ident_list_built)?;
        self.push(ASTType::IdentList(ident_list_built), context);
        Ok(())
    }

    /// Semantic action for production 207:
    ///
    /// IdentListList /* Vec<T>::Push */: ","^ /* Clipped */ IdentDef IdentListList;
    ///
    #[named]
    fn ident_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _ident_def: &ParseTreeStackEntry<'t>,
        _ident_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut ident_list_list = pop_item!(self, ident_list_list, IdentListList, context);
        let ident_def = pop_item!(self, ident_def, IdentDef, context);
        let ident_list_list_0_built = IdentListListBuilder::default()
            .ident_def(Box::new(ident_def))
            // Ignore clipped member 'comma'
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        ident_list_list.push(ident_list_list_0_built);
        self.push(ASTType::IdentListList(ident_list_list), context);
        Ok(())
    }

    /// Semantic action for production 208:
    ///
    /// IdentListList /* Vec<T>::New */: ;
    ///
    #[named]
    fn ident_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident_list_list_1_built = Vec::new();
        self.push(ASTType::IdentListList(ident_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 209:
    ///
    /// QualIdent: Ident;
    ///
    #[named]
    fn qual_ident_0(
        &mut self,
        _ident: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let qual_ident_0_built = QualIdent0Builder::default()
            .ident(Box::new(ident))
            .build()
            .into_diagnostic()?;
        let qual_ident_0_built = QualIdent::QualIdent0(qual_ident_0_built);
        // Calling user action here
        self.user_grammar.qual_ident(&qual_ident_0_built)?;
        self.push(ASTType::QualIdent(qual_ident_0_built), context);
        Ok(())
    }

    /// Semantic action for production 210:
    ///
    /// QualIdent: QIdent;
    ///
    #[named]
    fn qual_ident_1(
        &mut self,
        _q_ident: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let q_ident = pop_item!(self, q_ident, QIdent, context);
        let qual_ident_1_built = QualIdent1Builder::default()
            .q_ident(Box::new(q_ident))
            .build()
            .into_diagnostic()?;
        let qual_ident_1_built = QualIdent::QualIdent1(qual_ident_1_built);
        // Calling user action here
        self.user_grammar.qual_ident(&qual_ident_1_built)?;
        self.push(ASTType::QualIdent(qual_ident_1_built), context);
        Ok(())
    }

    /// Semantic action for production 211:
    ///
    /// IdentDef: Ident IdentDefOpt /* Option */;
    ///
    #[named]
    fn ident_def(
        &mut self,
        _ident: &ParseTreeStackEntry<'t>,
        _ident_def_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident_def_opt = pop_item!(self, ident_def_opt, IdentDefOpt, context);
        let ident = pop_item!(self, ident, Ident, context);
        let ident_def_built = IdentDefBuilder::default()
            .ident(Box::new(ident))
            .ident_def_opt(ident_def_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.ident_def(&ident_def_built)?;
        self.push(ASTType::IdentDef(ident_def_built), context);
        Ok(())
    }

    /// Semantic action for production 212:
    ///
    /// IdentDefOpt /* Option<T>::Some */: IdentDefOptGroup;
    ///
    #[named]
    fn ident_def_opt_0(
        &mut self,
        _ident_def_opt_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident_def_opt_group = pop_item!(self, ident_def_opt_group, IdentDefOptGroup, context);
        let ident_def_opt_0_built = IdentDefOptBuilder::default()
            .ident_def_opt_group(Box::new(ident_def_opt_group))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::IdentDefOpt(Some(Box::new(ident_def_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 213:
    ///
    /// IdentDefOptGroup: "\*";
    ///
    #[named]
    fn ident_def_opt_group_0(
        &mut self,
        star: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = star.token(parse_tree)?.clone();
        let ident_def_opt_group_0_built = IdentDefOptGroup0Builder::default()
            .star(star)
            .build()
            .into_diagnostic()?;
        let ident_def_opt_group_0_built =
            IdentDefOptGroup::IdentDefOptGroup0(ident_def_opt_group_0_built);
        self.push(
            ASTType::IdentDefOptGroup(ident_def_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 214:
    ///
    /// IdentDefOptGroup: "-";
    ///
    #[named]
    fn ident_def_opt_group_1(
        &mut self,
        minus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = minus.token(parse_tree)?.clone();
        let ident_def_opt_group_1_built = IdentDefOptGroup1Builder::default()
            .minus(minus)
            .build()
            .into_diagnostic()?;
        let ident_def_opt_group_1_built =
            IdentDefOptGroup::IdentDefOptGroup1(ident_def_opt_group_1_built);
        self.push(
            ASTType::IdentDefOptGroup(ident_def_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 215:
    ///
    /// IdentDefOpt /* Option<T>::None */: ;
    ///
    #[named]
    fn ident_def_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::IdentDefOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 216:
    ///
    /// Number: Integer;
    ///
    #[named]
    fn number_0(
        &mut self,
        _integer: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let number_0_built = Number0Builder::default()
            .integer(Box::new(integer))
            .build()
            .into_diagnostic()?;
        let number_0_built = Number::Number0(number_0_built);
        // Calling user action here
        self.user_grammar.number(&number_0_built)?;
        self.push(ASTType::Number(number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 217:
    ///
    /// Number: Real;
    ///
    #[named]
    fn number_1(
        &mut self,
        _real: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let real = pop_item!(self, real, Real, context);
        let number_1_built = Number1Builder::default()
            .real(Box::new(real))
            .build()
            .into_diagnostic()?;
        let number_1_built = Number::Number1(number_1_built);
        // Calling user action here
        self.user_grammar.number(&number_1_built)?;
        self.push(ASTType::Number(number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 218:
    ///
    /// Real: "[0-9][0-9]*\.[0-9]*(ED[+-]?[0-9][0-9]*)?";
    ///
    #[named]
    fn real(
        &mut self,
        real: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let real = real.token(parse_tree)?.clone();
        let real_built = RealBuilder::default()
            .real(real)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.real(&real_built)?;
        self.push(ASTType::Real(real_built), context);
        Ok(())
    }

    /// Semantic action for production 219:
    ///
    /// Character: "[0-9][0-9A-F]*X";
    ///
    #[named]
    fn character(
        &mut self,
        character: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let character = character.token(parse_tree)?.clone();
        let character_built = CharacterBuilder::default()
            .character(character)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.character(&character_built)?;
        self.push(ASTType::Character(character_built), context);
        Ok(())
    }

    /// Semantic action for production 220:
    ///
    /// Integer: "[0-9][0-9]*|[0-9][0-9A-F]*H";
    ///
    #[named]
    fn integer(
        &mut self,
        integer: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = integer.token(parse_tree)?.clone();
        let integer_built = IntegerBuilder::default()
            .integer(integer)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.integer(&integer_built)?;
        self.push(ASTType::Integer(integer_built), context);
        Ok(())
    }

    /// Semantic action for production 221:
    ///
    /// QIdent: "[a-zA-Z_]\w*\.[a-zA-Z_]\w*";
    ///
    #[named]
    fn q_ident(
        &mut self,
        q_ident: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let q_ident = q_ident.token(parse_tree)?.clone();
        let q_ident_built = QIdentBuilder::default()
            .q_ident(q_ident)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.q_ident(&q_ident_built)?;
        self.push(ASTType::QIdent(q_ident_built), context);
        Ok(())
    }

    /// Semantic action for production 222:
    ///
    /// Ident: "[a-zA-Z_]\w*";
    ///
    #[named]
    fn ident(
        &mut self,
        ident: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = ident.token(parse_tree)?.clone();
        let ident_built = IdentBuilder::default()
            .ident(ident)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.ident(&ident_built)?;
        self.push(ASTType::Ident(ident_built), context);
        Ok(())
    }

    /// Semantic action for production 223:
    ///
    /// String: "\u{0022}[^\u{0022}]*\u{0022}|'[^']*'";
    ///
    #[named]
    fn string(
        &mut self,
        string: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = string.token(parse_tree)?.clone();
        let string_built = StringBuilder::default()
            .string(string)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.string(&string_built)?;
        self.push(ASTType::String(string_built), context);
        Ok(())
    }

    /// Semantic action for production 224:
    ///
    /// InOp: "IN"^ /* Clipped */;
    ///
    #[named]
    fn in_op(
        &mut self,
        _in_op: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let in_op_built = InOpBuilder::default()
            // Ignore clipped member 'in_op'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.in_op(&in_op_built)?;
        self.push(ASTType::InOp(in_op_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for Oberon2GrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item Oberon2Grammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.kw_begin(&children[0], parse_tree),
            1 => self.kw_case(&children[0], parse_tree),
            2 => self.kw_do(&children[0], parse_tree),
            3 => self.kw_else(&children[0], parse_tree),
            4 => self.kw_elsif(&children[0], parse_tree),
            5 => self.kw_end(&children[0], parse_tree),
            6 => self.kw_if(&children[0], parse_tree),
            7 => self.kw_of(&children[0], parse_tree),
            8 => self.kw_procedure(&children[0], parse_tree),
            9 => self.kw_then(&children[0], parse_tree),
            10 => self.kw_to(&children[0], parse_tree),
            11 => self.kw_var(&children[0], parse_tree),
            12 => self.oberon2(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            13 => self.oberon2_opt_0(&children[0], parse_tree),
            14 => self.oberon2_opt_1(parse_tree),
            15 => self.module_head(&children[0], &children[1], &children[2], parse_tree),
            16 => self.module_body(&children[0], &children[1], parse_tree),
            17 => self.import_list(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            18 => self.import_list_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            19 => self.import_list_list_1(parse_tree),
            20 => self.import_list_opt0_0(&children[0], &children[1], parse_tree),
            21 => self.import_list_opt0_1(parse_tree),
            22 => self.import_list_opt_0(&children[0], &children[1], parse_tree),
            23 => self.import_list_opt_1(parse_tree),
            24 => self.decl_seq(&children[0], &children[1], parse_tree),
            25 => self.decl_seq_list0_0(&children[0], &children[1], parse_tree),
            26 => self.decl_seq_list0_group_0(&children[0], &children[1], parse_tree),
            27 => self.decl_seq_list0_group_1(&children[0], &children[1], parse_tree),
            28 => self.decl_seq_list0_1(parse_tree),
            29 => self.decl_seq_list_0(&children[0], &children[1], parse_tree),
            30 => self.decl_seq_list_1(parse_tree),
            31 => self.decl_block_0(&children[0], parse_tree),
            32 => self.decl_block_1(&children[0], parse_tree),
            33 => self.decl_block_2(&children[0], parse_tree),
            34 => self.const_decl_block(&children[0], &children[1], parse_tree),
            35 => {
                self.const_decl_block_list_0(&children[0], &children[1], &children[2], parse_tree)
            }
            36 => self.const_decl_block_list_1(parse_tree),
            37 => self.type_decl_block(&children[0], &children[1], parse_tree),
            38 => self.type_decl_block_list_0(&children[0], &children[1], &children[2], parse_tree),
            39 => self.type_decl_block_list_1(parse_tree),
            40 => self.var_decl_block(&children[0], &children[1], parse_tree),
            41 => self.var_decl_block_list_0(&children[0], &children[1], &children[2], parse_tree),
            42 => self.var_decl_block_list_1(parse_tree),
            43 => self.const_decl(&children[0], &children[1], &children[2], parse_tree),
            44 => self.type_decl(&children[0], &children[1], &children[2], parse_tree),
            45 => self.var_decl(&children[0], &children[1], &children[2], parse_tree),
            46 => self.proc_decl(&children[0], &children[1], &children[2], parse_tree),
            47 => self.procedure_heading(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            48 => self.procedure_heading_opt0_0(&children[0], parse_tree),
            49 => self.procedure_heading_opt0_1(parse_tree),
            50 => self.procedure_heading_opt_0(&children[0], parse_tree),
            51 => self.procedure_heading_opt_1(parse_tree),
            52 => self.procedure_body(&children[0], &children[1], parse_tree),
            53 => self.statement_block(&children[0], &children[1], &children[2], parse_tree),
            54 => self.statement_block_opt_0(&children[0], &children[1], parse_tree),
            55 => self.statement_block_opt_1(parse_tree),
            56 => self.forward_decl(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            57 => self.forward_decl_opt0_0(&children[0], parse_tree),
            58 => self.forward_decl_opt0_1(parse_tree),
            59 => self.forward_decl_opt_0(&children[0], parse_tree),
            60 => self.forward_decl_opt_1(parse_tree),
            61 => self.formal_pars(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            62 => self.formal_pars_opt0_0(&children[0], &children[1], parse_tree),
            63 => self.formal_pars_opt0_1(parse_tree),
            64 => self.formal_pars_opt_0(&children[0], &children[1], parse_tree),
            65 => self.formal_pars_opt_list_0(&children[0], &children[1], &children[2], parse_tree),
            66 => self.formal_pars_opt_list_1(parse_tree),
            67 => self.formal_pars_opt_1(parse_tree),
            68 => self.f_p_section(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            69 => self.f_p_section_list_0(&children[0], &children[1], &children[2], parse_tree),
            70 => self.f_p_section_list_1(parse_tree),
            71 => self.f_p_section_opt_0(&children[0], parse_tree),
            72 => self.f_p_section_opt_1(parse_tree),
            73 => self.receiver(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            74 => self.receiver_opt_0(&children[0], parse_tree),
            75 => self.receiver_opt_1(parse_tree),
            76 => self.receiver_var_decl(&children[0], &children[1], &children[2], parse_tree),
            77 => self.type_def_0(&children[0], parse_tree),
            78 => self.type_def_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            79 => self.type_def_2(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            80 => self.type_def_list_0(&children[0], &children[1], &children[2], parse_tree),
            81 => self.type_def_list_1(parse_tree),
            82 => self.type_def_3(&children[0], &children[1], &children[2], parse_tree),
            83 => self.type_def_4(&children[0], &children[1], parse_tree),
            84 => self.type_def_opt1_0(&children[0], parse_tree),
            85 => self.type_def_opt1_1(parse_tree),
            86 => self.type_def_opt0_0(&children[0], &children[1], &children[2], parse_tree),
            87 => self.type_def_opt0_1(parse_tree),
            88 => self.type_def_opt_0(&children[0], &children[1], parse_tree),
            89 => self.type_def_opt_list_0(&children[0], &children[1], &children[2], parse_tree),
            90 => self.type_def_opt_list_1(parse_tree),
            91 => self.type_def_opt_1(parse_tree),
            92 => self.field_list(&children[0], parse_tree),
            93 => self.field_list_opt_0(&children[0], &children[1], &children[2], parse_tree),
            94 => self.field_list_opt_1(parse_tree),
            95 => self.statement_seq(&children[0], &children[1], parse_tree),
            96 => self.statement_seq_list_0(&children[0], &children[1], &children[2], parse_tree),
            97 => self.statement_seq_list_1(parse_tree),
            98 => self.statement(&children[0], parse_tree),
            99 => self.statement_opt_0(&children[0], parse_tree),
            100 => self.statement_opt_group_0(&children[0], &children[1], parse_tree),
            101 => self.statement_opt_group_suffix_0(&children[0], &children[1], parse_tree),
            102 => self.statement_opt_group_suffix_1(&children[0], parse_tree),
            103 => self.statement_opt_group_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            104 => self.statement_opt_group_2(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            105 => self.statement_opt_group_3(&children[0], &children[1], &children[2], parse_tree),
            106 => self.statement_opt_group_4(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            107 => self.statement_opt_group_5(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            108 => self.statement_opt_group_6(&children[0], &children[1], &children[2], parse_tree),
            109 => self.statement_opt_group_7(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            110 => self.statement_opt_group_8(&children[0], parse_tree),
            111 => self.statement_opt_group_9(&children[0], &children[1], parse_tree),
            112 => self.statement_opt_group_list_0(&children[0], &children[1], parse_tree),
            113 => self.statement_opt_group_list_1(parse_tree),
            114 => self.statement_opt_group_list0_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            115 => self.statement_opt_group_list0_1(parse_tree),
            116 => self.statement_opt2_0(&children[0], parse_tree),
            117 => self.statement_opt2_1(parse_tree),
            118 => self.statement_opt1_0(&children[0], parse_tree),
            119 => self.statement_opt1_1(parse_tree),
            120 => self.statement_opt0_0(&children[0], &children[1], &children[2], parse_tree),
            121 => self.statement_opt3_0(&children[0], parse_tree),
            122 => self.statement_opt3_1(parse_tree),
            123 => self.statement_opt0_1(parse_tree),
            124 => self.statement_opt_1(parse_tree),
            125 => self.then_block(&children[0], &children[1], parse_tree),
            126 => self.cases(&children[0], &children[1], parse_tree),
            127 => self.cases_list_0(&children[0], &children[1], &children[2], parse_tree),
            128 => self.cases_list_1(parse_tree),
            129 => self.elsif_part(&children[0], &children[1], &children[2], parse_tree),
            130 => self.else_part(&children[0], &children[1], parse_tree),
            131 => self.opt_else_part_end(&children[0], &children[1], parse_tree),
            132 => self.opt_else_part_end_opt_0(&children[0], parse_tree),
            133 => self.opt_else_part_end_opt_1(parse_tree),
            134 => self.do_block(&children[0], &children[1], &children[2], parse_tree),
            135 => self.guarded_do_block(&children[0], &children[1], &children[2], parse_tree),
            136 => self.for_init(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            137 => self.for_step(&children[0], &children[1], parse_tree),
            138 => self.case(&children[0], parse_tree),
            139 => self.case_opt_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            140 => self.case_opt_list_0(&children[0], &children[1], &children[2], parse_tree),
            141 => self.case_opt_list_1(parse_tree),
            142 => self.case_opt_1(parse_tree),
            143 => self.case_labels(&children[0], &children[1], parse_tree),
            144 => self.case_labels_opt_0(&children[0], &children[1], parse_tree),
            145 => self.case_labels_opt_1(parse_tree),
            146 => self.guard(&children[0], &children[1], &children[2], parse_tree),
            147 => self.const_expr(&children[0], parse_tree),
            148 => self.expr(&children[0], &children[1], parse_tree),
            149 => self.expr_opt_0(&children[0], &children[1], parse_tree),
            150 => self.expr_opt_1(parse_tree),
            151 => self.simple_expr(&children[0], &children[1], &children[2], parse_tree),
            152 => self.simple_expr_list_0(&children[0], &children[1], &children[2], parse_tree),
            153 => self.simple_expr_list_1(parse_tree),
            154 => self.simple_expr_opt_0(&children[0], parse_tree),
            155 => self.simple_expr_opt_group_0(&children[0], parse_tree),
            156 => self.simple_expr_opt_group_1(&children[0], parse_tree),
            157 => self.simple_expr_opt_1(parse_tree),
            158 => self.term(&children[0], &children[1], parse_tree),
            159 => self.term_list_0(&children[0], &children[1], &children[2], parse_tree),
            160 => self.term_list_1(parse_tree),
            161 => self.factor_0(&children[0], &children[1], parse_tree),
            162 => self.factor_1(&children[0], parse_tree),
            163 => self.factor_2(&children[0], parse_tree),
            164 => self.factor_3(&children[0], parse_tree),
            165 => self.factor_4(&children[0], parse_tree),
            166 => self.factor_5(&children[0], parse_tree),
            167 => self.factor_6(&children[0], &children[1], &children[2], parse_tree),
            168 => self.factor_7(&children[0], &children[1], parse_tree),
            169 => self.factor_opt_0(&children[0], &children[1], &children[2], parse_tree),
            170 => self.factor_opt0_0(&children[0], parse_tree),
            171 => self.factor_opt0_1(parse_tree),
            172 => self.factor_opt_1(parse_tree),
            173 => self.set(&children[0], &children[1], &children[2], parse_tree),
            174 => self.set_opt_0(&children[0], &children[1], parse_tree),
            175 => self.set_opt_list_0(&children[0], &children[1], &children[2], parse_tree),
            176 => self.set_opt_list_1(parse_tree),
            177 => self.set_opt_1(parse_tree),
            178 => self.element(&children[0], &children[1], parse_tree),
            179 => self.element_opt_0(&children[0], &children[1], parse_tree),
            180 => self.element_opt_1(parse_tree),
            181 => self.relation_0(&children[0], parse_tree),
            182 => self.relation_1(&children[0], parse_tree),
            183 => self.relation_2(&children[0], parse_tree),
            184 => self.relation_3(&children[0], parse_tree),
            185 => self.relation_4(&children[0], parse_tree),
            186 => self.relation_5(&children[0], parse_tree),
            187 => self.relation_6(&children[0], parse_tree),
            188 => self.relation_7(&children[0], parse_tree),
            189 => self.add_op_0(&children[0], parse_tree),
            190 => self.add_op_1(&children[0], parse_tree),
            191 => self.add_op_2(&children[0], parse_tree),
            192 => self.mul_op_0(&children[0], parse_tree),
            193 => self.mul_op_1(&children[0], parse_tree),
            194 => self.mul_op_2(&children[0], parse_tree),
            195 => self.mul_op_3(&children[0], parse_tree),
            196 => self.mul_op_4(&children[0], parse_tree),
            197 => self.designator(&children[0], &children[1], parse_tree),
            198 => self.designator_list_0(&children[0], &children[1], parse_tree),
            199 => self.designator_list_1(parse_tree),
            200 => self.designator_suffix_0(&children[0], &children[1], parse_tree),
            201 => self.designator_suffix_1(&children[0], &children[1], &children[2], parse_tree),
            202 => self.designator_suffix_2(&children[0], parse_tree),
            203 => self.expr_list(&children[0], &children[1], parse_tree),
            204 => self.expr_list_list_0(&children[0], &children[1], &children[2], parse_tree),
            205 => self.expr_list_list_1(parse_tree),
            206 => self.ident_list(&children[0], &children[1], parse_tree),
            207 => self.ident_list_list_0(&children[0], &children[1], &children[2], parse_tree),
            208 => self.ident_list_list_1(parse_tree),
            209 => self.qual_ident_0(&children[0], parse_tree),
            210 => self.qual_ident_1(&children[0], parse_tree),
            211 => self.ident_def(&children[0], &children[1], parse_tree),
            212 => self.ident_def_opt_0(&children[0], parse_tree),
            213 => self.ident_def_opt_group_0(&children[0], parse_tree),
            214 => self.ident_def_opt_group_1(&children[0], parse_tree),
            215 => self.ident_def_opt_1(parse_tree),
            216 => self.number_0(&children[0], parse_tree),
            217 => self.number_1(&children[0], parse_tree),
            218 => self.real(&children[0], parse_tree),
            219 => self.character(&children[0], parse_tree),
            220 => self.integer(&children[0], parse_tree),
            221 => self.q_ident(&children[0], parse_tree),
            222 => self.ident(&children[0], parse_tree),
            223 => self.string(&children[0], parse_tree),
            224 => self.in_op(&children[0], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
