use crate::StrVec;

#[derive(BartDisplay, Builder, Debug, Default)]
#[template = "templates/user_trait_caller_function_template.rs.tpl"]
pub(crate) struct UserTraitCallerFunctionData {
    fn_name: String,
    prod_num: usize,
    fn_arguments: String,
}

#[derive(BartDisplay, Builder, Debug, Default)]
#[template = "templates/user_trait_function_template.rs.tpl"]
pub(crate) struct UserTraitFunctionData {
    pub fn_name: String,
    #[builder(default)]
    pub prod_num: usize,
    pub fn_arguments: String,
    #[builder(default)]
    pub prod_string: String,
    #[builder(default)]
    pub non_terminal: String,
    // This is used to control whether the #[named] is generated
    #[builder(default)]
    pub named: bool,
    #[builder(default)]
    pub code: StrVec,
    // Inner means the expanded version of the grammar.
    // If set to false the actual user grammar is meant.
    #[builder(default)]
    pub inner: bool,
}

#[derive(BartDisplay, Builder, Debug, Default)]
#[template = "templates/user_trait_function_stack_pop_template.rs.tpl"]
pub(crate) struct UserTraitFunctionStackPopData {
    pub arg_name: String,
    pub arg_type: String,
    pub vec_anchor: bool,
    pub vec_push_semantic: bool,
}

#[derive(Builder, Debug, Default)]
pub(crate) struct UserTraitData<'a> {
    pub user_type_name: &'a str,
    pub auto_generate: bool,
    pub range: bool,
    pub user_provided_attributes: StrVec,
    pub production_output_types: StrVec,
    pub non_terminal_types: StrVec,
    pub ast_type_decl: String,
    pub ast_type_has_lifetime: bool,
    pub trait_functions: StrVec,
    pub trait_caller: StrVec,
    pub module_name: &'a str,
    pub user_trait_functions: StrVec,
}

impl std::fmt::Display for UserTraitData<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let UserTraitData {
            user_type_name,
            auto_generate,
            range,
            user_provided_attributes,
            production_output_types,
            non_terminal_types,
            ast_type_decl,
            ast_type_has_lifetime,
            trait_functions,
            trait_caller,
            module_name,
            user_trait_functions,
        } = self;

        write!(f, "
            // ---------------------------------------------------------
            // This file was generated by parol.
            // It is not intended for manual editing and changes will be
            // lost after next build.
            // ---------------------------------------------------------

            // Disable clippy warnings that can result in the way how parol generates code.
            ")?;

        f.write_fmt(ume::ume! {
            #user_provided_attributes
            #![allow(clippy::enum_variant_names)]
            #![allow(clippy::large_enum_variant)]
            #![allow(clippy::upper_case_acronyms)]
        })?;

        if *range {
            f.write_fmt(ume::ume!(use parol_runtime::{Span, ToSpan};))?;
        }
        if *auto_generate {
            f.write_fmt(ume::ume! {
                use parol_runtime::derive_builder::Builder;
                #[allow(unused_imports)]
                use parol_runtime::parol_macros::{pop_item, pop_and_reverse_item};
                use parol_runtime::log::trace;
                use parol_runtime::miette::{bail, IntoDiagnostic};
            })?;
            if *ast_type_has_lifetime {
                f.write_fmt(ume::ume!(use parol_runtime::lexer::Token;))?;
            }
        } else {
            f.write_fmt(ume::ume!(use crate::#module_name::#user_type_name;))?;
        }
        if !*ast_type_has_lifetime {
            f.write_fmt(ume::ume!(use std::marker::PhantomData;))?;
        }
        f.write_fmt(ume::ume!{
            use parol_runtime::id_tree::Tree;
            use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};
            #[allow(unused_imports)]
            use parol_runtime::miette::{miette, Result};
        })?;

        let trait_name = format!("{}Trait", user_type_name);
        if *auto_generate {
            let lifetime = if *ast_type_has_lifetime { "<'t>" } else { "" };
            let auto_name = format!("{}Auto", user_type_name);
            f.write_fmt(ume::ume! {
                /// Semantic actions trait generated for the user grammar
                /// All functions have default implementations.
                pub trait #trait_name #lifetime {
                    #user_trait_functions
                }
            })?;

            write!(f, "
                // -------------------------------------------------------------------------------------------------
                //
                // Output Types of productions deduced from the structure of the transformed grammar
                //

                {production_output_types}

                // -------------------------------------------------------------------------------------------------
                //
                // Types of non-terminals deduced from the structure of the transformed grammar
                //

                {non_terminal_types}

                // -------------------------------------------------------------------------------------------------

                {ast_type_decl}
                ")?;

            let phantom_data_field = if *ast_type_has_lifetime {
                "".into()
            } else {
                ume::ume! {
                    // Just to hold the lifetime generated by parol
                    phantom: PhantomData<&'t str>,
                }.to_string()
            };
            f.write_fmt(ume::ume! {
                /// Auto-implemented adapter grammar
                ///
                /// The lifetime parameter `'t` refers to the lifetime of the scanned text.
                /// The lifetime parameter `'u` refers to the lifetime of user grammar object.
                ///
                #[allow(dead_code)]
                pub struct #auto_name<'t, 'u> where 't: 'u {
                    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
                    user_grammar: &'u mut dyn #trait_name #lifetime,
                    // Stack to construct the AST on it
                    item_stack: Vec<ASTType #lifetime>,
                    #phantom_data_field
                }
            })?;

            let phantom_data_field_default = if *ast_type_has_lifetime {
                "".into()
            } else {
                ume::ume! {
                    phantom: PhantomData::default(),
                }.to_string()
            };
            f.write_fmt(ume::ume! {
                ///
                /// The `{{{user_type_name}}}Auto` impl is automatically generated for the
                /// given grammar.
                ///
                impl<'t, 'u> #auto_name<'t, 'u> {
                    pub fn new(user_grammar: &'u mut dyn #trait_name #lifetime) -> Self {
                        Self {
                            user_grammar,
                            item_stack: Vec::new(),
                            #phantom_data_field_default
                        }
                    }

                    #[allow(dead_code)]
                    fn push(&mut self, item: ASTType #lifetime, context: &str) {
                        trace!("push    {}: {:?}", context, item);
                        self.item_stack.push(item)
                    }

                    #[allow(dead_code)]
                    fn pop(&mut self, context: &str) -> Option<ASTType #lifetime> {
                        if !self.item_stack.is_empty() {
                            let item = self.item_stack.pop();
                            if let Some(ref item) = item {
                                trace!("pop     {}: {:?}", context, item);
                            }
                            item
                        } else {
                            None
                        }
                    }

                    #[allow(dead_code)]
                    // Use this function for debugging purposes:
                    // trace!("{}", self.trace_item_stack(context));
                    fn trace_item_stack(&self, context: &str) -> std::string::String {
                        format!(
                            "Item stack at {}:\n{}",
                            context,
                            self.item_stack
                                .iter()
                                .rev()
                                .map(|s| format!("  {:?}", s))
                                .collect::<Vec<std::string::String>>()
                                .join("\n")
                        )
                    }

                    #trait_functions
                }
            })?;

            f.write_fmt(ume::ume! {
                impl<'t> UserActionsTrait<'t> for #auto_name<'t, '_> {
                    ///
                    /// This function is implemented automatically for the user's item {{{user_type_name}}}.
                    ///
                    fn call_semantic_action_for_production_number(
                        &mut self,
                        prod_num: usize,
                        children: &[ParseTreeStackEntry<'t>],
                        parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
                        match prod_num {
                            #trait_caller
                            _ => Err(miette!("Unhandled production number: {}", prod_num)),
                        }
                    }
                }
            })?;
        } else {
            f.write_fmt(ume::ume! {
                ///
                /// The `{{{user_type_name}}}Trait` trait is automatically generated for the
                /// given grammar.
                /// All functions have default implementations.
                ///
                pub trait #trait_name {
                    #trait_functions
                }

                impl UserActionsTrait<'_> for #user_type_name {
                    ///
                    /// This function is implemented automatically for the user's item {{{user_type_name}}}.
                    ///
                    fn call_semantic_action_for_production_number(
                        &mut self,
                        prod_num: usize,
                        children: &[ParseTreeStackEntry],
                        parse_tree: &Tree<ParseTreeType>) -> Result<()> {
                        match prod_num {
                            #trait_caller
                            _ => Err(miette!("Unhandled production number: {}", prod_num)),
                        }
                    }
                }
            })?;
        }
        Ok(())
    }
}

#[derive(BartDisplay, Debug, Default)]
#[template = "templates/non_terminal_type_struct_template.rs.tpl"]
pub(crate) struct NonTerminalTypeStruct {
    pub comment: StrVec,
    pub type_name: String,
    pub lifetime: String,
    pub members: StrVec,
}

#[derive(BartDisplay, Debug, Default)]
#[template = "templates/non_terminal_type_enum_template.rs.tpl"]
pub(crate) struct NonTerminalTypeEnum {
    pub comment: StrVec,
    pub type_name: String,
    pub lifetime: String,
    pub members: StrVec,
}

#[derive(Debug, Default)]
pub(crate) struct NonTerminalTypeVec {
    pub comment: StrVec,
    pub non_terminal: String,
    pub lifetime: String,
    pub type_ref: String,
}

impl std::fmt::Display for NonTerminalTypeVec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let NonTerminalTypeVec {
            comment,
            non_terminal,
            lifetime,
            type_ref,
        } = self;
        for comment in comment {
            write!(f, "/// {}", comment)?
        }
        f.write_fmt(ume::ume! {
            #[allow(dead_code)]
            #[derive(Builder, Debug, Clone)]
            #[builder(crate = "parol_runtime::derive_builder")]
            pub struct #non_terminal {
                vec: Vec<#type_ref #lifetime>
            }
        })
    }
}

#[derive(Builder, Debug, Default)]
pub(crate) struct RangeCalculation {
    pub type_name: String,
    pub lifetime: String,
    #[builder(default)]
    pub code: StrVec,
}

impl std::fmt::Display for RangeCalculation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let RangeCalculation {
            type_name,
            lifetime,
            code,
        } = self;
        f.write_fmt(ume::ume! {
            impl #lifetime ToSpan for #type_name #lifetime {
                fn span(&self) -> Span {
                    #code
                }
            }
        })
    }
}

#[derive(Builder, Debug, Default)]
pub(crate) struct EnumRangeCalc {
    #[builder(default)]
    pub enum_variants: StrVec,
}

impl std::fmt::Display for EnumRangeCalc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let EnumRangeCalc { enum_variants } = self;
        f.write_fmt(ume::ume! {
            match self {
                #enum_variants
            }
        })
    }
}
