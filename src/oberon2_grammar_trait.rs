// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

#[allow(unused_imports)]
use crate::oberon2_grammar::Oberon2Grammar;
use id_tree::Tree;
use log::trace;
use miette::{bail, miette, IntoDiagnostic, Result};
use parol_runtime::lexer::Token;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};
use std::path::{Path, PathBuf};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait Oberon2GrammarTrait<'t> {
    fn init(&mut self, _file_name: &Path) {}

    /// Semantic action for non-terminal 'BEGIN'
    fn b_e_g_i_n(&mut self, _arg: &BEGIN<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CASE'
    fn c_a_s_e(&mut self, _arg: &CASE<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DO'
    fn d_o(&mut self, _arg: &DO<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ELSE'
    fn e_l_s_e(&mut self, _arg: &ELSE<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ELSIF'
    fn e_l_s_i_f(&mut self, _arg: &ELSIF<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'END'
    fn e_n_d(&mut self, _arg: &END<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IF'
    fn i_f(&mut self, _arg: &IF<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OF'
    fn o_f(&mut self, _arg: &OF<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PROCEDURE'
    fn p_r_o_c_e_d_u_r_e(&mut self, _arg: &PROCEDURE<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'THEN'
    fn t_h_e_n(&mut self, _arg: &THEN<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TO'
    fn t_o(&mut self, _arg: &TO<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VAR'
    fn v_a_r(&mut self, _arg: &VAR<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Oberon2'
    fn oberon2(&mut self, _arg: &Oberon2<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ImportList'
    fn import_list(&mut self, _arg: &ImportList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DeclSeq'
    fn decl_seq(&mut self, _arg: &DeclSeq<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstDecl'
    fn const_decl(&mut self, _arg: &ConstDecl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeDecl'
    fn type_decl(&mut self, _arg: &TypeDecl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VarDecl'
    fn var_decl(&mut self, _arg: &VarDecl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProcDecl'
    fn proc_decl(&mut self, _arg: &ProcDecl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ForwardDecl'
    fn forward_decl(&mut self, _arg: &ForwardDecl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FormalPars'
    fn formal_pars(&mut self, _arg: &FormalPars<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FPSection'
    fn f_p_section(&mut self, _arg: &FPSection<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Receiver'
    fn receiver(&mut self, _arg: &Receiver<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeDef'
    fn type_def(&mut self, _arg: &TypeDef<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FieldList'
    fn field_list(&mut self, _arg: &FieldList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StatementSeq'
    fn statement_seq(&mut self, _arg: &StatementSeq<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Statement'
    fn statement(&mut self, _arg: &Statement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Case'
    fn case(&mut self, _arg: &Case<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaseLabels'
    fn case_labels(&mut self, _arg: &CaseLabels<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Guard'
    fn guard(&mut self, _arg: &Guard<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstExpr'
    fn const_expr(&mut self, _arg: &ConstExpr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expr'
    fn expr(&mut self, _arg: &Expr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SimpleExpr'
    fn simple_expr(&mut self, _arg: &SimpleExpr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Term'
    fn term(&mut self, _arg: &Term<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Factor'
    fn factor(&mut self, _arg: &Factor<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Set'
    fn set(&mut self, _arg: &Set<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Element'
    fn element(&mut self, _arg: &Element<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Relation'
    fn relation(&mut self, _arg: &Relation<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AddOp'
    fn add_op(&mut self, _arg: &AddOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MulOp'
    fn mul_op(&mut self, _arg: &MulOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Designator'
    fn designator(&mut self, _arg: &Designator<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DesignatorSuffix'
    fn designator_suffix(&mut self, _arg: &DesignatorSuffix<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExprList'
    fn expr_list(&mut self, _arg: &ExprList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentList'
    fn ident_list(&mut self, _arg: &IdentList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QualIdent'
    fn qual_ident(&mut self, _arg: &QualIdent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentDef'
    fn ident_def(&mut self, _arg: &IdentDef<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Number'
    fn number(&mut self, _arg: &Number<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Real'
    fn real(&mut self, _arg: &Real<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Character'
    fn character(&mut self, _arg: &Character<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Integer'
    fn integer(&mut self, _arg: &Integer<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QIdent'
    fn q_ident(&mut self, _arg: &QIdent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ident'
    fn ident(&mut self, _arg: &Ident<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'String'
    fn string(&mut self, _arg: &String<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 26
///
/// DeclSeqList0Group: ProcDecl ";";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclSeqList0Group0<'t> {
    pub proc_decl: Box<ProcDecl<'t>>,
    pub semicolon: Token<'t>, /* ; */
}

///
/// Type derived for production 27
///
/// DeclSeqList0Group: ForwardDecl ";";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclSeqList0Group1<'t> {
    pub forward_decl: Box<ForwardDecl<'t>>,
    pub semicolon: Token<'t>, /* ; */
}

///
/// Type derived for production 30
///
/// DeclSeqListGroup: "CONST" DeclSeqListGroupList /* Vec */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclSeqListGroup0<'t> {
    pub c_o_n_s_t: Token<'t>, /* CONST */
    pub decl_seq_list_group_list: Vec<DeclSeqListGroupList<'t>>,
}

///
/// Type derived for production 33
///
/// DeclSeqListGroup: "TYPE" DeclSeqListGroupList0 /* Vec */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclSeqListGroup1<'t> {
    pub t_y_p_e: Token<'t>, /* TYPE */
    pub decl_seq_list_group_list0: Vec<DeclSeqListGroupList0<'t>>,
}

///
/// Type derived for production 36
///
/// DeclSeqListGroup: VAR DeclSeqListGroupList1 /* Vec */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclSeqListGroup2<'t> {
    pub v_a_r: Box<VAR<'t>>,
    pub decl_seq_list_group_list1: Vec<DeclSeqListGroupList1<'t>>,
}

///
/// Type derived for production 70
///
/// TypeDef: QualIdent;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDef0<'t> {
    pub qual_ident: Box<QualIdent<'t>>,
}

///
/// Type derived for production 71
///
/// TypeDef: "ARRAY" TypeDefOpt /* Option */ OF TypeDef;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDef1<'t> {
    pub a_r_r_a_y: Token<'t>, /* ARRAY */
    pub type_def_opt: Option<Box<TypeDefOpt<'t>>>,
    pub o_f: Box<OF<'t>>,
    pub type_def: Box<TypeDef<'t>>,
}

///
/// Type derived for production 72
///
/// TypeDef: "RECORD" TypeDefOpt0 /* Option */ FieldList TypeDefList /* Vec */ END;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDef2<'t> {
    pub r_e_c_o_r_d: Token<'t>, /* RECORD */
    pub type_def_opt0: Option<Box<TypeDefOpt0<'t>>>,
    pub field_list: Box<FieldList<'t>>,
    pub type_def_list: Vec<TypeDefList<'t>>,
    pub e_n_d: Box<END<'t>>,
}

///
/// Type derived for production 75
///
/// TypeDef: "POINTER" TO TypeDef;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDef3<'t> {
    pub p_o_i_n_t_e_r: Token<'t>, /* POINTER */
    pub t_o: Box<TO<'t>>,
    pub type_def: Box<TypeDef<'t>>,
}

///
/// Type derived for production 76
///
/// TypeDef: PROCEDURE TypeDefOpt1 /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDef4<'t> {
    pub p_r_o_c_e_d_u_r_e: Box<PROCEDURE<'t>>,
    pub type_def_opt1: Option<Box<TypeDefOpt1<'t>>>,
}

///
/// Type derived for production 91
///
/// Statement: Designator StatementSuffix;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement0<'t> {
    pub designator: Box<Designator<'t>>,
    pub statement_suffix: Box<StatementSuffix<'t>>,
}

///
/// Type derived for production 92
///
/// StatementSuffix: ":=" Expr;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementSuffix0<'t> {
    pub colon_equ: Token<'t>, /* := */
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for production 93
///
/// StatementSuffix: StatementOpt /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementSuffix1<'t> {
    pub statement_opt: Option<Box<StatementOpt<'t>>>,
}

///
/// Type derived for production 94
///
/// Statement: IF Expr THEN StatementSeq StatementList /* Vec */ StatementOpt0 /* Option */ END;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement1<'t> {
    pub i_f: Box<IF<'t>>,
    pub expr: Box<Expr<'t>>,
    pub t_h_e_n: Box<THEN<'t>>,
    pub statement_seq: Box<StatementSeq<'t>>,
    pub statement_list: Vec<StatementList<'t>>,
    pub statement_opt0: Option<Box<StatementOpt0<'t>>>,
    pub e_n_d: Box<END<'t>>,
}

///
/// Type derived for production 95
///
/// Statement: CASE Expr OF Case StatementList0 /* Vec */ StatementOpt1 /* Option */ END;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement2<'t> {
    pub c_a_s_e: Box<CASE<'t>>,
    pub expr: Box<Expr<'t>>,
    pub o_f: Box<OF<'t>>,
    pub case: Box<Case<'t>>,
    pub statement_list0: Vec<StatementList0<'t>>,
    pub statement_opt1: Option<Box<StatementOpt1<'t>>>,
    pub e_n_d: Box<END<'t>>,
}

///
/// Type derived for production 96
///
/// Statement: "WHILE" Expr DO StatementSeq END;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement3<'t> {
    pub w_h_i_l_e: Token<'t>, /* WHILE */
    pub expr: Box<Expr<'t>>,
    pub d_o: Box<DO<'t>>,
    pub statement_seq: Box<StatementSeq<'t>>,
    pub e_n_d: Box<END<'t>>,
}

///
/// Type derived for production 97
///
/// Statement: "REPEAT" StatementSeq "UNTIL" Expr;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement4<'t> {
    pub r_e_p_e_a_t: Token<'t>, /* REPEAT */
    pub statement_seq: Box<StatementSeq<'t>>,
    pub u_n_t_i_l: Token<'t>, /* UNTIL */
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for production 98
///
/// Statement: "FOR" Ident ":=" Expr TO Expr StatementOpt2 /* Option */ DO StatementSeq END;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement5<'t> {
    pub f_o_r: Token<'t>, /* FOR */
    pub ident: Box<Ident<'t>>,
    pub colon_equ: Token<'t>, /* := */
    pub expr: Box<Expr<'t>>,
    pub t_o: Box<TO<'t>>,
    pub expr0: Box<Expr<'t>>,
    pub statement_opt2: Option<Box<StatementOpt2<'t>>>,
    pub d_o: Box<DO<'t>>,
    pub statement_seq: Box<StatementSeq<'t>>,
    pub e_n_d: Box<END<'t>>,
}

///
/// Type derived for production 99
///
/// Statement: "LOOP" StatementSeq END;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement6<'t> {
    pub l_o_o_p: Token<'t>, /* LOOP */
    pub statement_seq: Box<StatementSeq<'t>>,
    pub e_n_d: Box<END<'t>>,
}

///
/// Type derived for production 100
///
/// Statement: "WITH" Guard DO StatementSeq StatementList1 /* Vec */ StatementOpt3 /* Option */ END;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement7<'t> {
    pub w_i_t_h: Token<'t>, /* WITH */
    pub guard: Box<Guard<'t>>,
    pub d_o: Box<DO<'t>>,
    pub statement_seq: Box<StatementSeq<'t>>,
    pub statement_list1: Vec<StatementList1<'t>>,
    pub statement_opt3: Option<Box<StatementOpt3<'t>>>,
    pub e_n_d: Box<END<'t>>,
}

///
/// Type derived for production 101
///
/// Statement: "EXIT";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement8<'t> {
    pub e_x_i_t: Token<'t>, /* EXIT */
}

///
/// Type derived for production 102
///
/// Statement: "RETURN" StatementOpt4 /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement9<'t> {
    pub r_e_t_u_r_n: Token<'t>, /* RETURN */
    pub statement_opt4: Option<Box<StatementOpt4<'t>>>,
}

///
/// Type derived for production 103
///
/// Statement: ";";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement10<'t> {
    pub semicolon: Token<'t>, /* ; */
}

///
/// Type derived for production 141
///
/// SimpleExprOptGroup: "\+";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SimpleExprOptGroup0<'t> {
    pub plus: Token<'t>, /* \+ */
}

///
/// Type derived for production 142
///
/// SimpleExprOptGroup: "-";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SimpleExprOptGroup1<'t> {
    pub minus: Token<'t>, /* - */
}

///
/// Type derived for production 147
///
/// Factor: Designator FactorOpt /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor0<'t> {
    pub designator: Box<Designator<'t>>,
    pub factor_opt: Option<Box<FactorOpt<'t>>>,
}

///
/// Type derived for production 148
///
/// Factor: Number;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor1<'t> {
    pub number: Box<Number<'t>>,
}

///
/// Type derived for production 149
///
/// Factor: Character;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor2<'t> {
    pub character: Box<Character<'t>>,
}

///
/// Type derived for production 150
///
/// Factor: String;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor3<'t> {
    pub string: Box<String<'t>>,
}

///
/// Type derived for production 151
///
/// Factor: "NIL";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor4<'t> {
    pub n_i_l: Token<'t>, /* NIL */
}

///
/// Type derived for production 152
///
/// Factor: Set;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor5<'t> {
    pub set: Box<Set<'t>>,
}

///
/// Type derived for production 153
///
/// Factor: "\(" Expr "\)";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor6<'t> {
    pub l_paren: Token<'t>, /* \( */
    pub expr: Box<Expr<'t>>,
    pub r_paren: Token<'t>, /* \) */
}

///
/// Type derived for production 154
///
/// Factor: "~" Factor;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor7<'t> {
    pub tilde: Token<'t>, /* ~ */
    pub factor: Box<Factor<'t>>,
}

///
/// Type derived for production 167
///
/// Relation: "=";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relation0<'t> {
    pub equ: Token<'t>, /* = */
}

///
/// Type derived for production 168
///
/// Relation: "#";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relation1<'t> {
    pub hash: Token<'t>, /* # */
}

///
/// Type derived for production 169
///
/// Relation: "<";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relation2<'t> {
    pub l_t: Token<'t>, /* < */
}

///
/// Type derived for production 170
///
/// Relation: "<=";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relation3<'t> {
    pub l_t_equ: Token<'t>, /* <= */
}

///
/// Type derived for production 171
///
/// Relation: ">";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relation4<'t> {
    pub g_t: Token<'t>, /* > */
}

///
/// Type derived for production 172
///
/// Relation: ">=";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relation5<'t> {
    pub g_t_equ: Token<'t>, /* >= */
}

///
/// Type derived for production 173
///
/// Relation: "IN";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relation6<'t> {
    pub i_n: Token<'t>, /* IN */
}

///
/// Type derived for production 174
///
/// Relation: "IS";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relation7<'t> {
    pub i_s: Token<'t>, /* IS */
}

///
/// Type derived for production 175
///
/// AddOp: "\+";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AddOp0<'t> {
    pub plus: Token<'t>, /* \+ */
}

///
/// Type derived for production 176
///
/// AddOp: "-";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AddOp1<'t> {
    pub minus: Token<'t>, /* - */
}

///
/// Type derived for production 177
///
/// AddOp: "OR";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AddOp2<'t> {
    pub o_r: Token<'t>, /* OR */
}

///
/// Type derived for production 178
///
/// MulOp: "\*";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MulOp0<'t> {
    pub star: Token<'t>, /* \* */
}

///
/// Type derived for production 179
///
/// MulOp: "/";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MulOp1<'t> {
    pub slash: Token<'t>, /* / */
}

///
/// Type derived for production 180
///
/// MulOp: "DIV";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MulOp2<'t> {
    pub d_i_v: Token<'t>, /* DIV */
}

///
/// Type derived for production 181
///
/// MulOp: "MOD";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MulOp3<'t> {
    pub m_o_d: Token<'t>, /* MOD */
}

///
/// Type derived for production 182
///
/// MulOp: "&";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MulOp4<'t> {
    pub amp: Token<'t>, /* & */
}

///
/// Type derived for production 186
///
/// DesignatorSuffix: "\." Ident;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DesignatorSuffix0<'t> {
    pub dot: Token<'t>, /* \. */
    pub ident: Box<Ident<'t>>,
}

///
/// Type derived for production 187
///
/// DesignatorSuffix: "\[" ExprList "\]";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DesignatorSuffix1<'t> {
    pub l_bracket: Token<'t>, /* \[ */
    pub expr_list: Box<ExprList<'t>>,
    pub r_bracket: Token<'t>, /* \] */
}

///
/// Type derived for production 188
///
/// DesignatorSuffix: "\^";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DesignatorSuffix2<'t> {
    pub circumflex: Token<'t>, /* \^ */
}

///
/// Type derived for production 195
///
/// QualIdent: Ident;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct QualIdent0<'t> {
    pub ident: Box<Ident<'t>>,
}

///
/// Type derived for production 196
///
/// QualIdent: QIdent;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct QualIdent1<'t> {
    pub q_ident: Box<QIdent<'t>>,
}

///
/// Type derived for production 199
///
/// IdentDefOptGroup: "\*";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IdentDefOptGroup0<'t> {
    pub star: Token<'t>, /* \* */
}

///
/// Type derived for production 200
///
/// IdentDefOptGroup: "-";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IdentDefOptGroup1<'t> {
    pub minus: Token<'t>, /* - */
}

///
/// Type derived for production 202
///
/// Number: Integer;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number0<'t> {
    pub integer: Box<Integer<'t>>,
}

///
/// Type derived for production 203
///
/// Number: Real;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number1<'t> {
    pub real: Box<Real<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal AddOp
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AddOp<'t> {
    AddOp0(AddOp0<'t>),
    AddOp1(AddOp1<'t>),
    AddOp2(AddOp2<'t>),
}

///
/// Type derived for non-terminal BEGIN
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BEGIN<'t> {
    pub b_e_g_i_n: Token<'t>, /* BEGIN */
}

///
/// Type derived for non-terminal CASE
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CASE<'t> {
    pub c_a_s_e: Token<'t>, /* CASE */
}

///
/// Type derived for non-terminal Case
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Case<'t> {
    pub case_opt: Option<Box<CaseOpt<'t>>>,
}

///
/// Type derived for non-terminal CaseLabels
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CaseLabels<'t> {
    pub const_expr: Box<ConstExpr<'t>>,
    pub case_labels_opt: Option<Box<CaseLabelsOpt<'t>>>,
}

///
/// Type derived for non-terminal CaseLabelsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CaseLabelsOpt<'t> {
    pub dot_dot: Token<'t>, /* \.\. */
    pub const_expr: Box<ConstExpr<'t>>,
}

///
/// Type derived for non-terminal CaseOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CaseOpt<'t> {
    pub case_labels: Box<CaseLabels<'t>>,
    pub case_opt_list: Vec<CaseOptList<'t>>,
    pub colon: Token<'t>, /* : */
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal CaseOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CaseOptList<'t> {
    pub comma: Token<'t>, /* , */
    pub case_labels: Box<CaseLabels<'t>>,
}

///
/// Type derived for non-terminal Character
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Character<'t> {
    pub character: Token<'t>, /* [0-9][0-9A-F]*X */
}

///
/// Type derived for non-terminal ConstDecl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ConstDecl<'t> {
    pub ident_def: Box<IdentDef<'t>>,
    pub equ: Token<'t>, /* = */
    pub const_expr: Box<ConstExpr<'t>>,
}

///
/// Type derived for non-terminal ConstExpr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ConstExpr<'t> {
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for non-terminal DO
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DO<'t> {
    pub d_o: Token<'t>, /* DO */
}

///
/// Type derived for non-terminal DeclSeq
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclSeq<'t> {
    pub decl_seq_list: Vec<DeclSeqList<'t>>,
    pub decl_seq_list0: Vec<DeclSeqList0<'t>>,
}

///
/// Type derived for non-terminal DeclSeqList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclSeqList<'t> {
    pub decl_seq_list_group: Box<DeclSeqListGroup<'t>>,
}

///
/// Type derived for non-terminal DeclSeqList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclSeqList0<'t> {
    pub decl_seq_list0_group: Box<DeclSeqList0Group<'t>>,
}

///
/// Type derived for non-terminal DeclSeqList0Group
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DeclSeqList0Group<'t> {
    DeclSeqList0Group0(DeclSeqList0Group0<'t>),
    DeclSeqList0Group1(DeclSeqList0Group1<'t>),
}

///
/// Type derived for non-terminal DeclSeqListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DeclSeqListGroup<'t> {
    DeclSeqListGroup0(DeclSeqListGroup0<'t>),
    DeclSeqListGroup1(DeclSeqListGroup1<'t>),
    DeclSeqListGroup2(DeclSeqListGroup2<'t>),
}

///
/// Type derived for non-terminal DeclSeqListGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclSeqListGroupList<'t> {
    pub const_decl: Box<ConstDecl<'t>>,
    pub semicolon: Token<'t>, /* ; */
}

///
/// Type derived for non-terminal DeclSeqListGroupList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclSeqListGroupList0<'t> {
    pub type_decl: Box<TypeDecl<'t>>,
    pub semicolon: Token<'t>, /* ; */
}

///
/// Type derived for non-terminal DeclSeqListGroupList1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DeclSeqListGroupList1<'t> {
    pub var_decl: Box<VarDecl<'t>>,
    pub semicolon: Token<'t>, /* ; */
}

///
/// Type derived for non-terminal Designator
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Designator<'t> {
    pub qual_ident: Box<QualIdent<'t>>,
    pub designator_list: Vec<DesignatorList<'t>>,
}

///
/// Type derived for non-terminal DesignatorList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DesignatorList<'t> {
    pub designator_suffix: Box<DesignatorSuffix<'t>>,
}

///
/// Type derived for non-terminal DesignatorSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DesignatorSuffix<'t> {
    DesignatorSuffix0(DesignatorSuffix0<'t>),
    DesignatorSuffix1(DesignatorSuffix1<'t>),
    DesignatorSuffix2(DesignatorSuffix2<'t>),
}

///
/// Type derived for non-terminal ELSE
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ELSE<'t> {
    pub e_l_s_e: Token<'t>, /* ELSE */
}

///
/// Type derived for non-terminal ELSIF
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ELSIF<'t> {
    pub e_l_s_i_f: Token<'t>, /* ELSIF */
}

///
/// Type derived for non-terminal END
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct END<'t> {
    pub e_n_d: Token<'t>, /* END */
}

///
/// Type derived for non-terminal Element
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Element<'t> {
    pub expr: Box<Expr<'t>>,
    pub element_opt: Option<Box<ElementOpt<'t>>>,
}

///
/// Type derived for non-terminal ElementOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ElementOpt<'t> {
    pub dot_dot: Token<'t>, /* \.\. */
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for non-terminal Expr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expr<'t> {
    pub simple_expr: Box<SimpleExpr<'t>>,
    pub expr_opt: Option<Box<ExprOpt<'t>>>,
}

///
/// Type derived for non-terminal ExprList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ExprList<'t> {
    pub expr: Box<Expr<'t>>,
    pub expr_list_list: Vec<ExprListList<'t>>,
}

///
/// Type derived for non-terminal ExprListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ExprListList<'t> {
    pub comma: Token<'t>, /* , */
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for non-terminal ExprOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ExprOpt<'t> {
    pub relation: Box<Relation<'t>>,
    pub simple_expr: Box<SimpleExpr<'t>>,
}

///
/// Type derived for non-terminal FPSection
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FPSection<'t> {
    pub f_p_section_opt: Option<Box<FPSectionOpt<'t>>>,
    pub ident: Box<Ident<'t>>,
    pub f_p_section_list: Vec<FPSectionList<'t>>,
    pub colon: Token<'t>, /* : */
    pub type_def: Box<TypeDef<'t>>,
}

///
/// Type derived for non-terminal FPSectionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FPSectionList<'t> {
    pub comma: Token<'t>, /* , */
    pub ident: Box<Ident<'t>>,
}

///
/// Type derived for non-terminal FPSectionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FPSectionOpt<'t> {
    pub v_a_r: Box<VAR<'t>>,
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor<'t> {
    Factor0(Factor0<'t>),
    Factor1(Factor1<'t>),
    Factor2(Factor2<'t>),
    Factor3(Factor3<'t>),
    Factor4(Factor4<'t>),
    Factor5(Factor5<'t>),
    Factor6(Factor6<'t>),
    Factor7(Factor7<'t>),
}

///
/// Type derived for non-terminal FactorOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FactorOpt<'t> {
    pub l_paren: Token<'t>, /* \( */
    pub factor_opt0: Option<Box<FactorOpt0<'t>>>,
    pub r_paren: Token<'t>, /* \) */
}

///
/// Type derived for non-terminal FactorOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FactorOpt0<'t> {
    pub expr_list: Box<ExprList<'t>>,
}

///
/// Type derived for non-terminal FieldList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FieldList<'t> {
    pub field_list_opt: Option<Box<FieldListOpt<'t>>>,
}

///
/// Type derived for non-terminal FieldListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FieldListOpt<'t> {
    pub ident_list: Box<IdentList<'t>>,
    pub colon: Token<'t>, /* : */
    pub type_def: Box<TypeDef<'t>>,
}

///
/// Type derived for non-terminal FormalPars
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FormalPars<'t> {
    pub l_paren: Token<'t>, /* \( */
    pub formal_pars_opt: Option<Box<FormalParsOpt<'t>>>,
    pub r_paren: Token<'t>, /* \) */
    pub formal_pars_opt0: Option<Box<FormalParsOpt0<'t>>>,
}

///
/// Type derived for non-terminal FormalParsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FormalParsOpt<'t> {
    pub f_p_section: Box<FPSection<'t>>,
    pub formal_pars_opt_list: Vec<FormalParsOptList<'t>>,
}

///
/// Type derived for non-terminal FormalParsOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FormalParsOpt0<'t> {
    pub colon: Token<'t>, /* : */
    pub qual_ident: Box<QualIdent<'t>>,
}

///
/// Type derived for non-terminal FormalParsOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FormalParsOptList<'t> {
    pub semicolon: Token<'t>, /* ; */
    pub f_p_section: Box<FPSection<'t>>,
}

///
/// Type derived for non-terminal ForwardDecl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ForwardDecl<'t> {
    pub p_r_o_c_e_d_u_r_e: Box<PROCEDURE<'t>>,
    pub circumflex: Token<'t>, /* \^ */
    pub forward_decl_opt: Option<Box<ForwardDeclOpt<'t>>>,
    pub ident_def: Box<IdentDef<'t>>,
    pub forward_decl_opt0: Option<Box<ForwardDeclOpt0<'t>>>,
}

///
/// Type derived for non-terminal ForwardDeclOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ForwardDeclOpt<'t> {
    pub receiver: Box<Receiver<'t>>,
}

///
/// Type derived for non-terminal ForwardDeclOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ForwardDeclOpt0<'t> {
    pub formal_pars: Box<FormalPars<'t>>,
}

///
/// Type derived for non-terminal Guard
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Guard<'t> {
    pub qual_ident: Box<QualIdent<'t>>,
    pub colon: Token<'t>, /* : */
    pub qual_ident0: Box<QualIdent<'t>>,
}

///
/// Type derived for non-terminal IF
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IF<'t> {
    pub i_f: Token<'t>, /* IF */
}

///
/// Type derived for non-terminal Ident
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Ident<'t> {
    pub ident: Token<'t>, /* [a-zA-Z_]\w* */
}

///
/// Type derived for non-terminal IdentDef
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IdentDef<'t> {
    pub ident: Box<Ident<'t>>,
    pub ident_def_opt: Option<Box<IdentDefOpt<'t>>>,
}

///
/// Type derived for non-terminal IdentDefOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IdentDefOpt<'t> {
    pub ident_def_opt_group: Box<IdentDefOptGroup<'t>>,
}

///
/// Type derived for non-terminal IdentDefOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IdentDefOptGroup<'t> {
    IdentDefOptGroup0(IdentDefOptGroup0<'t>),
    IdentDefOptGroup1(IdentDefOptGroup1<'t>),
}

///
/// Type derived for non-terminal IdentList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IdentList<'t> {
    pub ident_def: Box<IdentDef<'t>>,
    pub ident_list_list: Vec<IdentListList<'t>>,
}

///
/// Type derived for non-terminal IdentListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IdentListList<'t> {
    pub comma: Token<'t>, /* , */
    pub ident_def: Box<IdentDef<'t>>,
}

///
/// Type derived for non-terminal ImportList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ImportList<'t> {
    pub i_m_p_o_r_t: Token<'t>, /* IMPORT */
    pub import_list_opt: Option<Box<ImportListOpt<'t>>>,
    pub ident: Box<Ident<'t>>,
    pub import_list_list: Vec<ImportListList<'t>>,
    pub semicolon: Token<'t>, /* ; */
}

///
/// Type derived for non-terminal ImportListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ImportListList<'t> {
    pub comma: Token<'t>, /* , */
    pub import_list_opt0: Option<Box<ImportListOpt0<'t>>>,
    pub ident: Box<Ident<'t>>,
}

///
/// Type derived for non-terminal ImportListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ImportListOpt<'t> {
    pub ident: Box<Ident<'t>>,
    pub colon_equ: Token<'t>, /* := */
}

///
/// Type derived for non-terminal ImportListOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ImportListOpt0<'t> {
    pub ident: Box<Ident<'t>>,
    pub colon_equ: Token<'t>, /* := */
}

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Integer<'t> {
    pub integer: Token<'t>, /* [0-9][0-9]*|[0-9][0-9A-F]*H */
}

///
/// Type derived for non-terminal MulOp
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MulOp<'t> {
    MulOp0(MulOp0<'t>),
    MulOp1(MulOp1<'t>),
    MulOp2(MulOp2<'t>),
    MulOp3(MulOp3<'t>),
    MulOp4(MulOp4<'t>),
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Number<'t> {
    Number0(Number0<'t>),
    Number1(Number1<'t>),
}

///
/// Type derived for non-terminal OF
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OF<'t> {
    pub o_f: Token<'t>, /* OF */
}

///
/// Type derived for non-terminal Oberon2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Oberon2<'t> {
    pub m_o_d_u_l_e: Token<'t>, /* MODULE */
    pub ident: Box<Ident<'t>>,
    pub semicolon: Token<'t>, /* ; */
    pub oberon2_opt: Option<Box<Oberon2Opt<'t>>>,
    pub decl_seq: Box<DeclSeq<'t>>,
    pub oberon2_opt0: Option<Box<Oberon2Opt0<'t>>>,
    pub e_n_d: Box<END<'t>>,
    pub ident0: Box<Ident<'t>>,
    pub dot: Token<'t>, /* \. */
}

///
/// Type derived for non-terminal Oberon2Opt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Oberon2Opt<'t> {
    pub import_list: Box<ImportList<'t>>,
}

///
/// Type derived for non-terminal Oberon2Opt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Oberon2Opt0<'t> {
    pub b_e_g_i_n: Box<BEGIN<'t>>,
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal PROCEDURE
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct PROCEDURE<'t> {
    pub p_r_o_c_e_d_u_r_e: Token<'t>, /* PROCEDURE */
}

///
/// Type derived for non-terminal ProcDecl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ProcDecl<'t> {
    pub p_r_o_c_e_d_u_r_e: Box<PROCEDURE<'t>>,
    pub proc_decl_opt: Option<Box<ProcDeclOpt<'t>>>,
    pub ident_def: Box<IdentDef<'t>>,
    pub proc_decl_opt0: Option<Box<ProcDeclOpt0<'t>>>,
    pub semicolon: Token<'t>, /* ; */
    pub decl_seq: Box<DeclSeq<'t>>,
    pub proc_decl_opt1: Option<Box<ProcDeclOpt1<'t>>>,
    pub e_n_d: Box<END<'t>>,
    pub ident: Box<Ident<'t>>,
}

///
/// Type derived for non-terminal ProcDeclOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ProcDeclOpt<'t> {
    pub receiver: Box<Receiver<'t>>,
}

///
/// Type derived for non-terminal ProcDeclOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ProcDeclOpt0<'t> {
    pub formal_pars: Box<FormalPars<'t>>,
}

///
/// Type derived for non-terminal ProcDeclOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ProcDeclOpt1<'t> {
    pub b_e_g_i_n: Box<BEGIN<'t>>,
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal QIdent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct QIdent<'t> {
    pub q_ident: Token<'t>, /* [a-zA-Z_]\w*\.[a-zA-Z_]\w* */
}

///
/// Type derived for non-terminal QualIdent
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum QualIdent<'t> {
    QualIdent0(QualIdent0<'t>),
    QualIdent1(QualIdent1<'t>),
}

///
/// Type derived for non-terminal Real
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Real<'t> {
    pub real: Token<'t>, /* [0-9][0-9]*\.[0-9]*(ED[+-]?[0-9][0-9]*)? */
}

///
/// Type derived for non-terminal Receiver
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Receiver<'t> {
    pub l_paren: Token<'t>, /* \( */
    pub receiver_opt: Option<Box<ReceiverOpt<'t>>>,
    pub ident: Box<Ident<'t>>,
    pub colon: Token<'t>, /* : */
    pub ident0: Box<Ident<'t>>,
    pub r_paren: Token<'t>, /* \) */
}

///
/// Type derived for non-terminal ReceiverOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ReceiverOpt<'t> {
    pub v_a_r: Box<VAR<'t>>,
}

///
/// Type derived for non-terminal Relation
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Relation<'t> {
    Relation0(Relation0<'t>),
    Relation1(Relation1<'t>),
    Relation2(Relation2<'t>),
    Relation3(Relation3<'t>),
    Relation4(Relation4<'t>),
    Relation5(Relation5<'t>),
    Relation6(Relation6<'t>),
    Relation7(Relation7<'t>),
}

///
/// Type derived for non-terminal Set
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Set<'t> {
    pub l_brace: Token<'t>, /* \{ */
    pub set_opt: Option<Box<SetOpt<'t>>>,
    pub r_brace: Token<'t>, /* \} */
}

///
/// Type derived for non-terminal SetOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SetOpt<'t> {
    pub element: Box<Element<'t>>,
    pub set_opt_list: Vec<SetOptList<'t>>,
}

///
/// Type derived for non-terminal SetOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SetOptList<'t> {
    pub comma: Token<'t>, /* , */
    pub element: Box<Element<'t>>,
}

///
/// Type derived for non-terminal SimpleExpr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SimpleExpr<'t> {
    pub simple_expr_opt: Option<Box<SimpleExprOpt<'t>>>,
    pub term: Box<Term<'t>>,
    pub simple_expr_list: Vec<SimpleExprList<'t>>,
}

///
/// Type derived for non-terminal SimpleExprList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SimpleExprList<'t> {
    pub add_op: Box<AddOp<'t>>,
    pub term: Box<Term<'t>>,
}

///
/// Type derived for non-terminal SimpleExprOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SimpleExprOpt<'t> {
    pub simple_expr_opt_group: Box<SimpleExprOptGroup<'t>>,
}

///
/// Type derived for non-terminal SimpleExprOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SimpleExprOptGroup<'t> {
    SimpleExprOptGroup0(SimpleExprOptGroup0<'t>),
    SimpleExprOptGroup1(SimpleExprOptGroup1<'t>),
}

///
/// Type derived for non-terminal Statement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Statement<'t> {
    Statement0(Statement0<'t>),
    Statement1(Statement1<'t>),
    Statement2(Statement2<'t>),
    Statement3(Statement3<'t>),
    Statement4(Statement4<'t>),
    Statement5(Statement5<'t>),
    Statement6(Statement6<'t>),
    Statement7(Statement7<'t>),
    Statement8(Statement8<'t>),
    Statement9(Statement9<'t>),
    Statement10(Statement10<'t>),
}

///
/// Type derived for non-terminal StatementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementList<'t> {
    pub e_l_s_i_f: Box<ELSIF<'t>>,
    pub expr: Box<Expr<'t>>,
    pub t_h_e_n: Box<THEN<'t>>,
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal StatementList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementList0<'t> {
    pub or: Token<'t>, /* \| */
    pub case: Box<Case<'t>>,
}

///
/// Type derived for non-terminal StatementList1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementList1<'t> {
    pub or: Token<'t>, /* \| */
    pub guard: Box<Guard<'t>>,
    pub d_o: Box<DO<'t>>,
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal StatementOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOpt<'t> {
    pub l_paren: Token<'t>, /* \( */
    pub statement_opt5: Option<Box<StatementOpt5<'t>>>,
    pub r_paren: Token<'t>, /* \) */
}

///
/// Type derived for non-terminal StatementOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOpt0<'t> {
    pub e_l_s_e: Box<ELSE<'t>>,
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal StatementOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOpt1<'t> {
    pub e_l_s_e: Box<ELSE<'t>>,
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal StatementOpt2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOpt2<'t> {
    pub b_y: Token<'t>, /* BY */
    pub const_expr: Box<ConstExpr<'t>>,
}

///
/// Type derived for non-terminal StatementOpt3
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOpt3<'t> {
    pub e_l_s_e: Box<ELSE<'t>>,
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal StatementOpt4
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOpt4<'t> {
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for non-terminal StatementOpt5
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementOpt5<'t> {
    pub expr_list: Box<ExprList<'t>>,
}

///
/// Type derived for non-terminal StatementSeq
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementSeq<'t> {
    pub statement: Box<Statement<'t>>,
    pub statement_seq_list: Vec<StatementSeqList<'t>>,
}

///
/// Type derived for non-terminal StatementSeqList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementSeqList<'t> {
    pub semicolon: Token<'t>, /* ; */
    pub statement: Box<Statement<'t>>,
}

///
/// Type derived for non-terminal StatementSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StatementSuffix<'t> {
    StatementSuffix0(StatementSuffix0<'t>),
    StatementSuffix1(StatementSuffix1<'t>),
}

///
/// Type derived for non-terminal String
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct String<'t> {
    pub string: Token<'t>, /* \u{0022}[^\u{0022}]*\u{0022}|'[^']*' */
}

///
/// Type derived for non-terminal THEN
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct THEN<'t> {
    pub t_h_e_n: Token<'t>, /* THEN */
}

///
/// Type derived for non-terminal TO
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TO<'t> {
    pub t_o: Token<'t>, /* TO */
}

///
/// Type derived for non-terminal Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Term<'t> {
    pub factor: Box<Factor<'t>>,
    pub term_list: Vec<TermList<'t>>,
}

///
/// Type derived for non-terminal TermList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TermList<'t> {
    pub mul_op: Box<MulOp<'t>>,
    pub factor: Box<Factor<'t>>,
}

///
/// Type derived for non-terminal TypeDecl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDecl<'t> {
    pub ident_def: Box<IdentDef<'t>>,
    pub equ: Token<'t>, /* = */
    pub type_def: Box<TypeDef<'t>>,
}

///
/// Type derived for non-terminal TypeDef
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TypeDef<'t> {
    TypeDef0(TypeDef0<'t>),
    TypeDef1(TypeDef1<'t>),
    TypeDef2(TypeDef2<'t>),
    TypeDef3(TypeDef3<'t>),
    TypeDef4(TypeDef4<'t>),
}

///
/// Type derived for non-terminal TypeDefList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDefList<'t> {
    pub semicolon: Token<'t>, /* ; */
    pub field_list: Box<FieldList<'t>>,
}

///
/// Type derived for non-terminal TypeDefOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDefOpt<'t> {
    pub const_expr: Box<ConstExpr<'t>>,
    pub type_def_opt_list: Vec<TypeDefOptList<'t>>,
}

///
/// Type derived for non-terminal TypeDefOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDefOpt0<'t> {
    pub l_paren: Token<'t>, /* \( */
    pub qual_ident: Box<QualIdent<'t>>,
    pub r_paren: Token<'t>, /* \) */
}

///
/// Type derived for non-terminal TypeDefOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDefOpt1<'t> {
    pub formal_pars: Box<FormalPars<'t>>,
}

///
/// Type derived for non-terminal TypeDefOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeDefOptList<'t> {
    pub comma: Token<'t>, /* , */
    pub const_expr: Box<ConstExpr<'t>>,
}

///
/// Type derived for non-terminal VAR
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct VAR<'t> {
    pub v_a_r: Token<'t>, /* VAR */
}

///
/// Type derived for non-terminal VarDecl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct VarDecl<'t> {
    pub ident_list: Box<IdentList<'t>>,
    pub colon: Token<'t>, /* : */
    pub type_def: Box<TypeDef<'t>>,
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    AddOp(AddOp<'t>),
    BEGIN(BEGIN<'t>),
    CASE(CASE<'t>),
    Case(Case<'t>),
    CaseLabels(CaseLabels<'t>),
    CaseLabelsOpt(Option<Box<CaseLabelsOpt<'t>>>),
    CaseOpt(Option<Box<CaseOpt<'t>>>),
    CaseOptList(Vec<CaseOptList<'t>>),
    Character(Character<'t>),
    ConstDecl(ConstDecl<'t>),
    ConstExpr(ConstExpr<'t>),
    DO(DO<'t>),
    DeclSeq(DeclSeq<'t>),
    DeclSeqList(Vec<DeclSeqList<'t>>),
    DeclSeqList0(Vec<DeclSeqList0<'t>>),
    DeclSeqList0Group(DeclSeqList0Group<'t>),
    DeclSeqListGroup(DeclSeqListGroup<'t>),
    DeclSeqListGroupList(Vec<DeclSeqListGroupList<'t>>),
    DeclSeqListGroupList0(Vec<DeclSeqListGroupList0<'t>>),
    DeclSeqListGroupList1(Vec<DeclSeqListGroupList1<'t>>),
    Designator(Designator<'t>),
    DesignatorList(Vec<DesignatorList<'t>>),
    DesignatorSuffix(DesignatorSuffix<'t>),
    ELSE(ELSE<'t>),
    ELSIF(ELSIF<'t>),
    END(END<'t>),
    Element(Element<'t>),
    ElementOpt(Option<Box<ElementOpt<'t>>>),
    Expr(Expr<'t>),
    ExprList(ExprList<'t>),
    ExprListList(Vec<ExprListList<'t>>),
    ExprOpt(Option<Box<ExprOpt<'t>>>),
    FPSection(FPSection<'t>),
    FPSectionList(Vec<FPSectionList<'t>>),
    FPSectionOpt(Option<Box<FPSectionOpt<'t>>>),
    Factor(Factor<'t>),
    FactorOpt(Option<Box<FactorOpt<'t>>>),
    FactorOpt0(Option<Box<FactorOpt0<'t>>>),
    FieldList(FieldList<'t>),
    FieldListOpt(Option<Box<FieldListOpt<'t>>>),
    FormalPars(FormalPars<'t>),
    FormalParsOpt(Option<Box<FormalParsOpt<'t>>>),
    FormalParsOpt0(Option<Box<FormalParsOpt0<'t>>>),
    FormalParsOptList(Vec<FormalParsOptList<'t>>),
    ForwardDecl(ForwardDecl<'t>),
    ForwardDeclOpt(Option<Box<ForwardDeclOpt<'t>>>),
    ForwardDeclOpt0(Option<Box<ForwardDeclOpt0<'t>>>),
    Guard(Guard<'t>),
    IF(IF<'t>),
    Ident(Ident<'t>),
    IdentDef(IdentDef<'t>),
    IdentDefOpt(Option<Box<IdentDefOpt<'t>>>),
    IdentDefOptGroup(IdentDefOptGroup<'t>),
    IdentList(IdentList<'t>),
    IdentListList(Vec<IdentListList<'t>>),
    ImportList(ImportList<'t>),
    ImportListList(Vec<ImportListList<'t>>),
    ImportListOpt(Option<Box<ImportListOpt<'t>>>),
    ImportListOpt0(Option<Box<ImportListOpt0<'t>>>),
    Integer(Integer<'t>),
    MulOp(MulOp<'t>),
    Number(Number<'t>),
    OF(OF<'t>),
    Oberon2(Oberon2<'t>),
    Oberon2Opt(Option<Box<Oberon2Opt<'t>>>),
    Oberon2Opt0(Option<Box<Oberon2Opt0<'t>>>),
    PROCEDURE(PROCEDURE<'t>),
    ProcDecl(ProcDecl<'t>),
    ProcDeclOpt(Option<Box<ProcDeclOpt<'t>>>),
    ProcDeclOpt0(Option<Box<ProcDeclOpt0<'t>>>),
    ProcDeclOpt1(Option<Box<ProcDeclOpt1<'t>>>),
    QIdent(QIdent<'t>),
    QualIdent(QualIdent<'t>),
    Real(Real<'t>),
    Receiver(Receiver<'t>),
    ReceiverOpt(Option<Box<ReceiverOpt<'t>>>),
    Relation(Relation<'t>),
    Set(Set<'t>),
    SetOpt(Option<Box<SetOpt<'t>>>),
    SetOptList(Vec<SetOptList<'t>>),
    SimpleExpr(SimpleExpr<'t>),
    SimpleExprList(Vec<SimpleExprList<'t>>),
    SimpleExprOpt(Option<Box<SimpleExprOpt<'t>>>),
    SimpleExprOptGroup(SimpleExprOptGroup<'t>),
    Statement(Statement<'t>),
    StatementList(Vec<StatementList<'t>>),
    StatementList0(Vec<StatementList0<'t>>),
    StatementList1(Vec<StatementList1<'t>>),
    StatementOpt(Option<Box<StatementOpt<'t>>>),
    StatementOpt0(Option<Box<StatementOpt0<'t>>>),
    StatementOpt1(Option<Box<StatementOpt1<'t>>>),
    StatementOpt2(Option<Box<StatementOpt2<'t>>>),
    StatementOpt3(Option<Box<StatementOpt3<'t>>>),
    StatementOpt4(Option<Box<StatementOpt4<'t>>>),
    StatementOpt5(Option<Box<StatementOpt5<'t>>>),
    StatementSeq(StatementSeq<'t>),
    StatementSeqList(Vec<StatementSeqList<'t>>),
    StatementSuffix(StatementSuffix<'t>),
    String(String<'t>),
    THEN(THEN<'t>),
    TO(TO<'t>),
    Term(Term<'t>),
    TermList(Vec<TermList<'t>>),
    TypeDecl(TypeDecl<'t>),
    TypeDef(TypeDef<'t>),
    TypeDefList(Vec<TypeDefList<'t>>),
    TypeDefOpt(Option<Box<TypeDefOpt<'t>>>),
    TypeDefOpt0(Option<Box<TypeDefOpt0<'t>>>),
    TypeDefOpt1(Option<Box<TypeDefOpt1<'t>>>),
    TypeDefOptList(Vec<TypeDefOptList<'t>>),
    VAR(VAR<'t>),
    VarDecl(VarDecl<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct Oberon2GrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn Oberon2GrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
    // Path of the input file. Used for diagnostics.
    file_name: PathBuf,
}

///
/// The `Oberon2GrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> Oberon2GrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn Oberon2GrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            file_name: PathBuf::default(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// BEGIN: "BEGIN";
    ///
    #[named]
    fn b_e_g_i_n(
        &mut self,
        b_e_g_i_n: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let b_e_g_i_n = *b_e_g_i_n.token(parse_tree)?;
        let b_e_g_i_n_built = BEGINBuilder::default()
            .b_e_g_i_n(b_e_g_i_n)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.b_e_g_i_n(&b_e_g_i_n_built)?;
        self.push(ASTType::BEGIN(b_e_g_i_n_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// CASE: "CASE";
    ///
    #[named]
    fn c_a_s_e(
        &mut self,
        c_a_s_e: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let c_a_s_e = *c_a_s_e.token(parse_tree)?;
        let c_a_s_e_built = CASEBuilder::default()
            .c_a_s_e(c_a_s_e)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.c_a_s_e(&c_a_s_e_built)?;
        self.push(ASTType::CASE(c_a_s_e_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// DO: "DO";
    ///
    #[named]
    fn d_o(
        &mut self,
        d_o: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let d_o = *d_o.token(parse_tree)?;
        let d_o_built = DOBuilder::default().d_o(d_o).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.d_o(&d_o_built)?;
        self.push(ASTType::DO(d_o_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// ELSE: "ELSE";
    ///
    #[named]
    fn e_l_s_e(
        &mut self,
        e_l_s_e: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let e_l_s_e = *e_l_s_e.token(parse_tree)?;
        let e_l_s_e_built = ELSEBuilder::default()
            .e_l_s_e(e_l_s_e)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.e_l_s_e(&e_l_s_e_built)?;
        self.push(ASTType::ELSE(e_l_s_e_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// ELSIF: "ELSIF";
    ///
    #[named]
    fn e_l_s_i_f(
        &mut self,
        e_l_s_i_f: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let e_l_s_i_f = *e_l_s_i_f.token(parse_tree)?;
        let e_l_s_i_f_built = ELSIFBuilder::default()
            .e_l_s_i_f(e_l_s_i_f)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.e_l_s_i_f(&e_l_s_i_f_built)?;
        self.push(ASTType::ELSIF(e_l_s_i_f_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// END: "END";
    ///
    #[named]
    fn e_n_d(
        &mut self,
        e_n_d: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let e_n_d = *e_n_d.token(parse_tree)?;
        let e_n_d_built = ENDBuilder::default()
            .e_n_d(e_n_d)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.e_n_d(&e_n_d_built)?;
        self.push(ASTType::END(e_n_d_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// IF: "IF";
    ///
    #[named]
    fn i_f(
        &mut self,
        i_f: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i_f = *i_f.token(parse_tree)?;
        let i_f_built = IFBuilder::default().i_f(i_f).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.i_f(&i_f_built)?;
        self.push(ASTType::IF(i_f_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// OF: "OF";
    ///
    #[named]
    fn o_f(
        &mut self,
        o_f: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let o_f = *o_f.token(parse_tree)?;
        let o_f_built = OFBuilder::default().o_f(o_f).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.o_f(&o_f_built)?;
        self.push(ASTType::OF(o_f_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// PROCEDURE: "PROCEDURE";
    ///
    #[named]
    fn p_r_o_c_e_d_u_r_e(
        &mut self,
        p_r_o_c_e_d_u_r_e: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let p_r_o_c_e_d_u_r_e = *p_r_o_c_e_d_u_r_e.token(parse_tree)?;
        let p_r_o_c_e_d_u_r_e_built = PROCEDUREBuilder::default()
            .p_r_o_c_e_d_u_r_e(p_r_o_c_e_d_u_r_e)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .p_r_o_c_e_d_u_r_e(&p_r_o_c_e_d_u_r_e_built)?;
        self.push(ASTType::PROCEDURE(p_r_o_c_e_d_u_r_e_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// THEN: "THEN";
    ///
    #[named]
    fn t_h_e_n(
        &mut self,
        t_h_e_n: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let t_h_e_n = *t_h_e_n.token(parse_tree)?;
        let t_h_e_n_built = THENBuilder::default()
            .t_h_e_n(t_h_e_n)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.t_h_e_n(&t_h_e_n_built)?;
        self.push(ASTType::THEN(t_h_e_n_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// TO: "TO";
    ///
    #[named]
    fn t_o(
        &mut self,
        t_o: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let t_o = *t_o.token(parse_tree)?;
        let t_o_built = TOBuilder::default().t_o(t_o).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.t_o(&t_o_built)?;
        self.push(ASTType::TO(t_o_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// VAR: "VAR";
    ///
    #[named]
    fn v_a_r(
        &mut self,
        v_a_r: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let v_a_r = *v_a_r.token(parse_tree)?;
        let v_a_r_built = VARBuilder::default()
            .v_a_r(v_a_r)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.v_a_r(&v_a_r_built)?;
        self.push(ASTType::VAR(v_a_r_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// Oberon2: "MODULE" Ident ";" Oberon2Opt /* Option */ DeclSeq Oberon2Opt0 /* Option */ END Ident "\.";
    ///
    #[named]
    fn oberon2(
        &mut self,
        m_o_d_u_l_e: &ParseTreeStackEntry<'t>,
        _ident: &ParseTreeStackEntry<'t>,
        semicolon: &ParseTreeStackEntry<'t>,
        _oberon2_opt: &ParseTreeStackEntry<'t>,
        _decl_seq: &ParseTreeStackEntry<'t>,
        _oberon2_opt0: &ParseTreeStackEntry<'t>,
        _e_n_d: &ParseTreeStackEntry<'t>,
        _ident0: &ParseTreeStackEntry<'t>,
        dot: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_o_d_u_l_e = *m_o_d_u_l_e.token(parse_tree)?;
        let semicolon = *semicolon.token(parse_tree)?;
        let dot = *dot.token(parse_tree)?;
        let ident0 = if let Some(ASTType::Ident(ident0)) = self.pop(context) {
            ident0
        } else {
            bail!("{}: Expecting ASTType::Ident", context);
        };
        let e_n_d = if let Some(ASTType::END(e_n_d)) = self.pop(context) {
            e_n_d
        } else {
            bail!("{}: Expecting ASTType::END", context);
        };
        let oberon2_opt0 = if let Some(ASTType::Oberon2Opt0(oberon2_opt0)) = self.pop(context) {
            oberon2_opt0
        } else {
            bail!("{}: Expecting ASTType::Oberon2Opt0", context);
        };
        let decl_seq = if let Some(ASTType::DeclSeq(decl_seq)) = self.pop(context) {
            decl_seq
        } else {
            bail!("{}: Expecting ASTType::DeclSeq", context);
        };
        let oberon2_opt = if let Some(ASTType::Oberon2Opt(oberon2_opt)) = self.pop(context) {
            oberon2_opt
        } else {
            bail!("{}: Expecting ASTType::Oberon2Opt", context);
        };
        let ident = if let Some(ASTType::Ident(ident)) = self.pop(context) {
            ident
        } else {
            bail!("{}: Expecting ASTType::Ident", context);
        };
        let oberon2_built = Oberon2Builder::default()
            .m_o_d_u_l_e(m_o_d_u_l_e)
            .ident(Box::new(ident))
            .semicolon(semicolon)
            .oberon2_opt(oberon2_opt)
            .decl_seq(Box::new(decl_seq))
            .oberon2_opt0(oberon2_opt0)
            .e_n_d(Box::new(e_n_d))
            .ident0(Box::new(ident0))
            .dot(dot)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.oberon2(&oberon2_built)?;
        self.push(ASTType::Oberon2(oberon2_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// Oberon2Opt0: BEGIN StatementSeq; // Option<T>::Some
    ///
    #[named]
    fn oberon2_opt0_0(
        &mut self,
        _b_e_g_i_n: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq = if let Some(ASTType::StatementSeq(statement_seq)) = self.pop(context) {
            statement_seq
        } else {
            bail!("{}: Expecting ASTType::StatementSeq", context);
        };
        let b_e_g_i_n = if let Some(ASTType::BEGIN(b_e_g_i_n)) = self.pop(context) {
            b_e_g_i_n
        } else {
            bail!("{}: Expecting ASTType::BEGIN", context);
        };
        let oberon2_opt0_0_built = Oberon2Opt0Builder::default()
            .b_e_g_i_n(Box::new(b_e_g_i_n))
            .statement_seq(Box::new(statement_seq))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::Oberon2Opt0(Some(Box::new(oberon2_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// Oberon2Opt0: ; // Option<T>::None
    ///
    #[named]
    fn oberon2_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::Oberon2Opt0(None), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// Oberon2Opt: ImportList; // Option<T>::Some
    ///
    #[named]
    fn oberon2_opt_0(
        &mut self,
        _import_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_list = if let Some(ASTType::ImportList(import_list)) = self.pop(context) {
            import_list
        } else {
            bail!("{}: Expecting ASTType::ImportList", context);
        };
        let oberon2_opt_0_built = Oberon2OptBuilder::default()
            .import_list(Box::new(import_list))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::Oberon2Opt(Some(Box::new(oberon2_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// Oberon2Opt: ; // Option<T>::None
    ///
    #[named]
    fn oberon2_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::Oberon2Opt(None), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// ImportList: "IMPORT" ImportListOpt /* Option */ Ident ImportListList /* Vec */ ";";
    ///
    #[named]
    fn import_list(
        &mut self,
        i_m_p_o_r_t: &ParseTreeStackEntry<'t>,
        _import_list_opt: &ParseTreeStackEntry<'t>,
        _ident: &ParseTreeStackEntry<'t>,
        _import_list_list: &ParseTreeStackEntry<'t>,
        semicolon: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i_m_p_o_r_t = *i_m_p_o_r_t.token(parse_tree)?;
        let semicolon = *semicolon.token(parse_tree)?;
        let import_list_list =
            if let Some(ASTType::ImportListList(mut import_list_list)) = self.pop(context) {
                import_list_list.reverse();
                import_list_list
            } else {
                bail!("{}: Expecting ASTType::ImportListList", context);
            };
        let ident = if let Some(ASTType::Ident(ident)) = self.pop(context) {
            ident
        } else {
            bail!("{}: Expecting ASTType::Ident", context);
        };
        let import_list_opt =
            if let Some(ASTType::ImportListOpt(import_list_opt)) = self.pop(context) {
                import_list_opt
            } else {
                bail!("{}: Expecting ASTType::ImportListOpt", context);
            };
        let import_list_built = ImportListBuilder::default()
            .i_m_p_o_r_t(i_m_p_o_r_t)
            .import_list_opt(import_list_opt)
            .ident(Box::new(ident))
            .import_list_list(import_list_list)
            .semicolon(semicolon)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.import_list(&import_list_built)?;
        self.push(ASTType::ImportList(import_list_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// ImportListList: "," ImportListOpt0 /* Option */ Ident ImportListList; // Vec<T>::Push
    ///
    #[named]
    fn import_list_list_0(
        &mut self,
        comma: &ParseTreeStackEntry<'t>,
        _import_list_opt0: &ParseTreeStackEntry<'t>,
        _ident: &ParseTreeStackEntry<'t>,
        _import_list_list: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = *comma.token(parse_tree)?;
        let mut import_list_list =
            if let Some(ASTType::ImportListList(import_list_list)) = self.pop(context) {
                import_list_list
            } else {
                bail!("{}: Expecting ASTType::ImportListList", context);
            };
        let ident = if let Some(ASTType::Ident(ident)) = self.pop(context) {
            ident
        } else {
            bail!("{}: Expecting ASTType::Ident", context);
        };
        let import_list_opt0 =
            if let Some(ASTType::ImportListOpt0(import_list_opt0)) = self.pop(context) {
                import_list_opt0
            } else {
                bail!("{}: Expecting ASTType::ImportListOpt0", context);
            };
        let import_list_list_0_built = ImportListListBuilder::default()
            .ident(Box::new(ident))
            .import_list_opt0(import_list_opt0)
            .comma(comma)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        import_list_list.push(import_list_list_0_built);
        self.push(ASTType::ImportListList(import_list_list), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// ImportListList: ; // Vec<T>::New
    ///
    #[named]
    fn import_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_list_list_1_built = Vec::new();
        self.push(ASTType::ImportListList(import_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// ImportListOpt0: Ident ":="; // Option<T>::Some
    ///
    #[named]
    fn import_list_opt0_0(
        &mut self,
        _ident: &ParseTreeStackEntry<'t>,
        colon_equ: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_equ = *colon_equ.token(parse_tree)?;
        let ident = if let Some(ASTType::Ident(ident)) = self.pop(context) {
            ident
        } else {
            bail!("{}: Expecting ASTType::Ident", context);
        };
        let import_list_opt0_0_built = ImportListOpt0Builder::default()
            .ident(Box::new(ident))
            .colon_equ(colon_equ)
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ImportListOpt0(Some(Box::new(import_list_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// ImportListOpt0: ; // Option<T>::None
    ///
    #[named]
    fn import_list_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ImportListOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// ImportListOpt: Ident ":="; // Option<T>::Some
    ///
    #[named]
    fn import_list_opt_0(
        &mut self,
        _ident: &ParseTreeStackEntry<'t>,
        colon_equ: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_equ = *colon_equ.token(parse_tree)?;
        let ident = if let Some(ASTType::Ident(ident)) = self.pop(context) {
            ident
        } else {
            bail!("{}: Expecting ASTType::Ident", context);
        };
        let import_list_opt_0_built = ImportListOptBuilder::default()
            .ident(Box::new(ident))
            .colon_equ(colon_equ)
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ImportListOpt(Some(Box::new(import_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// ImportListOpt: ; // Option<T>::None
    ///
    #[named]
    fn import_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ImportListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// DeclSeq: DeclSeqList /* Vec */ DeclSeqList0 /* Vec */;
    ///
    #[named]
    fn decl_seq(
        &mut self,
        _decl_seq_list: &ParseTreeStackEntry<'t>,
        _decl_seq_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let decl_seq_list0 =
            if let Some(ASTType::DeclSeqList0(mut decl_seq_list0)) = self.pop(context) {
                decl_seq_list0.reverse();
                decl_seq_list0
            } else {
                bail!("{}: Expecting ASTType::DeclSeqList0", context);
            };
        let decl_seq_list = if let Some(ASTType::DeclSeqList(mut decl_seq_list)) = self.pop(context)
        {
            decl_seq_list.reverse();
            decl_seq_list
        } else {
            bail!("{}: Expecting ASTType::DeclSeqList", context);
        };
        let decl_seq_built = DeclSeqBuilder::default()
            .decl_seq_list(decl_seq_list)
            .decl_seq_list0(decl_seq_list0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.decl_seq(&decl_seq_built)?;
        self.push(ASTType::DeclSeq(decl_seq_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// DeclSeqList0: DeclSeqList0Group DeclSeqList0; // Vec<T>::Push
    ///
    #[named]
    fn decl_seq_list0_0(
        &mut self,
        _decl_seq_list0_group: &ParseTreeStackEntry<'t>,
        _decl_seq_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut decl_seq_list0 =
            if let Some(ASTType::DeclSeqList0(decl_seq_list0)) = self.pop(context) {
                decl_seq_list0
            } else {
                bail!("{}: Expecting ASTType::DeclSeqList0", context);
            };
        let decl_seq_list0_group =
            if let Some(ASTType::DeclSeqList0Group(decl_seq_list0_group)) = self.pop(context) {
                decl_seq_list0_group
            } else {
                bail!("{}: Expecting ASTType::DeclSeqList0Group", context);
            };
        let decl_seq_list0_0_built = DeclSeqList0Builder::default()
            .decl_seq_list0_group(Box::new(decl_seq_list0_group))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        decl_seq_list0.push(decl_seq_list0_0_built);
        self.push(ASTType::DeclSeqList0(decl_seq_list0), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// DeclSeqList0Group: ProcDecl ";";
    ///
    #[named]
    fn decl_seq_list0_group_0(
        &mut self,
        _proc_decl: &ParseTreeStackEntry<'t>,
        semicolon: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = *semicolon.token(parse_tree)?;
        let proc_decl = if let Some(ASTType::ProcDecl(proc_decl)) = self.pop(context) {
            proc_decl
        } else {
            bail!("{}: Expecting ASTType::ProcDecl", context);
        };
        let decl_seq_list0_group_0_built = DeclSeqList0Group0Builder::default()
            .proc_decl(Box::new(proc_decl))
            .semicolon(semicolon)
            .build()
            .into_diagnostic()?;
        let decl_seq_list0_group_0_built =
            DeclSeqList0Group::DeclSeqList0Group0(decl_seq_list0_group_0_built);
        self.push(
            ASTType::DeclSeqList0Group(decl_seq_list0_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// DeclSeqList0Group: ForwardDecl ";";
    ///
    #[named]
    fn decl_seq_list0_group_1(
        &mut self,
        _forward_decl: &ParseTreeStackEntry<'t>,
        semicolon: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = *semicolon.token(parse_tree)?;
        let forward_decl = if let Some(ASTType::ForwardDecl(forward_decl)) = self.pop(context) {
            forward_decl
        } else {
            bail!("{}: Expecting ASTType::ForwardDecl", context);
        };
        let decl_seq_list0_group_1_built = DeclSeqList0Group1Builder::default()
            .forward_decl(Box::new(forward_decl))
            .semicolon(semicolon)
            .build()
            .into_diagnostic()?;
        let decl_seq_list0_group_1_built =
            DeclSeqList0Group::DeclSeqList0Group1(decl_seq_list0_group_1_built);
        self.push(
            ASTType::DeclSeqList0Group(decl_seq_list0_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// DeclSeqList0: ; // Vec<T>::New
    ///
    #[named]
    fn decl_seq_list0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let decl_seq_list0_1_built = Vec::new();
        self.push(ASTType::DeclSeqList0(decl_seq_list0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// DeclSeqList: DeclSeqListGroup DeclSeqList; // Vec<T>::Push
    ///
    #[named]
    fn decl_seq_list_0(
        &mut self,
        _decl_seq_list_group: &ParseTreeStackEntry<'t>,
        _decl_seq_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut decl_seq_list = if let Some(ASTType::DeclSeqList(decl_seq_list)) = self.pop(context)
        {
            decl_seq_list
        } else {
            bail!("{}: Expecting ASTType::DeclSeqList", context);
        };
        let decl_seq_list_group =
            if let Some(ASTType::DeclSeqListGroup(decl_seq_list_group)) = self.pop(context) {
                decl_seq_list_group
            } else {
                bail!("{}: Expecting ASTType::DeclSeqListGroup", context);
            };
        let decl_seq_list_0_built = DeclSeqListBuilder::default()
            .decl_seq_list_group(Box::new(decl_seq_list_group))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        decl_seq_list.push(decl_seq_list_0_built);
        self.push(ASTType::DeclSeqList(decl_seq_list), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// DeclSeqListGroup: "CONST" DeclSeqListGroupList /* Vec */;
    ///
    #[named]
    fn decl_seq_list_group_0(
        &mut self,
        c_o_n_s_t: &ParseTreeStackEntry<'t>,
        _decl_seq_list_group_list: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let c_o_n_s_t = *c_o_n_s_t.token(parse_tree)?;
        let decl_seq_list_group_list =
            if let Some(ASTType::DeclSeqListGroupList(mut decl_seq_list_group_list)) =
                self.pop(context)
            {
                decl_seq_list_group_list.reverse();
                decl_seq_list_group_list
            } else {
                bail!("{}: Expecting ASTType::DeclSeqListGroupList", context);
            };
        let decl_seq_list_group_0_built = DeclSeqListGroup0Builder::default()
            .c_o_n_s_t(c_o_n_s_t)
            .decl_seq_list_group_list(decl_seq_list_group_list)
            .build()
            .into_diagnostic()?;
        let decl_seq_list_group_0_built =
            DeclSeqListGroup::DeclSeqListGroup0(decl_seq_list_group_0_built);
        self.push(
            ASTType::DeclSeqListGroup(decl_seq_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// DeclSeqListGroupList: ConstDecl ";" DeclSeqListGroupList; // Vec<T>::Push
    ///
    #[named]
    fn decl_seq_list_group_list_0(
        &mut self,
        _const_decl: &ParseTreeStackEntry<'t>,
        semicolon: &ParseTreeStackEntry<'t>,
        _decl_seq_list_group_list: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = *semicolon.token(parse_tree)?;
        let mut decl_seq_list_group_list = if let Some(ASTType::DeclSeqListGroupList(
            decl_seq_list_group_list,
        )) = self.pop(context)
        {
            decl_seq_list_group_list
        } else {
            bail!("{}: Expecting ASTType::DeclSeqListGroupList", context);
        };
        let const_decl = if let Some(ASTType::ConstDecl(const_decl)) = self.pop(context) {
            const_decl
        } else {
            bail!("{}: Expecting ASTType::ConstDecl", context);
        };
        let decl_seq_list_group_list_0_built = DeclSeqListGroupListBuilder::default()
            .semicolon(semicolon)
            .const_decl(Box::new(const_decl))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        decl_seq_list_group_list.push(decl_seq_list_group_list_0_built);
        self.push(
            ASTType::DeclSeqListGroupList(decl_seq_list_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// DeclSeqListGroupList: ; // Vec<T>::New
    ///
    #[named]
    fn decl_seq_list_group_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let decl_seq_list_group_list_1_built = Vec::new();
        self.push(
            ASTType::DeclSeqListGroupList(decl_seq_list_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// DeclSeqListGroup: "TYPE" DeclSeqListGroupList0 /* Vec */;
    ///
    #[named]
    fn decl_seq_list_group_1(
        &mut self,
        t_y_p_e: &ParseTreeStackEntry<'t>,
        _decl_seq_list_group_list0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let t_y_p_e = *t_y_p_e.token(parse_tree)?;
        let decl_seq_list_group_list0 =
            if let Some(ASTType::DeclSeqListGroupList0(mut decl_seq_list_group_list0)) =
                self.pop(context)
            {
                decl_seq_list_group_list0.reverse();
                decl_seq_list_group_list0
            } else {
                bail!("{}: Expecting ASTType::DeclSeqListGroupList0", context);
            };
        let decl_seq_list_group_1_built = DeclSeqListGroup1Builder::default()
            .t_y_p_e(t_y_p_e)
            .decl_seq_list_group_list0(decl_seq_list_group_list0)
            .build()
            .into_diagnostic()?;
        let decl_seq_list_group_1_built =
            DeclSeqListGroup::DeclSeqListGroup1(decl_seq_list_group_1_built);
        self.push(
            ASTType::DeclSeqListGroup(decl_seq_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// DeclSeqListGroupList0: TypeDecl ";" DeclSeqListGroupList0; // Vec<T>::Push
    ///
    #[named]
    fn decl_seq_list_group_list0_0(
        &mut self,
        _type_decl: &ParseTreeStackEntry<'t>,
        semicolon: &ParseTreeStackEntry<'t>,
        _decl_seq_list_group_list0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = *semicolon.token(parse_tree)?;
        let mut decl_seq_list_group_list0 =
            if let Some(ASTType::DeclSeqListGroupList0(decl_seq_list_group_list0)) =
                self.pop(context)
            {
                decl_seq_list_group_list0
            } else {
                bail!("{}: Expecting ASTType::DeclSeqListGroupList0", context);
            };
        let type_decl = if let Some(ASTType::TypeDecl(type_decl)) = self.pop(context) {
            type_decl
        } else {
            bail!("{}: Expecting ASTType::TypeDecl", context);
        };
        let decl_seq_list_group_list0_0_built = DeclSeqListGroupList0Builder::default()
            .semicolon(semicolon)
            .type_decl(Box::new(type_decl))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        decl_seq_list_group_list0.push(decl_seq_list_group_list0_0_built);
        self.push(
            ASTType::DeclSeqListGroupList0(decl_seq_list_group_list0),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// DeclSeqListGroupList0: ; // Vec<T>::New
    ///
    #[named]
    fn decl_seq_list_group_list0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let decl_seq_list_group_list0_1_built = Vec::new();
        self.push(
            ASTType::DeclSeqListGroupList0(decl_seq_list_group_list0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// DeclSeqListGroup: VAR DeclSeqListGroupList1 /* Vec */;
    ///
    #[named]
    fn decl_seq_list_group_2(
        &mut self,
        _v_a_r: &ParseTreeStackEntry<'t>,
        _decl_seq_list_group_list1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let decl_seq_list_group_list1 =
            if let Some(ASTType::DeclSeqListGroupList1(mut decl_seq_list_group_list1)) =
                self.pop(context)
            {
                decl_seq_list_group_list1.reverse();
                decl_seq_list_group_list1
            } else {
                bail!("{}: Expecting ASTType::DeclSeqListGroupList1", context);
            };
        let v_a_r = if let Some(ASTType::VAR(v_a_r)) = self.pop(context) {
            v_a_r
        } else {
            bail!("{}: Expecting ASTType::VAR", context);
        };
        let decl_seq_list_group_2_built = DeclSeqListGroup2Builder::default()
            .v_a_r(Box::new(v_a_r))
            .decl_seq_list_group_list1(decl_seq_list_group_list1)
            .build()
            .into_diagnostic()?;
        let decl_seq_list_group_2_built =
            DeclSeqListGroup::DeclSeqListGroup2(decl_seq_list_group_2_built);
        self.push(
            ASTType::DeclSeqListGroup(decl_seq_list_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// DeclSeqListGroupList1: VarDecl ";" DeclSeqListGroupList1; // Vec<T>::Push
    ///
    #[named]
    fn decl_seq_list_group_list1_0(
        &mut self,
        _var_decl: &ParseTreeStackEntry<'t>,
        semicolon: &ParseTreeStackEntry<'t>,
        _decl_seq_list_group_list1: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = *semicolon.token(parse_tree)?;
        let mut decl_seq_list_group_list1 =
            if let Some(ASTType::DeclSeqListGroupList1(decl_seq_list_group_list1)) =
                self.pop(context)
            {
                decl_seq_list_group_list1
            } else {
                bail!("{}: Expecting ASTType::DeclSeqListGroupList1", context);
            };
        let var_decl = if let Some(ASTType::VarDecl(var_decl)) = self.pop(context) {
            var_decl
        } else {
            bail!("{}: Expecting ASTType::VarDecl", context);
        };
        let decl_seq_list_group_list1_0_built = DeclSeqListGroupList1Builder::default()
            .semicolon(semicolon)
            .var_decl(Box::new(var_decl))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        decl_seq_list_group_list1.push(decl_seq_list_group_list1_0_built);
        self.push(
            ASTType::DeclSeqListGroupList1(decl_seq_list_group_list1),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// DeclSeqListGroupList1: ; // Vec<T>::New
    ///
    #[named]
    fn decl_seq_list_group_list1_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let decl_seq_list_group_list1_1_built = Vec::new();
        self.push(
            ASTType::DeclSeqListGroupList1(decl_seq_list_group_list1_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// DeclSeqList: ; // Vec<T>::New
    ///
    #[named]
    fn decl_seq_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let decl_seq_list_1_built = Vec::new();
        self.push(ASTType::DeclSeqList(decl_seq_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// ConstDecl: IdentDef "=" ConstExpr;
    ///
    #[named]
    fn const_decl(
        &mut self,
        _ident_def: &ParseTreeStackEntry<'t>,
        equ: &ParseTreeStackEntry<'t>,
        _const_expr: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ = *equ.token(parse_tree)?;
        let const_expr = if let Some(ASTType::ConstExpr(const_expr)) = self.pop(context) {
            const_expr
        } else {
            bail!("{}: Expecting ASTType::ConstExpr", context);
        };
        let ident_def = if let Some(ASTType::IdentDef(ident_def)) = self.pop(context) {
            ident_def
        } else {
            bail!("{}: Expecting ASTType::IdentDef", context);
        };
        let const_decl_built = ConstDeclBuilder::default()
            .ident_def(Box::new(ident_def))
            .equ(equ)
            .const_expr(Box::new(const_expr))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.const_decl(&const_decl_built)?;
        self.push(ASTType::ConstDecl(const_decl_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// TypeDecl: IdentDef "=" TypeDef;
    ///
    #[named]
    fn type_decl(
        &mut self,
        _ident_def: &ParseTreeStackEntry<'t>,
        equ: &ParseTreeStackEntry<'t>,
        _type_def: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ = *equ.token(parse_tree)?;
        let type_def = if let Some(ASTType::TypeDef(type_def)) = self.pop(context) {
            type_def
        } else {
            bail!("{}: Expecting ASTType::TypeDef", context);
        };
        let ident_def = if let Some(ASTType::IdentDef(ident_def)) = self.pop(context) {
            ident_def
        } else {
            bail!("{}: Expecting ASTType::IdentDef", context);
        };
        let type_decl_built = TypeDeclBuilder::default()
            .ident_def(Box::new(ident_def))
            .equ(equ)
            .type_def(Box::new(type_def))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.type_decl(&type_decl_built)?;
        self.push(ASTType::TypeDecl(type_decl_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// VarDecl: IdentList ":" TypeDef;
    ///
    #[named]
    fn var_decl(
        &mut self,
        _ident_list: &ParseTreeStackEntry<'t>,
        colon: &ParseTreeStackEntry<'t>,
        _type_def: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = *colon.token(parse_tree)?;
        let type_def = if let Some(ASTType::TypeDef(type_def)) = self.pop(context) {
            type_def
        } else {
            bail!("{}: Expecting ASTType::TypeDef", context);
        };
        let ident_list = if let Some(ASTType::IdentList(ident_list)) = self.pop(context) {
            ident_list
        } else {
            bail!("{}: Expecting ASTType::IdentList", context);
        };
        let var_decl_built = VarDeclBuilder::default()
            .ident_list(Box::new(ident_list))
            .colon(colon)
            .type_def(Box::new(type_def))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.var_decl(&var_decl_built)?;
        self.push(ASTType::VarDecl(var_decl_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// ProcDecl: PROCEDURE ProcDeclOpt /* Option */ IdentDef ProcDeclOpt0 /* Option */ ";" DeclSeq ProcDeclOpt1 /* Option */ END Ident;
    ///
    #[named]
    fn proc_decl(
        &mut self,
        _p_r_o_c_e_d_u_r_e: &ParseTreeStackEntry<'t>,
        _proc_decl_opt: &ParseTreeStackEntry<'t>,
        _ident_def: &ParseTreeStackEntry<'t>,
        _proc_decl_opt0: &ParseTreeStackEntry<'t>,
        semicolon: &ParseTreeStackEntry<'t>,
        _decl_seq: &ParseTreeStackEntry<'t>,
        _proc_decl_opt1: &ParseTreeStackEntry<'t>,
        _e_n_d: &ParseTreeStackEntry<'t>,
        _ident: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = *semicolon.token(parse_tree)?;
        let ident = if let Some(ASTType::Ident(ident)) = self.pop(context) {
            ident
        } else {
            bail!("{}: Expecting ASTType::Ident", context);
        };
        let e_n_d = if let Some(ASTType::END(e_n_d)) = self.pop(context) {
            e_n_d
        } else {
            bail!("{}: Expecting ASTType::END", context);
        };
        let proc_decl_opt1 = if let Some(ASTType::ProcDeclOpt1(proc_decl_opt1)) = self.pop(context)
        {
            proc_decl_opt1
        } else {
            bail!("{}: Expecting ASTType::ProcDeclOpt1", context);
        };
        let decl_seq = if let Some(ASTType::DeclSeq(decl_seq)) = self.pop(context) {
            decl_seq
        } else {
            bail!("{}: Expecting ASTType::DeclSeq", context);
        };
        let proc_decl_opt0 = if let Some(ASTType::ProcDeclOpt0(proc_decl_opt0)) = self.pop(context)
        {
            proc_decl_opt0
        } else {
            bail!("{}: Expecting ASTType::ProcDeclOpt0", context);
        };
        let ident_def = if let Some(ASTType::IdentDef(ident_def)) = self.pop(context) {
            ident_def
        } else {
            bail!("{}: Expecting ASTType::IdentDef", context);
        };
        let proc_decl_opt = if let Some(ASTType::ProcDeclOpt(proc_decl_opt)) = self.pop(context) {
            proc_decl_opt
        } else {
            bail!("{}: Expecting ASTType::ProcDeclOpt", context);
        };
        let p_r_o_c_e_d_u_r_e =
            if let Some(ASTType::PROCEDURE(p_r_o_c_e_d_u_r_e)) = self.pop(context) {
                p_r_o_c_e_d_u_r_e
            } else {
                bail!("{}: Expecting ASTType::PROCEDURE", context);
            };
        let proc_decl_built = ProcDeclBuilder::default()
            .p_r_o_c_e_d_u_r_e(Box::new(p_r_o_c_e_d_u_r_e))
            .proc_decl_opt(proc_decl_opt)
            .ident_def(Box::new(ident_def))
            .proc_decl_opt0(proc_decl_opt0)
            .semicolon(semicolon)
            .decl_seq(Box::new(decl_seq))
            .proc_decl_opt1(proc_decl_opt1)
            .e_n_d(Box::new(e_n_d))
            .ident(Box::new(ident))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.proc_decl(&proc_decl_built)?;
        self.push(ASTType::ProcDecl(proc_decl_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// ProcDeclOpt1: BEGIN StatementSeq; // Option<T>::Some
    ///
    #[named]
    fn proc_decl_opt1_0(
        &mut self,
        _b_e_g_i_n: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq = if let Some(ASTType::StatementSeq(statement_seq)) = self.pop(context) {
            statement_seq
        } else {
            bail!("{}: Expecting ASTType::StatementSeq", context);
        };
        let b_e_g_i_n = if let Some(ASTType::BEGIN(b_e_g_i_n)) = self.pop(context) {
            b_e_g_i_n
        } else {
            bail!("{}: Expecting ASTType::BEGIN", context);
        };
        let proc_decl_opt1_0_built = ProcDeclOpt1Builder::default()
            .b_e_g_i_n(Box::new(b_e_g_i_n))
            .statement_seq(Box::new(statement_seq))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ProcDeclOpt1(Some(Box::new(proc_decl_opt1_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// ProcDeclOpt1: ; // Option<T>::None
    ///
    #[named]
    fn proc_decl_opt1_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ProcDeclOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// ProcDeclOpt0: FormalPars; // Option<T>::Some
    ///
    #[named]
    fn proc_decl_opt0_0(
        &mut self,
        _formal_pars: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let formal_pars = if let Some(ASTType::FormalPars(formal_pars)) = self.pop(context) {
            formal_pars
        } else {
            bail!("{}: Expecting ASTType::FormalPars", context);
        };
        let proc_decl_opt0_0_built = ProcDeclOpt0Builder::default()
            .formal_pars(Box::new(formal_pars))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ProcDeclOpt0(Some(Box::new(proc_decl_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// ProcDeclOpt0: ; // Option<T>::None
    ///
    #[named]
    fn proc_decl_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ProcDeclOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// ProcDeclOpt: Receiver; // Option<T>::Some
    ///
    #[named]
    fn proc_decl_opt_0(
        &mut self,
        _receiver: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let receiver = if let Some(ASTType::Receiver(receiver)) = self.pop(context) {
            receiver
        } else {
            bail!("{}: Expecting ASTType::Receiver", context);
        };
        let proc_decl_opt_0_built = ProcDeclOptBuilder::default()
            .receiver(Box::new(receiver))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ProcDeclOpt(Some(Box::new(proc_decl_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// ProcDeclOpt: ; // Option<T>::None
    ///
    #[named]
    fn proc_decl_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ProcDeclOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// ForwardDecl: PROCEDURE "\^" ForwardDeclOpt /* Option */ IdentDef ForwardDeclOpt0 /* Option */;
    ///
    #[named]
    fn forward_decl(
        &mut self,
        _p_r_o_c_e_d_u_r_e: &ParseTreeStackEntry<'t>,
        circumflex: &ParseTreeStackEntry<'t>,
        _forward_decl_opt: &ParseTreeStackEntry<'t>,
        _ident_def: &ParseTreeStackEntry<'t>,
        _forward_decl_opt0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let circumflex = *circumflex.token(parse_tree)?;
        let forward_decl_opt0 =
            if let Some(ASTType::ForwardDeclOpt0(forward_decl_opt0)) = self.pop(context) {
                forward_decl_opt0
            } else {
                bail!("{}: Expecting ASTType::ForwardDeclOpt0", context);
            };
        let ident_def = if let Some(ASTType::IdentDef(ident_def)) = self.pop(context) {
            ident_def
        } else {
            bail!("{}: Expecting ASTType::IdentDef", context);
        };
        let forward_decl_opt =
            if let Some(ASTType::ForwardDeclOpt(forward_decl_opt)) = self.pop(context) {
                forward_decl_opt
            } else {
                bail!("{}: Expecting ASTType::ForwardDeclOpt", context);
            };
        let p_r_o_c_e_d_u_r_e =
            if let Some(ASTType::PROCEDURE(p_r_o_c_e_d_u_r_e)) = self.pop(context) {
                p_r_o_c_e_d_u_r_e
            } else {
                bail!("{}: Expecting ASTType::PROCEDURE", context);
            };
        let forward_decl_built = ForwardDeclBuilder::default()
            .p_r_o_c_e_d_u_r_e(Box::new(p_r_o_c_e_d_u_r_e))
            .circumflex(circumflex)
            .forward_decl_opt(forward_decl_opt)
            .ident_def(Box::new(ident_def))
            .forward_decl_opt0(forward_decl_opt0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.forward_decl(&forward_decl_built)?;
        self.push(ASTType::ForwardDecl(forward_decl_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// ForwardDeclOpt0: FormalPars; // Option<T>::Some
    ///
    #[named]
    fn forward_decl_opt0_0(
        &mut self,
        _formal_pars: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let formal_pars = if let Some(ASTType::FormalPars(formal_pars)) = self.pop(context) {
            formal_pars
        } else {
            bail!("{}: Expecting ASTType::FormalPars", context);
        };
        let forward_decl_opt0_0_built = ForwardDeclOpt0Builder::default()
            .formal_pars(Box::new(formal_pars))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ForwardDeclOpt0(Some(Box::new(forward_decl_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// ForwardDeclOpt0: ; // Option<T>::None
    ///
    #[named]
    fn forward_decl_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ForwardDeclOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// ForwardDeclOpt: Receiver; // Option<T>::Some
    ///
    #[named]
    fn forward_decl_opt_0(
        &mut self,
        _receiver: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let receiver = if let Some(ASTType::Receiver(receiver)) = self.pop(context) {
            receiver
        } else {
            bail!("{}: Expecting ASTType::Receiver", context);
        };
        let forward_decl_opt_0_built = ForwardDeclOptBuilder::default()
            .receiver(Box::new(receiver))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ForwardDeclOpt(Some(Box::new(forward_decl_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// ForwardDeclOpt: ; // Option<T>::None
    ///
    #[named]
    fn forward_decl_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ForwardDeclOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// FormalPars: "\(" FormalParsOpt /* Option */ "\)" FormalParsOpt0 /* Option */;
    ///
    #[named]
    fn formal_pars(
        &mut self,
        l_paren: &ParseTreeStackEntry<'t>,
        _formal_pars_opt: &ParseTreeStackEntry<'t>,
        r_paren: &ParseTreeStackEntry<'t>,
        _formal_pars_opt0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = *l_paren.token(parse_tree)?;
        let r_paren = *r_paren.token(parse_tree)?;
        let formal_pars_opt0 =
            if let Some(ASTType::FormalParsOpt0(formal_pars_opt0)) = self.pop(context) {
                formal_pars_opt0
            } else {
                bail!("{}: Expecting ASTType::FormalParsOpt0", context);
            };
        let formal_pars_opt =
            if let Some(ASTType::FormalParsOpt(formal_pars_opt)) = self.pop(context) {
                formal_pars_opt
            } else {
                bail!("{}: Expecting ASTType::FormalParsOpt", context);
            };
        let formal_pars_built = FormalParsBuilder::default()
            .l_paren(l_paren)
            .formal_pars_opt(formal_pars_opt)
            .r_paren(r_paren)
            .formal_pars_opt0(formal_pars_opt0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.formal_pars(&formal_pars_built)?;
        self.push(ASTType::FormalPars(formal_pars_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// FormalParsOpt0: ":" QualIdent; // Option<T>::Some
    ///
    #[named]
    fn formal_pars_opt0_0(
        &mut self,
        colon: &ParseTreeStackEntry<'t>,
        _qual_ident: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = *colon.token(parse_tree)?;
        let qual_ident = if let Some(ASTType::QualIdent(qual_ident)) = self.pop(context) {
            qual_ident
        } else {
            bail!("{}: Expecting ASTType::QualIdent", context);
        };
        let formal_pars_opt0_0_built = FormalParsOpt0Builder::default()
            .colon(colon)
            .qual_ident(Box::new(qual_ident))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FormalParsOpt0(Some(Box::new(formal_pars_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// FormalParsOpt0: ; // Option<T>::None
    ///
    #[named]
    fn formal_pars_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FormalParsOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// FormalParsOpt: FPSection FormalParsOptList /* Vec */; // Option<T>::Some
    ///
    #[named]
    fn formal_pars_opt_0(
        &mut self,
        _f_p_section: &ParseTreeStackEntry<'t>,
        _formal_pars_opt_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let formal_pars_opt_list =
            if let Some(ASTType::FormalParsOptList(mut formal_pars_opt_list)) = self.pop(context) {
                formal_pars_opt_list.reverse();
                formal_pars_opt_list
            } else {
                bail!("{}: Expecting ASTType::FormalParsOptList", context);
            };
        let f_p_section = if let Some(ASTType::FPSection(f_p_section)) = self.pop(context) {
            f_p_section
        } else {
            bail!("{}: Expecting ASTType::FPSection", context);
        };
        let formal_pars_opt_0_built = FormalParsOptBuilder::default()
            .f_p_section(Box::new(f_p_section))
            .formal_pars_opt_list(formal_pars_opt_list)
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FormalParsOpt(Some(Box::new(formal_pars_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// FormalParsOptList: ";" FPSection FormalParsOptList; // Vec<T>::Push
    ///
    #[named]
    fn formal_pars_opt_list_0(
        &mut self,
        semicolon: &ParseTreeStackEntry<'t>,
        _f_p_section: &ParseTreeStackEntry<'t>,
        _formal_pars_opt_list: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = *semicolon.token(parse_tree)?;
        let mut formal_pars_opt_list =
            if let Some(ASTType::FormalParsOptList(formal_pars_opt_list)) = self.pop(context) {
                formal_pars_opt_list
            } else {
                bail!("{}: Expecting ASTType::FormalParsOptList", context);
            };
        let f_p_section = if let Some(ASTType::FPSection(f_p_section)) = self.pop(context) {
            f_p_section
        } else {
            bail!("{}: Expecting ASTType::FPSection", context);
        };
        let formal_pars_opt_list_0_built = FormalParsOptListBuilder::default()
            .f_p_section(Box::new(f_p_section))
            .semicolon(semicolon)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        formal_pars_opt_list.push(formal_pars_opt_list_0_built);
        self.push(ASTType::FormalParsOptList(formal_pars_opt_list), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// FormalParsOptList: ; // Vec<T>::New
    ///
    #[named]
    fn formal_pars_opt_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let formal_pars_opt_list_1_built = Vec::new();
        self.push(
            ASTType::FormalParsOptList(formal_pars_opt_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// FormalParsOpt: ; // Option<T>::None
    ///
    #[named]
    fn formal_pars_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FormalParsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// FPSection: FPSectionOpt /* Option */ Ident FPSectionList /* Vec */ ":" TypeDef;
    ///
    #[named]
    fn f_p_section(
        &mut self,
        _f_p_section_opt: &ParseTreeStackEntry<'t>,
        _ident: &ParseTreeStackEntry<'t>,
        _f_p_section_list: &ParseTreeStackEntry<'t>,
        colon: &ParseTreeStackEntry<'t>,
        _type_def: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = *colon.token(parse_tree)?;
        let type_def = if let Some(ASTType::TypeDef(type_def)) = self.pop(context) {
            type_def
        } else {
            bail!("{}: Expecting ASTType::TypeDef", context);
        };
        let f_p_section_list =
            if let Some(ASTType::FPSectionList(mut f_p_section_list)) = self.pop(context) {
                f_p_section_list.reverse();
                f_p_section_list
            } else {
                bail!("{}: Expecting ASTType::FPSectionList", context);
            };
        let ident = if let Some(ASTType::Ident(ident)) = self.pop(context) {
            ident
        } else {
            bail!("{}: Expecting ASTType::Ident", context);
        };
        let f_p_section_opt =
            if let Some(ASTType::FPSectionOpt(f_p_section_opt)) = self.pop(context) {
                f_p_section_opt
            } else {
                bail!("{}: Expecting ASTType::FPSectionOpt", context);
            };
        let f_p_section_built = FPSectionBuilder::default()
            .f_p_section_opt(f_p_section_opt)
            .ident(Box::new(ident))
            .f_p_section_list(f_p_section_list)
            .colon(colon)
            .type_def(Box::new(type_def))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.f_p_section(&f_p_section_built)?;
        self.push(ASTType::FPSection(f_p_section_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// FPSectionList: "," Ident FPSectionList; // Vec<T>::Push
    ///
    #[named]
    fn f_p_section_list_0(
        &mut self,
        comma: &ParseTreeStackEntry<'t>,
        _ident: &ParseTreeStackEntry<'t>,
        _f_p_section_list: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = *comma.token(parse_tree)?;
        let mut f_p_section_list =
            if let Some(ASTType::FPSectionList(f_p_section_list)) = self.pop(context) {
                f_p_section_list
            } else {
                bail!("{}: Expecting ASTType::FPSectionList", context);
            };
        let ident = if let Some(ASTType::Ident(ident)) = self.pop(context) {
            ident
        } else {
            bail!("{}: Expecting ASTType::Ident", context);
        };
        let f_p_section_list_0_built = FPSectionListBuilder::default()
            .ident(Box::new(ident))
            .comma(comma)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        f_p_section_list.push(f_p_section_list_0_built);
        self.push(ASTType::FPSectionList(f_p_section_list), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// FPSectionList: ; // Vec<T>::New
    ///
    #[named]
    fn f_p_section_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f_p_section_list_1_built = Vec::new();
        self.push(ASTType::FPSectionList(f_p_section_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// FPSectionOpt: VAR; // Option<T>::Some
    ///
    #[named]
    fn f_p_section_opt_0(
        &mut self,
        _v_a_r: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let v_a_r = if let Some(ASTType::VAR(v_a_r)) = self.pop(context) {
            v_a_r
        } else {
            bail!("{}: Expecting ASTType::VAR", context);
        };
        let f_p_section_opt_0_built = FPSectionOptBuilder::default()
            .v_a_r(Box::new(v_a_r))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FPSectionOpt(Some(Box::new(f_p_section_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// FPSectionOpt: ; // Option<T>::None
    ///
    #[named]
    fn f_p_section_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FPSectionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// Receiver: "\(" ReceiverOpt /* Option */ Ident ":" Ident "\)";
    ///
    #[named]
    fn receiver(
        &mut self,
        l_paren: &ParseTreeStackEntry<'t>,
        _receiver_opt: &ParseTreeStackEntry<'t>,
        _ident: &ParseTreeStackEntry<'t>,
        colon: &ParseTreeStackEntry<'t>,
        _ident0: &ParseTreeStackEntry<'t>,
        r_paren: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = *l_paren.token(parse_tree)?;
        let colon = *colon.token(parse_tree)?;
        let r_paren = *r_paren.token(parse_tree)?;
        let ident0 = if let Some(ASTType::Ident(ident0)) = self.pop(context) {
            ident0
        } else {
            bail!("{}: Expecting ASTType::Ident", context);
        };
        let ident = if let Some(ASTType::Ident(ident)) = self.pop(context) {
            ident
        } else {
            bail!("{}: Expecting ASTType::Ident", context);
        };
        let receiver_opt = if let Some(ASTType::ReceiverOpt(receiver_opt)) = self.pop(context) {
            receiver_opt
        } else {
            bail!("{}: Expecting ASTType::ReceiverOpt", context);
        };
        let receiver_built = ReceiverBuilder::default()
            .l_paren(l_paren)
            .receiver_opt(receiver_opt)
            .ident(Box::new(ident))
            .colon(colon)
            .ident0(Box::new(ident0))
            .r_paren(r_paren)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.receiver(&receiver_built)?;
        self.push(ASTType::Receiver(receiver_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// ReceiverOpt: VAR; // Option<T>::Some
    ///
    #[named]
    fn receiver_opt_0(
        &mut self,
        _v_a_r: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let v_a_r = if let Some(ASTType::VAR(v_a_r)) = self.pop(context) {
            v_a_r
        } else {
            bail!("{}: Expecting ASTType::VAR", context);
        };
        let receiver_opt_0_built = ReceiverOptBuilder::default()
            .v_a_r(Box::new(v_a_r))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ReceiverOpt(Some(Box::new(receiver_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// ReceiverOpt: ; // Option<T>::None
    ///
    #[named]
    fn receiver_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ReceiverOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// TypeDef: QualIdent;
    ///
    #[named]
    fn type_def_0(
        &mut self,
        _qual_ident: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qual_ident = if let Some(ASTType::QualIdent(qual_ident)) = self.pop(context) {
            qual_ident
        } else {
            bail!("{}: Expecting ASTType::QualIdent", context);
        };
        let type_def_0_built = TypeDef0Builder::default()
            .qual_ident(Box::new(qual_ident))
            .build()
            .into_diagnostic()?;
        let type_def_0_built = TypeDef::TypeDef0(type_def_0_built);
        // Calling user action here
        self.user_grammar.type_def(&type_def_0_built)?;
        self.push(ASTType::TypeDef(type_def_0_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// TypeDef: "ARRAY" TypeDefOpt /* Option */ OF TypeDef;
    ///
    #[named]
    fn type_def_1(
        &mut self,
        a_r_r_a_y: &ParseTreeStackEntry<'t>,
        _type_def_opt: &ParseTreeStackEntry<'t>,
        _o_f: &ParseTreeStackEntry<'t>,
        _type_def: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let a_r_r_a_y = *a_r_r_a_y.token(parse_tree)?;
        let type_def = if let Some(ASTType::TypeDef(type_def)) = self.pop(context) {
            type_def
        } else {
            bail!("{}: Expecting ASTType::TypeDef", context);
        };
        let o_f = if let Some(ASTType::OF(o_f)) = self.pop(context) {
            o_f
        } else {
            bail!("{}: Expecting ASTType::OF", context);
        };
        let type_def_opt = if let Some(ASTType::TypeDefOpt(type_def_opt)) = self.pop(context) {
            type_def_opt
        } else {
            bail!("{}: Expecting ASTType::TypeDefOpt", context);
        };
        let type_def_1_built = TypeDef1Builder::default()
            .a_r_r_a_y(a_r_r_a_y)
            .type_def_opt(type_def_opt)
            .o_f(Box::new(o_f))
            .type_def(Box::new(type_def))
            .build()
            .into_diagnostic()?;
        let type_def_1_built = TypeDef::TypeDef1(type_def_1_built);
        // Calling user action here
        self.user_grammar.type_def(&type_def_1_built)?;
        self.push(ASTType::TypeDef(type_def_1_built), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// TypeDef: "RECORD" TypeDefOpt0 /* Option */ FieldList TypeDefList /* Vec */ END;
    ///
    #[named]
    fn type_def_2(
        &mut self,
        r_e_c_o_r_d: &ParseTreeStackEntry<'t>,
        _type_def_opt0: &ParseTreeStackEntry<'t>,
        _field_list: &ParseTreeStackEntry<'t>,
        _type_def_list: &ParseTreeStackEntry<'t>,
        _e_n_d: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_e_c_o_r_d = *r_e_c_o_r_d.token(parse_tree)?;
        let e_n_d = if let Some(ASTType::END(e_n_d)) = self.pop(context) {
            e_n_d
        } else {
            bail!("{}: Expecting ASTType::END", context);
        };
        let type_def_list = if let Some(ASTType::TypeDefList(mut type_def_list)) = self.pop(context)
        {
            type_def_list.reverse();
            type_def_list
        } else {
            bail!("{}: Expecting ASTType::TypeDefList", context);
        };
        let field_list = if let Some(ASTType::FieldList(field_list)) = self.pop(context) {
            field_list
        } else {
            bail!("{}: Expecting ASTType::FieldList", context);
        };
        let type_def_opt0 = if let Some(ASTType::TypeDefOpt0(type_def_opt0)) = self.pop(context) {
            type_def_opt0
        } else {
            bail!("{}: Expecting ASTType::TypeDefOpt0", context);
        };
        let type_def_2_built = TypeDef2Builder::default()
            .r_e_c_o_r_d(r_e_c_o_r_d)
            .type_def_opt0(type_def_opt0)
            .field_list(Box::new(field_list))
            .type_def_list(type_def_list)
            .e_n_d(Box::new(e_n_d))
            .build()
            .into_diagnostic()?;
        let type_def_2_built = TypeDef::TypeDef2(type_def_2_built);
        // Calling user action here
        self.user_grammar.type_def(&type_def_2_built)?;
        self.push(ASTType::TypeDef(type_def_2_built), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// TypeDefList: ";" FieldList TypeDefList; // Vec<T>::Push
    ///
    #[named]
    fn type_def_list_0(
        &mut self,
        semicolon: &ParseTreeStackEntry<'t>,
        _field_list: &ParseTreeStackEntry<'t>,
        _type_def_list: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = *semicolon.token(parse_tree)?;
        let mut type_def_list = if let Some(ASTType::TypeDefList(type_def_list)) = self.pop(context)
        {
            type_def_list
        } else {
            bail!("{}: Expecting ASTType::TypeDefList", context);
        };
        let field_list = if let Some(ASTType::FieldList(field_list)) = self.pop(context) {
            field_list
        } else {
            bail!("{}: Expecting ASTType::FieldList", context);
        };
        let type_def_list_0_built = TypeDefListBuilder::default()
            .field_list(Box::new(field_list))
            .semicolon(semicolon)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        type_def_list.push(type_def_list_0_built);
        self.push(ASTType::TypeDefList(type_def_list), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// TypeDefList: ; // Vec<T>::New
    ///
    #[named]
    fn type_def_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def_list_1_built = Vec::new();
        self.push(ASTType::TypeDefList(type_def_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// TypeDef: "POINTER" TO TypeDef;
    ///
    #[named]
    fn type_def_3(
        &mut self,
        p_o_i_n_t_e_r: &ParseTreeStackEntry<'t>,
        _t_o: &ParseTreeStackEntry<'t>,
        _type_def: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let p_o_i_n_t_e_r = *p_o_i_n_t_e_r.token(parse_tree)?;
        let type_def = if let Some(ASTType::TypeDef(type_def)) = self.pop(context) {
            type_def
        } else {
            bail!("{}: Expecting ASTType::TypeDef", context);
        };
        let t_o = if let Some(ASTType::TO(t_o)) = self.pop(context) {
            t_o
        } else {
            bail!("{}: Expecting ASTType::TO", context);
        };
        let type_def_3_built = TypeDef3Builder::default()
            .p_o_i_n_t_e_r(p_o_i_n_t_e_r)
            .t_o(Box::new(t_o))
            .type_def(Box::new(type_def))
            .build()
            .into_diagnostic()?;
        let type_def_3_built = TypeDef::TypeDef3(type_def_3_built);
        // Calling user action here
        self.user_grammar.type_def(&type_def_3_built)?;
        self.push(ASTType::TypeDef(type_def_3_built), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// TypeDef: PROCEDURE TypeDefOpt1 /* Option */;
    ///
    #[named]
    fn type_def_4(
        &mut self,
        _p_r_o_c_e_d_u_r_e: &ParseTreeStackEntry<'t>,
        _type_def_opt1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def_opt1 = if let Some(ASTType::TypeDefOpt1(type_def_opt1)) = self.pop(context) {
            type_def_opt1
        } else {
            bail!("{}: Expecting ASTType::TypeDefOpt1", context);
        };
        let p_r_o_c_e_d_u_r_e =
            if let Some(ASTType::PROCEDURE(p_r_o_c_e_d_u_r_e)) = self.pop(context) {
                p_r_o_c_e_d_u_r_e
            } else {
                bail!("{}: Expecting ASTType::PROCEDURE", context);
            };
        let type_def_4_built = TypeDef4Builder::default()
            .p_r_o_c_e_d_u_r_e(Box::new(p_r_o_c_e_d_u_r_e))
            .type_def_opt1(type_def_opt1)
            .build()
            .into_diagnostic()?;
        let type_def_4_built = TypeDef::TypeDef4(type_def_4_built);
        // Calling user action here
        self.user_grammar.type_def(&type_def_4_built)?;
        self.push(ASTType::TypeDef(type_def_4_built), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// TypeDefOpt1: FormalPars; // Option<T>::Some
    ///
    #[named]
    fn type_def_opt1_0(
        &mut self,
        _formal_pars: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let formal_pars = if let Some(ASTType::FormalPars(formal_pars)) = self.pop(context) {
            formal_pars
        } else {
            bail!("{}: Expecting ASTType::FormalPars", context);
        };
        let type_def_opt1_0_built = TypeDefOpt1Builder::default()
            .formal_pars(Box::new(formal_pars))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::TypeDefOpt1(Some(Box::new(type_def_opt1_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// TypeDefOpt1: ; // Option<T>::None
    ///
    #[named]
    fn type_def_opt1_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypeDefOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// TypeDefOpt0: "\(" QualIdent "\)"; // Option<T>::Some
    ///
    #[named]
    fn type_def_opt0_0(
        &mut self,
        l_paren: &ParseTreeStackEntry<'t>,
        _qual_ident: &ParseTreeStackEntry<'t>,
        r_paren: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = *l_paren.token(parse_tree)?;
        let r_paren = *r_paren.token(parse_tree)?;
        let qual_ident = if let Some(ASTType::QualIdent(qual_ident)) = self.pop(context) {
            qual_ident
        } else {
            bail!("{}: Expecting ASTType::QualIdent", context);
        };
        let type_def_opt0_0_built = TypeDefOpt0Builder::default()
            .l_paren(l_paren)
            .qual_ident(Box::new(qual_ident))
            .r_paren(r_paren)
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::TypeDefOpt0(Some(Box::new(type_def_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// TypeDefOpt0: ; // Option<T>::None
    ///
    #[named]
    fn type_def_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypeDefOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// TypeDefOpt: ConstExpr TypeDefOptList /* Vec */; // Option<T>::Some
    ///
    #[named]
    fn type_def_opt_0(
        &mut self,
        _const_expr: &ParseTreeStackEntry<'t>,
        _type_def_opt_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def_opt_list =
            if let Some(ASTType::TypeDefOptList(mut type_def_opt_list)) = self.pop(context) {
                type_def_opt_list.reverse();
                type_def_opt_list
            } else {
                bail!("{}: Expecting ASTType::TypeDefOptList", context);
            };
        let const_expr = if let Some(ASTType::ConstExpr(const_expr)) = self.pop(context) {
            const_expr
        } else {
            bail!("{}: Expecting ASTType::ConstExpr", context);
        };
        let type_def_opt_0_built = TypeDefOptBuilder::default()
            .const_expr(Box::new(const_expr))
            .type_def_opt_list(type_def_opt_list)
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::TypeDefOpt(Some(Box::new(type_def_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// TypeDefOptList: "," ConstExpr TypeDefOptList; // Vec<T>::Push
    ///
    #[named]
    fn type_def_opt_list_0(
        &mut self,
        comma: &ParseTreeStackEntry<'t>,
        _const_expr: &ParseTreeStackEntry<'t>,
        _type_def_opt_list: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = *comma.token(parse_tree)?;
        let mut type_def_opt_list =
            if let Some(ASTType::TypeDefOptList(type_def_opt_list)) = self.pop(context) {
                type_def_opt_list
            } else {
                bail!("{}: Expecting ASTType::TypeDefOptList", context);
            };
        let const_expr = if let Some(ASTType::ConstExpr(const_expr)) = self.pop(context) {
            const_expr
        } else {
            bail!("{}: Expecting ASTType::ConstExpr", context);
        };
        let type_def_opt_list_0_built = TypeDefOptListBuilder::default()
            .const_expr(Box::new(const_expr))
            .comma(comma)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        type_def_opt_list.push(type_def_opt_list_0_built);
        self.push(ASTType::TypeDefOptList(type_def_opt_list), context);
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// TypeDefOptList: ; // Vec<T>::New
    ///
    #[named]
    fn type_def_opt_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def_opt_list_1_built = Vec::new();
        self.push(ASTType::TypeDefOptList(type_def_opt_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// TypeDefOpt: ; // Option<T>::None
    ///
    #[named]
    fn type_def_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypeDefOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// FieldList: FieldListOpt /* Option */;
    ///
    #[named]
    fn field_list(
        &mut self,
        _field_list_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let field_list_opt = if let Some(ASTType::FieldListOpt(field_list_opt)) = self.pop(context)
        {
            field_list_opt
        } else {
            bail!("{}: Expecting ASTType::FieldListOpt", context);
        };
        let field_list_built = FieldListBuilder::default()
            .field_list_opt(field_list_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.field_list(&field_list_built)?;
        self.push(ASTType::FieldList(field_list_built), context);
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// FieldListOpt: IdentList ":" TypeDef; // Option<T>::Some
    ///
    #[named]
    fn field_list_opt_0(
        &mut self,
        _ident_list: &ParseTreeStackEntry<'t>,
        colon: &ParseTreeStackEntry<'t>,
        _type_def: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = *colon.token(parse_tree)?;
        let type_def = if let Some(ASTType::TypeDef(type_def)) = self.pop(context) {
            type_def
        } else {
            bail!("{}: Expecting ASTType::TypeDef", context);
        };
        let ident_list = if let Some(ASTType::IdentList(ident_list)) = self.pop(context) {
            ident_list
        } else {
            bail!("{}: Expecting ASTType::IdentList", context);
        };
        let field_list_opt_0_built = FieldListOptBuilder::default()
            .ident_list(Box::new(ident_list))
            .colon(colon)
            .type_def(Box::new(type_def))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FieldListOpt(Some(Box::new(field_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// FieldListOpt: ; // Option<T>::None
    ///
    #[named]
    fn field_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FieldListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// StatementSeq: Statement StatementSeqList /* Vec */;
    ///
    #[named]
    fn statement_seq(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _statement_seq_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq_list =
            if let Some(ASTType::StatementSeqList(mut statement_seq_list)) = self.pop(context) {
                statement_seq_list.reverse();
                statement_seq_list
            } else {
                bail!("{}: Expecting ASTType::StatementSeqList", context);
            };
        let statement = if let Some(ASTType::Statement(statement)) = self.pop(context) {
            statement
        } else {
            bail!("{}: Expecting ASTType::Statement", context);
        };
        let statement_seq_built = StatementSeqBuilder::default()
            .statement(Box::new(statement))
            .statement_seq_list(statement_seq_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.statement_seq(&statement_seq_built)?;
        self.push(ASTType::StatementSeq(statement_seq_built), context);
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// StatementSeqList: ";" Statement StatementSeqList; // Vec<T>::Push
    ///
    #[named]
    fn statement_seq_list_0(
        &mut self,
        semicolon: &ParseTreeStackEntry<'t>,
        _statement: &ParseTreeStackEntry<'t>,
        _statement_seq_list: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = *semicolon.token(parse_tree)?;
        let mut statement_seq_list =
            if let Some(ASTType::StatementSeqList(statement_seq_list)) = self.pop(context) {
                statement_seq_list
            } else {
                bail!("{}: Expecting ASTType::StatementSeqList", context);
            };
        let statement = if let Some(ASTType::Statement(statement)) = self.pop(context) {
            statement
        } else {
            bail!("{}: Expecting ASTType::Statement", context);
        };
        let statement_seq_list_0_built = StatementSeqListBuilder::default()
            .statement(Box::new(statement))
            .semicolon(semicolon)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        statement_seq_list.push(statement_seq_list_0_built);
        self.push(ASTType::StatementSeqList(statement_seq_list), context);
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// StatementSeqList: ; // Vec<T>::New
    ///
    #[named]
    fn statement_seq_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq_list_1_built = Vec::new();
        self.push(
            ASTType::StatementSeqList(statement_seq_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// Statement: Designator StatementSuffix;
    ///
    #[named]
    fn statement_0(
        &mut self,
        _designator: &ParseTreeStackEntry<'t>,
        _statement_suffix: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_suffix =
            if let Some(ASTType::StatementSuffix(statement_suffix)) = self.pop(context) {
                statement_suffix
            } else {
                bail!("{}: Expecting ASTType::StatementSuffix", context);
            };
        let designator = if let Some(ASTType::Designator(designator)) = self.pop(context) {
            designator
        } else {
            bail!("{}: Expecting ASTType::Designator", context);
        };
        let statement_0_built = Statement0Builder::default()
            .designator(Box::new(designator))
            .statement_suffix(Box::new(statement_suffix))
            .build()
            .into_diagnostic()?;
        let statement_0_built = Statement::Statement0(statement_0_built);
        // Calling user action here
        self.user_grammar.statement(&statement_0_built)?;
        self.push(ASTType::Statement(statement_0_built), context);
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// StatementSuffix: ":=" Expr;
    ///
    #[named]
    fn statement_suffix_0(
        &mut self,
        colon_equ: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_equ = *colon_equ.token(parse_tree)?;
        let expr = if let Some(ASTType::Expr(expr)) = self.pop(context) {
            expr
        } else {
            bail!("{}: Expecting ASTType::Expr", context);
        };
        let statement_suffix_0_built = StatementSuffix0Builder::default()
            .colon_equ(colon_equ)
            .expr(Box::new(expr))
            .build()
            .into_diagnostic()?;
        let statement_suffix_0_built = StatementSuffix::StatementSuffix0(statement_suffix_0_built);
        self.push(ASTType::StatementSuffix(statement_suffix_0_built), context);
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// StatementSuffix: StatementOpt /* Option */;
    ///
    #[named]
    fn statement_suffix_1(
        &mut self,
        _statement_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt = if let Some(ASTType::StatementOpt(statement_opt)) = self.pop(context) {
            statement_opt
        } else {
            bail!("{}: Expecting ASTType::StatementOpt", context);
        };
        let statement_suffix_1_built = StatementSuffix1Builder::default()
            .statement_opt(statement_opt)
            .build()
            .into_diagnostic()?;
        let statement_suffix_1_built = StatementSuffix::StatementSuffix1(statement_suffix_1_built);
        self.push(ASTType::StatementSuffix(statement_suffix_1_built), context);
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// Statement: IF Expr THEN StatementSeq StatementList /* Vec */ StatementOpt0 /* Option */ END;
    ///
    #[named]
    fn statement_1(
        &mut self,
        _i_f: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        _t_h_e_n: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _statement_list: &ParseTreeStackEntry<'t>,
        _statement_opt0: &ParseTreeStackEntry<'t>,
        _e_n_d: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let e_n_d = if let Some(ASTType::END(e_n_d)) = self.pop(context) {
            e_n_d
        } else {
            bail!("{}: Expecting ASTType::END", context);
        };
        let statement_opt0 = if let Some(ASTType::StatementOpt0(statement_opt0)) = self.pop(context)
        {
            statement_opt0
        } else {
            bail!("{}: Expecting ASTType::StatementOpt0", context);
        };
        let statement_list =
            if let Some(ASTType::StatementList(mut statement_list)) = self.pop(context) {
                statement_list.reverse();
                statement_list
            } else {
                bail!("{}: Expecting ASTType::StatementList", context);
            };
        let statement_seq = if let Some(ASTType::StatementSeq(statement_seq)) = self.pop(context) {
            statement_seq
        } else {
            bail!("{}: Expecting ASTType::StatementSeq", context);
        };
        let t_h_e_n = if let Some(ASTType::THEN(t_h_e_n)) = self.pop(context) {
            t_h_e_n
        } else {
            bail!("{}: Expecting ASTType::THEN", context);
        };
        let expr = if let Some(ASTType::Expr(expr)) = self.pop(context) {
            expr
        } else {
            bail!("{}: Expecting ASTType::Expr", context);
        };
        let i_f = if let Some(ASTType::IF(i_f)) = self.pop(context) {
            i_f
        } else {
            bail!("{}: Expecting ASTType::IF", context);
        };
        let statement_1_built = Statement1Builder::default()
            .i_f(Box::new(i_f))
            .expr(Box::new(expr))
            .t_h_e_n(Box::new(t_h_e_n))
            .statement_seq(Box::new(statement_seq))
            .statement_list(statement_list)
            .statement_opt0(statement_opt0)
            .e_n_d(Box::new(e_n_d))
            .build()
            .into_diagnostic()?;
        let statement_1_built = Statement::Statement1(statement_1_built);
        // Calling user action here
        self.user_grammar.statement(&statement_1_built)?;
        self.push(ASTType::Statement(statement_1_built), context);
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// Statement: CASE Expr OF Case StatementList0 /* Vec */ StatementOpt1 /* Option */ END;
    ///
    #[named]
    fn statement_2(
        &mut self,
        _c_a_s_e: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        _o_f: &ParseTreeStackEntry<'t>,
        _case: &ParseTreeStackEntry<'t>,
        _statement_list0: &ParseTreeStackEntry<'t>,
        _statement_opt1: &ParseTreeStackEntry<'t>,
        _e_n_d: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let e_n_d = if let Some(ASTType::END(e_n_d)) = self.pop(context) {
            e_n_d
        } else {
            bail!("{}: Expecting ASTType::END", context);
        };
        let statement_opt1 = if let Some(ASTType::StatementOpt1(statement_opt1)) = self.pop(context)
        {
            statement_opt1
        } else {
            bail!("{}: Expecting ASTType::StatementOpt1", context);
        };
        let statement_list0 =
            if let Some(ASTType::StatementList0(mut statement_list0)) = self.pop(context) {
                statement_list0.reverse();
                statement_list0
            } else {
                bail!("{}: Expecting ASTType::StatementList0", context);
            };
        let case = if let Some(ASTType::Case(case)) = self.pop(context) {
            case
        } else {
            bail!("{}: Expecting ASTType::Case", context);
        };
        let o_f = if let Some(ASTType::OF(o_f)) = self.pop(context) {
            o_f
        } else {
            bail!("{}: Expecting ASTType::OF", context);
        };
        let expr = if let Some(ASTType::Expr(expr)) = self.pop(context) {
            expr
        } else {
            bail!("{}: Expecting ASTType::Expr", context);
        };
        let c_a_s_e = if let Some(ASTType::CASE(c_a_s_e)) = self.pop(context) {
            c_a_s_e
        } else {
            bail!("{}: Expecting ASTType::CASE", context);
        };
        let statement_2_built = Statement2Builder::default()
            .c_a_s_e(Box::new(c_a_s_e))
            .expr(Box::new(expr))
            .o_f(Box::new(o_f))
            .case(Box::new(case))
            .statement_list0(statement_list0)
            .statement_opt1(statement_opt1)
            .e_n_d(Box::new(e_n_d))
            .build()
            .into_diagnostic()?;
        let statement_2_built = Statement::Statement2(statement_2_built);
        // Calling user action here
        self.user_grammar.statement(&statement_2_built)?;
        self.push(ASTType::Statement(statement_2_built), context);
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// Statement: "WHILE" Expr DO StatementSeq END;
    ///
    #[named]
    fn statement_3(
        &mut self,
        w_h_i_l_e: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        _d_o: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _e_n_d: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let w_h_i_l_e = *w_h_i_l_e.token(parse_tree)?;
        let e_n_d = if let Some(ASTType::END(e_n_d)) = self.pop(context) {
            e_n_d
        } else {
            bail!("{}: Expecting ASTType::END", context);
        };
        let statement_seq = if let Some(ASTType::StatementSeq(statement_seq)) = self.pop(context) {
            statement_seq
        } else {
            bail!("{}: Expecting ASTType::StatementSeq", context);
        };
        let d_o = if let Some(ASTType::DO(d_o)) = self.pop(context) {
            d_o
        } else {
            bail!("{}: Expecting ASTType::DO", context);
        };
        let expr = if let Some(ASTType::Expr(expr)) = self.pop(context) {
            expr
        } else {
            bail!("{}: Expecting ASTType::Expr", context);
        };
        let statement_3_built = Statement3Builder::default()
            .w_h_i_l_e(w_h_i_l_e)
            .expr(Box::new(expr))
            .d_o(Box::new(d_o))
            .statement_seq(Box::new(statement_seq))
            .e_n_d(Box::new(e_n_d))
            .build()
            .into_diagnostic()?;
        let statement_3_built = Statement::Statement3(statement_3_built);
        // Calling user action here
        self.user_grammar.statement(&statement_3_built)?;
        self.push(ASTType::Statement(statement_3_built), context);
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// Statement: "REPEAT" StatementSeq "UNTIL" Expr;
    ///
    #[named]
    fn statement_4(
        &mut self,
        r_e_p_e_a_t: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        u_n_t_i_l: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_e_p_e_a_t = *r_e_p_e_a_t.token(parse_tree)?;
        let u_n_t_i_l = *u_n_t_i_l.token(parse_tree)?;
        let expr = if let Some(ASTType::Expr(expr)) = self.pop(context) {
            expr
        } else {
            bail!("{}: Expecting ASTType::Expr", context);
        };
        let statement_seq = if let Some(ASTType::StatementSeq(statement_seq)) = self.pop(context) {
            statement_seq
        } else {
            bail!("{}: Expecting ASTType::StatementSeq", context);
        };
        let statement_4_built = Statement4Builder::default()
            .r_e_p_e_a_t(r_e_p_e_a_t)
            .statement_seq(Box::new(statement_seq))
            .u_n_t_i_l(u_n_t_i_l)
            .expr(Box::new(expr))
            .build()
            .into_diagnostic()?;
        let statement_4_built = Statement::Statement4(statement_4_built);
        // Calling user action here
        self.user_grammar.statement(&statement_4_built)?;
        self.push(ASTType::Statement(statement_4_built), context);
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// Statement: "FOR" Ident ":=" Expr TO Expr StatementOpt2 /* Option */ DO StatementSeq END;
    ///
    #[named]
    fn statement_5(
        &mut self,
        f_o_r: &ParseTreeStackEntry<'t>,
        _ident: &ParseTreeStackEntry<'t>,
        colon_equ: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        _t_o: &ParseTreeStackEntry<'t>,
        _expr0: &ParseTreeStackEntry<'t>,
        _statement_opt2: &ParseTreeStackEntry<'t>,
        _d_o: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _e_n_d: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f_o_r = *f_o_r.token(parse_tree)?;
        let colon_equ = *colon_equ.token(parse_tree)?;
        let e_n_d = if let Some(ASTType::END(e_n_d)) = self.pop(context) {
            e_n_d
        } else {
            bail!("{}: Expecting ASTType::END", context);
        };
        let statement_seq = if let Some(ASTType::StatementSeq(statement_seq)) = self.pop(context) {
            statement_seq
        } else {
            bail!("{}: Expecting ASTType::StatementSeq", context);
        };
        let d_o = if let Some(ASTType::DO(d_o)) = self.pop(context) {
            d_o
        } else {
            bail!("{}: Expecting ASTType::DO", context);
        };
        let statement_opt2 = if let Some(ASTType::StatementOpt2(statement_opt2)) = self.pop(context)
        {
            statement_opt2
        } else {
            bail!("{}: Expecting ASTType::StatementOpt2", context);
        };
        let expr0 = if let Some(ASTType::Expr(expr0)) = self.pop(context) {
            expr0
        } else {
            bail!("{}: Expecting ASTType::Expr", context);
        };
        let t_o = if let Some(ASTType::TO(t_o)) = self.pop(context) {
            t_o
        } else {
            bail!("{}: Expecting ASTType::TO", context);
        };
        let expr = if let Some(ASTType::Expr(expr)) = self.pop(context) {
            expr
        } else {
            bail!("{}: Expecting ASTType::Expr", context);
        };
        let ident = if let Some(ASTType::Ident(ident)) = self.pop(context) {
            ident
        } else {
            bail!("{}: Expecting ASTType::Ident", context);
        };
        let statement_5_built = Statement5Builder::default()
            .f_o_r(f_o_r)
            .ident(Box::new(ident))
            .colon_equ(colon_equ)
            .expr(Box::new(expr))
            .t_o(Box::new(t_o))
            .expr0(Box::new(expr0))
            .statement_opt2(statement_opt2)
            .d_o(Box::new(d_o))
            .statement_seq(Box::new(statement_seq))
            .e_n_d(Box::new(e_n_d))
            .build()
            .into_diagnostic()?;
        let statement_5_built = Statement::Statement5(statement_5_built);
        // Calling user action here
        self.user_grammar.statement(&statement_5_built)?;
        self.push(ASTType::Statement(statement_5_built), context);
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// Statement: "LOOP" StatementSeq END;
    ///
    #[named]
    fn statement_6(
        &mut self,
        l_o_o_p: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _e_n_d: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_o_o_p = *l_o_o_p.token(parse_tree)?;
        let e_n_d = if let Some(ASTType::END(e_n_d)) = self.pop(context) {
            e_n_d
        } else {
            bail!("{}: Expecting ASTType::END", context);
        };
        let statement_seq = if let Some(ASTType::StatementSeq(statement_seq)) = self.pop(context) {
            statement_seq
        } else {
            bail!("{}: Expecting ASTType::StatementSeq", context);
        };
        let statement_6_built = Statement6Builder::default()
            .l_o_o_p(l_o_o_p)
            .statement_seq(Box::new(statement_seq))
            .e_n_d(Box::new(e_n_d))
            .build()
            .into_diagnostic()?;
        let statement_6_built = Statement::Statement6(statement_6_built);
        // Calling user action here
        self.user_grammar.statement(&statement_6_built)?;
        self.push(ASTType::Statement(statement_6_built), context);
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// Statement: "WITH" Guard DO StatementSeq StatementList1 /* Vec */ StatementOpt3 /* Option */ END;
    ///
    #[named]
    fn statement_7(
        &mut self,
        w_i_t_h: &ParseTreeStackEntry<'t>,
        _guard: &ParseTreeStackEntry<'t>,
        _d_o: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _statement_list1: &ParseTreeStackEntry<'t>,
        _statement_opt3: &ParseTreeStackEntry<'t>,
        _e_n_d: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let w_i_t_h = *w_i_t_h.token(parse_tree)?;
        let e_n_d = if let Some(ASTType::END(e_n_d)) = self.pop(context) {
            e_n_d
        } else {
            bail!("{}: Expecting ASTType::END", context);
        };
        let statement_opt3 = if let Some(ASTType::StatementOpt3(statement_opt3)) = self.pop(context)
        {
            statement_opt3
        } else {
            bail!("{}: Expecting ASTType::StatementOpt3", context);
        };
        let statement_list1 =
            if let Some(ASTType::StatementList1(mut statement_list1)) = self.pop(context) {
                statement_list1.reverse();
                statement_list1
            } else {
                bail!("{}: Expecting ASTType::StatementList1", context);
            };
        let statement_seq = if let Some(ASTType::StatementSeq(statement_seq)) = self.pop(context) {
            statement_seq
        } else {
            bail!("{}: Expecting ASTType::StatementSeq", context);
        };
        let d_o = if let Some(ASTType::DO(d_o)) = self.pop(context) {
            d_o
        } else {
            bail!("{}: Expecting ASTType::DO", context);
        };
        let guard = if let Some(ASTType::Guard(guard)) = self.pop(context) {
            guard
        } else {
            bail!("{}: Expecting ASTType::Guard", context);
        };
        let statement_7_built = Statement7Builder::default()
            .w_i_t_h(w_i_t_h)
            .guard(Box::new(guard))
            .d_o(Box::new(d_o))
            .statement_seq(Box::new(statement_seq))
            .statement_list1(statement_list1)
            .statement_opt3(statement_opt3)
            .e_n_d(Box::new(e_n_d))
            .build()
            .into_diagnostic()?;
        let statement_7_built = Statement::Statement7(statement_7_built);
        // Calling user action here
        self.user_grammar.statement(&statement_7_built)?;
        self.push(ASTType::Statement(statement_7_built), context);
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// Statement: "EXIT";
    ///
    #[named]
    fn statement_8(
        &mut self,
        e_x_i_t: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let e_x_i_t = *e_x_i_t.token(parse_tree)?;
        let statement_8_built = Statement8Builder::default()
            .e_x_i_t(e_x_i_t)
            .build()
            .into_diagnostic()?;
        let statement_8_built = Statement::Statement8(statement_8_built);
        // Calling user action here
        self.user_grammar.statement(&statement_8_built)?;
        self.push(ASTType::Statement(statement_8_built), context);
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// Statement: "RETURN" StatementOpt4 /* Option */;
    ///
    #[named]
    fn statement_9(
        &mut self,
        r_e_t_u_r_n: &ParseTreeStackEntry<'t>,
        _statement_opt4: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_e_t_u_r_n = *r_e_t_u_r_n.token(parse_tree)?;
        let statement_opt4 = if let Some(ASTType::StatementOpt4(statement_opt4)) = self.pop(context)
        {
            statement_opt4
        } else {
            bail!("{}: Expecting ASTType::StatementOpt4", context);
        };
        let statement_9_built = Statement9Builder::default()
            .r_e_t_u_r_n(r_e_t_u_r_n)
            .statement_opt4(statement_opt4)
            .build()
            .into_diagnostic()?;
        let statement_9_built = Statement::Statement9(statement_9_built);
        // Calling user action here
        self.user_grammar.statement(&statement_9_built)?;
        self.push(ASTType::Statement(statement_9_built), context);
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// Statement: ";";
    ///
    #[named]
    fn statement_10(
        &mut self,
        semicolon: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = *semicolon.token(parse_tree)?;
        let statement_10_built = Statement10Builder::default()
            .semicolon(semicolon)
            .build()
            .into_diagnostic()?;
        let statement_10_built = Statement::Statement10(statement_10_built);
        // Calling user action here
        self.user_grammar.statement(&statement_10_built)?;
        self.push(ASTType::Statement(statement_10_built), context);
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// StatementList: ELSIF Expr THEN StatementSeq StatementList; // Vec<T>::Push
    ///
    #[named]
    fn statement_list_0(
        &mut self,
        _e_l_s_i_f: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        _t_h_e_n: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _statement_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut statement_list =
            if let Some(ASTType::StatementList(statement_list)) = self.pop(context) {
                statement_list
            } else {
                bail!("{}: Expecting ASTType::StatementList", context);
            };
        let statement_seq = if let Some(ASTType::StatementSeq(statement_seq)) = self.pop(context) {
            statement_seq
        } else {
            bail!("{}: Expecting ASTType::StatementSeq", context);
        };
        let t_h_e_n = if let Some(ASTType::THEN(t_h_e_n)) = self.pop(context) {
            t_h_e_n
        } else {
            bail!("{}: Expecting ASTType::THEN", context);
        };
        let expr = if let Some(ASTType::Expr(expr)) = self.pop(context) {
            expr
        } else {
            bail!("{}: Expecting ASTType::Expr", context);
        };
        let e_l_s_i_f = if let Some(ASTType::ELSIF(e_l_s_i_f)) = self.pop(context) {
            e_l_s_i_f
        } else {
            bail!("{}: Expecting ASTType::ELSIF", context);
        };
        let statement_list_0_built = StatementListBuilder::default()
            .statement_seq(Box::new(statement_seq))
            .t_h_e_n(Box::new(t_h_e_n))
            .expr(Box::new(expr))
            .e_l_s_i_f(Box::new(e_l_s_i_f))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        statement_list.push(statement_list_0_built);
        self.push(ASTType::StatementList(statement_list), context);
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// StatementList: ; // Vec<T>::New
    ///
    #[named]
    fn statement_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_list_1_built = Vec::new();
        self.push(ASTType::StatementList(statement_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// StatementList0: "\|" Case StatementList0; // Vec<T>::Push
    ///
    #[named]
    fn statement_list0_0(
        &mut self,
        or: &ParseTreeStackEntry<'t>,
        _case: &ParseTreeStackEntry<'t>,
        _statement_list0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let or = *or.token(parse_tree)?;
        let mut statement_list0 =
            if let Some(ASTType::StatementList0(statement_list0)) = self.pop(context) {
                statement_list0
            } else {
                bail!("{}: Expecting ASTType::StatementList0", context);
            };
        let case = if let Some(ASTType::Case(case)) = self.pop(context) {
            case
        } else {
            bail!("{}: Expecting ASTType::Case", context);
        };
        let statement_list0_0_built = StatementList0Builder::default()
            .case(Box::new(case))
            .or(or)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        statement_list0.push(statement_list0_0_built);
        self.push(ASTType::StatementList0(statement_list0), context);
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// StatementList0: ; // Vec<T>::New
    ///
    #[named]
    fn statement_list0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_list0_1_built = Vec::new();
        self.push(ASTType::StatementList0(statement_list0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// StatementList1: "\|" Guard DO StatementSeq StatementList1; // Vec<T>::Push
    ///
    #[named]
    fn statement_list1_0(
        &mut self,
        or: &ParseTreeStackEntry<'t>,
        _guard: &ParseTreeStackEntry<'t>,
        _d_o: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _statement_list1: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let or = *or.token(parse_tree)?;
        let mut statement_list1 =
            if let Some(ASTType::StatementList1(statement_list1)) = self.pop(context) {
                statement_list1
            } else {
                bail!("{}: Expecting ASTType::StatementList1", context);
            };
        let statement_seq = if let Some(ASTType::StatementSeq(statement_seq)) = self.pop(context) {
            statement_seq
        } else {
            bail!("{}: Expecting ASTType::StatementSeq", context);
        };
        let d_o = if let Some(ASTType::DO(d_o)) = self.pop(context) {
            d_o
        } else {
            bail!("{}: Expecting ASTType::DO", context);
        };
        let guard = if let Some(ASTType::Guard(guard)) = self.pop(context) {
            guard
        } else {
            bail!("{}: Expecting ASTType::Guard", context);
        };
        let statement_list1_0_built = StatementList1Builder::default()
            .statement_seq(Box::new(statement_seq))
            .d_o(Box::new(d_o))
            .guard(Box::new(guard))
            .or(or)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        statement_list1.push(statement_list1_0_built);
        self.push(ASTType::StatementList1(statement_list1), context);
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// StatementList1: ; // Vec<T>::New
    ///
    #[named]
    fn statement_list1_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_list1_1_built = Vec::new();
        self.push(ASTType::StatementList1(statement_list1_1_built), context);
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// StatementOpt4: Expr; // Option<T>::Some
    ///
    #[named]
    fn statement_opt4_0(
        &mut self,
        _expr: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr = if let Some(ASTType::Expr(expr)) = self.pop(context) {
            expr
        } else {
            bail!("{}: Expecting ASTType::Expr", context);
        };
        let statement_opt4_0_built = StatementOpt4Builder::default()
            .expr(Box::new(expr))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::StatementOpt4(Some(Box::new(statement_opt4_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// StatementOpt4: ; // Option<T>::None
    ///
    #[named]
    fn statement_opt4_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementOpt4(None), context);
        Ok(())
    }

    /// Semantic action for production 112:
    ///
    /// StatementOpt3: ELSE StatementSeq; // Option<T>::Some
    ///
    #[named]
    fn statement_opt3_0(
        &mut self,
        _e_l_s_e: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq = if let Some(ASTType::StatementSeq(statement_seq)) = self.pop(context) {
            statement_seq
        } else {
            bail!("{}: Expecting ASTType::StatementSeq", context);
        };
        let e_l_s_e = if let Some(ASTType::ELSE(e_l_s_e)) = self.pop(context) {
            e_l_s_e
        } else {
            bail!("{}: Expecting ASTType::ELSE", context);
        };
        let statement_opt3_0_built = StatementOpt3Builder::default()
            .e_l_s_e(Box::new(e_l_s_e))
            .statement_seq(Box::new(statement_seq))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::StatementOpt3(Some(Box::new(statement_opt3_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 113:
    ///
    /// StatementOpt3: ; // Option<T>::None
    ///
    #[named]
    fn statement_opt3_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementOpt3(None), context);
        Ok(())
    }

    /// Semantic action for production 114:
    ///
    /// StatementOpt2: "BY" ConstExpr; // Option<T>::Some
    ///
    #[named]
    fn statement_opt2_0(
        &mut self,
        b_y: &ParseTreeStackEntry<'t>,
        _const_expr: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let b_y = *b_y.token(parse_tree)?;
        let const_expr = if let Some(ASTType::ConstExpr(const_expr)) = self.pop(context) {
            const_expr
        } else {
            bail!("{}: Expecting ASTType::ConstExpr", context);
        };
        let statement_opt2_0_built = StatementOpt2Builder::default()
            .b_y(b_y)
            .const_expr(Box::new(const_expr))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::StatementOpt2(Some(Box::new(statement_opt2_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 115:
    ///
    /// StatementOpt2: ; // Option<T>::None
    ///
    #[named]
    fn statement_opt2_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementOpt2(None), context);
        Ok(())
    }

    /// Semantic action for production 116:
    ///
    /// StatementOpt1: ELSE StatementSeq; // Option<T>::Some
    ///
    #[named]
    fn statement_opt1_0(
        &mut self,
        _e_l_s_e: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq = if let Some(ASTType::StatementSeq(statement_seq)) = self.pop(context) {
            statement_seq
        } else {
            bail!("{}: Expecting ASTType::StatementSeq", context);
        };
        let e_l_s_e = if let Some(ASTType::ELSE(e_l_s_e)) = self.pop(context) {
            e_l_s_e
        } else {
            bail!("{}: Expecting ASTType::ELSE", context);
        };
        let statement_opt1_0_built = StatementOpt1Builder::default()
            .e_l_s_e(Box::new(e_l_s_e))
            .statement_seq(Box::new(statement_seq))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::StatementOpt1(Some(Box::new(statement_opt1_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 117:
    ///
    /// StatementOpt1: ; // Option<T>::None
    ///
    #[named]
    fn statement_opt1_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 118:
    ///
    /// StatementOpt0: ELSE StatementSeq; // Option<T>::Some
    ///
    #[named]
    fn statement_opt0_0(
        &mut self,
        _e_l_s_e: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq = if let Some(ASTType::StatementSeq(statement_seq)) = self.pop(context) {
            statement_seq
        } else {
            bail!("{}: Expecting ASTType::StatementSeq", context);
        };
        let e_l_s_e = if let Some(ASTType::ELSE(e_l_s_e)) = self.pop(context) {
            e_l_s_e
        } else {
            bail!("{}: Expecting ASTType::ELSE", context);
        };
        let statement_opt0_0_built = StatementOpt0Builder::default()
            .e_l_s_e(Box::new(e_l_s_e))
            .statement_seq(Box::new(statement_seq))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::StatementOpt0(Some(Box::new(statement_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 119:
    ///
    /// StatementOpt0: ; // Option<T>::None
    ///
    #[named]
    fn statement_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 120:
    ///
    /// StatementOpt: "\(" StatementOpt5 /* Option */ "\)"; // Option<T>::Some
    ///
    #[named]
    fn statement_opt_0(
        &mut self,
        l_paren: &ParseTreeStackEntry<'t>,
        _statement_opt5: &ParseTreeStackEntry<'t>,
        r_paren: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = *l_paren.token(parse_tree)?;
        let r_paren = *r_paren.token(parse_tree)?;
        let statement_opt5 = if let Some(ASTType::StatementOpt5(statement_opt5)) = self.pop(context)
        {
            statement_opt5
        } else {
            bail!("{}: Expecting ASTType::StatementOpt5", context);
        };
        let statement_opt_0_built = StatementOptBuilder::default()
            .l_paren(l_paren)
            .statement_opt5(statement_opt5)
            .r_paren(r_paren)
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::StatementOpt(Some(Box::new(statement_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 121:
    ///
    /// StatementOpt5: ExprList; // Option<T>::Some
    ///
    #[named]
    fn statement_opt5_0(
        &mut self,
        _expr_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr_list = if let Some(ASTType::ExprList(expr_list)) = self.pop(context) {
            expr_list
        } else {
            bail!("{}: Expecting ASTType::ExprList", context);
        };
        let statement_opt5_0_built = StatementOpt5Builder::default()
            .expr_list(Box::new(expr_list))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::StatementOpt5(Some(Box::new(statement_opt5_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 122:
    ///
    /// StatementOpt5: ; // Option<T>::None
    ///
    #[named]
    fn statement_opt5_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementOpt5(None), context);
        Ok(())
    }

    /// Semantic action for production 123:
    ///
    /// StatementOpt: ; // Option<T>::None
    ///
    #[named]
    fn statement_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 124:
    ///
    /// Case: CaseOpt /* Option */;
    ///
    #[named]
    fn case(
        &mut self,
        _case_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_opt = if let Some(ASTType::CaseOpt(case_opt)) = self.pop(context) {
            case_opt
        } else {
            bail!("{}: Expecting ASTType::CaseOpt", context);
        };
        let case_built = CaseBuilder::default()
            .case_opt(case_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.case(&case_built)?;
        self.push(ASTType::Case(case_built), context);
        Ok(())
    }

    /// Semantic action for production 125:
    ///
    /// CaseOpt: CaseLabels CaseOptList /* Vec */ ":" StatementSeq; // Option<T>::Some
    ///
    #[named]
    fn case_opt_0(
        &mut self,
        _case_labels: &ParseTreeStackEntry<'t>,
        _case_opt_list: &ParseTreeStackEntry<'t>,
        colon: &ParseTreeStackEntry<'t>,
        _statement_seq: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = *colon.token(parse_tree)?;
        let statement_seq = if let Some(ASTType::StatementSeq(statement_seq)) = self.pop(context) {
            statement_seq
        } else {
            bail!("{}: Expecting ASTType::StatementSeq", context);
        };
        let case_opt_list = if let Some(ASTType::CaseOptList(mut case_opt_list)) = self.pop(context)
        {
            case_opt_list.reverse();
            case_opt_list
        } else {
            bail!("{}: Expecting ASTType::CaseOptList", context);
        };
        let case_labels = if let Some(ASTType::CaseLabels(case_labels)) = self.pop(context) {
            case_labels
        } else {
            bail!("{}: Expecting ASTType::CaseLabels", context);
        };
        let case_opt_0_built = CaseOptBuilder::default()
            .case_labels(Box::new(case_labels))
            .case_opt_list(case_opt_list)
            .colon(colon)
            .statement_seq(Box::new(statement_seq))
            .build()
            .into_diagnostic()?;
        self.push(ASTType::CaseOpt(Some(Box::new(case_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 126:
    ///
    /// CaseOptList: "," CaseLabels CaseOptList; // Vec<T>::Push
    ///
    #[named]
    fn case_opt_list_0(
        &mut self,
        comma: &ParseTreeStackEntry<'t>,
        _case_labels: &ParseTreeStackEntry<'t>,
        _case_opt_list: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = *comma.token(parse_tree)?;
        let mut case_opt_list = if let Some(ASTType::CaseOptList(case_opt_list)) = self.pop(context)
        {
            case_opt_list
        } else {
            bail!("{}: Expecting ASTType::CaseOptList", context);
        };
        let case_labels = if let Some(ASTType::CaseLabels(case_labels)) = self.pop(context) {
            case_labels
        } else {
            bail!("{}: Expecting ASTType::CaseLabels", context);
        };
        let case_opt_list_0_built = CaseOptListBuilder::default()
            .case_labels(Box::new(case_labels))
            .comma(comma)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        case_opt_list.push(case_opt_list_0_built);
        self.push(ASTType::CaseOptList(case_opt_list), context);
        Ok(())
    }

    /// Semantic action for production 127:
    ///
    /// CaseOptList: ; // Vec<T>::New
    ///
    #[named]
    fn case_opt_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_opt_list_1_built = Vec::new();
        self.push(ASTType::CaseOptList(case_opt_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 128:
    ///
    /// CaseOpt: ; // Option<T>::None
    ///
    #[named]
    fn case_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CaseOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 129:
    ///
    /// CaseLabels: ConstExpr CaseLabelsOpt /* Option */;
    ///
    #[named]
    fn case_labels(
        &mut self,
        _const_expr: &ParseTreeStackEntry<'t>,
        _case_labels_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_labels_opt =
            if let Some(ASTType::CaseLabelsOpt(case_labels_opt)) = self.pop(context) {
                case_labels_opt
            } else {
                bail!("{}: Expecting ASTType::CaseLabelsOpt", context);
            };
        let const_expr = if let Some(ASTType::ConstExpr(const_expr)) = self.pop(context) {
            const_expr
        } else {
            bail!("{}: Expecting ASTType::ConstExpr", context);
        };
        let case_labels_built = CaseLabelsBuilder::default()
            .const_expr(Box::new(const_expr))
            .case_labels_opt(case_labels_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.case_labels(&case_labels_built)?;
        self.push(ASTType::CaseLabels(case_labels_built), context);
        Ok(())
    }

    /// Semantic action for production 130:
    ///
    /// CaseLabelsOpt: "\.\." ConstExpr; // Option<T>::Some
    ///
    #[named]
    fn case_labels_opt_0(
        &mut self,
        dot_dot: &ParseTreeStackEntry<'t>,
        _const_expr: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_dot = *dot_dot.token(parse_tree)?;
        let const_expr = if let Some(ASTType::ConstExpr(const_expr)) = self.pop(context) {
            const_expr
        } else {
            bail!("{}: Expecting ASTType::ConstExpr", context);
        };
        let case_labels_opt_0_built = CaseLabelsOptBuilder::default()
            .dot_dot(dot_dot)
            .const_expr(Box::new(const_expr))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::CaseLabelsOpt(Some(Box::new(case_labels_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 131:
    ///
    /// CaseLabelsOpt: ; // Option<T>::None
    ///
    #[named]
    fn case_labels_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CaseLabelsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 132:
    ///
    /// Guard: QualIdent ":" QualIdent;
    ///
    #[named]
    fn guard(
        &mut self,
        _qual_ident: &ParseTreeStackEntry<'t>,
        colon: &ParseTreeStackEntry<'t>,
        _qual_ident0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = *colon.token(parse_tree)?;
        let qual_ident0 = if let Some(ASTType::QualIdent(qual_ident0)) = self.pop(context) {
            qual_ident0
        } else {
            bail!("{}: Expecting ASTType::QualIdent", context);
        };
        let qual_ident = if let Some(ASTType::QualIdent(qual_ident)) = self.pop(context) {
            qual_ident
        } else {
            bail!("{}: Expecting ASTType::QualIdent", context);
        };
        let guard_built = GuardBuilder::default()
            .qual_ident(Box::new(qual_ident))
            .colon(colon)
            .qual_ident0(Box::new(qual_ident0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.guard(&guard_built)?;
        self.push(ASTType::Guard(guard_built), context);
        Ok(())
    }

    /// Semantic action for production 133:
    ///
    /// ConstExpr: Expr;
    ///
    #[named]
    fn const_expr(
        &mut self,
        _expr: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr = if let Some(ASTType::Expr(expr)) = self.pop(context) {
            expr
        } else {
            bail!("{}: Expecting ASTType::Expr", context);
        };
        let const_expr_built = ConstExprBuilder::default()
            .expr(Box::new(expr))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.const_expr(&const_expr_built)?;
        self.push(ASTType::ConstExpr(const_expr_built), context);
        Ok(())
    }

    /// Semantic action for production 134:
    ///
    /// Expr: SimpleExpr ExprOpt /* Option */;
    ///
    #[named]
    fn expr(
        &mut self,
        _simple_expr: &ParseTreeStackEntry<'t>,
        _expr_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr_opt = if let Some(ASTType::ExprOpt(expr_opt)) = self.pop(context) {
            expr_opt
        } else {
            bail!("{}: Expecting ASTType::ExprOpt", context);
        };
        let simple_expr = if let Some(ASTType::SimpleExpr(simple_expr)) = self.pop(context) {
            simple_expr
        } else {
            bail!("{}: Expecting ASTType::SimpleExpr", context);
        };
        let expr_built = ExprBuilder::default()
            .simple_expr(Box::new(simple_expr))
            .expr_opt(expr_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expr(&expr_built)?;
        self.push(ASTType::Expr(expr_built), context);
        Ok(())
    }

    /// Semantic action for production 135:
    ///
    /// ExprOpt: Relation SimpleExpr; // Option<T>::Some
    ///
    #[named]
    fn expr_opt_0(
        &mut self,
        _relation: &ParseTreeStackEntry<'t>,
        _simple_expr: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_expr = if let Some(ASTType::SimpleExpr(simple_expr)) = self.pop(context) {
            simple_expr
        } else {
            bail!("{}: Expecting ASTType::SimpleExpr", context);
        };
        let relation = if let Some(ASTType::Relation(relation)) = self.pop(context) {
            relation
        } else {
            bail!("{}: Expecting ASTType::Relation", context);
        };
        let expr_opt_0_built = ExprOptBuilder::default()
            .relation(Box::new(relation))
            .simple_expr(Box::new(simple_expr))
            .build()
            .into_diagnostic()?;
        self.push(ASTType::ExprOpt(Some(Box::new(expr_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 136:
    ///
    /// ExprOpt: ; // Option<T>::None
    ///
    #[named]
    fn expr_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ExprOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 137:
    ///
    /// SimpleExpr: SimpleExprOpt /* Option */ Term SimpleExprList /* Vec */;
    ///
    #[named]
    fn simple_expr(
        &mut self,
        _simple_expr_opt: &ParseTreeStackEntry<'t>,
        _term: &ParseTreeStackEntry<'t>,
        _simple_expr_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_expr_list =
            if let Some(ASTType::SimpleExprList(mut simple_expr_list)) = self.pop(context) {
                simple_expr_list.reverse();
                simple_expr_list
            } else {
                bail!("{}: Expecting ASTType::SimpleExprList", context);
            };
        let term = if let Some(ASTType::Term(term)) = self.pop(context) {
            term
        } else {
            bail!("{}: Expecting ASTType::Term", context);
        };
        let simple_expr_opt =
            if let Some(ASTType::SimpleExprOpt(simple_expr_opt)) = self.pop(context) {
                simple_expr_opt
            } else {
                bail!("{}: Expecting ASTType::SimpleExprOpt", context);
            };
        let simple_expr_built = SimpleExprBuilder::default()
            .simple_expr_opt(simple_expr_opt)
            .term(Box::new(term))
            .simple_expr_list(simple_expr_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.simple_expr(&simple_expr_built)?;
        self.push(ASTType::SimpleExpr(simple_expr_built), context);
        Ok(())
    }

    /// Semantic action for production 138:
    ///
    /// SimpleExprList: AddOp Term SimpleExprList; // Vec<T>::Push
    ///
    #[named]
    fn simple_expr_list_0(
        &mut self,
        _add_op: &ParseTreeStackEntry<'t>,
        _term: &ParseTreeStackEntry<'t>,
        _simple_expr_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut simple_expr_list =
            if let Some(ASTType::SimpleExprList(simple_expr_list)) = self.pop(context) {
                simple_expr_list
            } else {
                bail!("{}: Expecting ASTType::SimpleExprList", context);
            };
        let term = if let Some(ASTType::Term(term)) = self.pop(context) {
            term
        } else {
            bail!("{}: Expecting ASTType::Term", context);
        };
        let add_op = if let Some(ASTType::AddOp(add_op)) = self.pop(context) {
            add_op
        } else {
            bail!("{}: Expecting ASTType::AddOp", context);
        };
        let simple_expr_list_0_built = SimpleExprListBuilder::default()
            .term(Box::new(term))
            .add_op(Box::new(add_op))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        simple_expr_list.push(simple_expr_list_0_built);
        self.push(ASTType::SimpleExprList(simple_expr_list), context);
        Ok(())
    }

    /// Semantic action for production 139:
    ///
    /// SimpleExprList: ; // Vec<T>::New
    ///
    #[named]
    fn simple_expr_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_expr_list_1_built = Vec::new();
        self.push(ASTType::SimpleExprList(simple_expr_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 140:
    ///
    /// SimpleExprOpt: SimpleExprOptGroup; // Option<T>::Some
    ///
    #[named]
    fn simple_expr_opt_0(
        &mut self,
        _simple_expr_opt_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_expr_opt_group =
            if let Some(ASTType::SimpleExprOptGroup(simple_expr_opt_group)) = self.pop(context) {
                simple_expr_opt_group
            } else {
                bail!("{}: Expecting ASTType::SimpleExprOptGroup", context);
            };
        let simple_expr_opt_0_built = SimpleExprOptBuilder::default()
            .simple_expr_opt_group(Box::new(simple_expr_opt_group))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::SimpleExprOpt(Some(Box::new(simple_expr_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 141:
    ///
    /// SimpleExprOptGroup: "\+";
    ///
    #[named]
    fn simple_expr_opt_group_0(
        &mut self,
        plus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = *plus.token(parse_tree)?;
        let simple_expr_opt_group_0_built = SimpleExprOptGroup0Builder::default()
            .plus(plus)
            .build()
            .into_diagnostic()?;
        let simple_expr_opt_group_0_built =
            SimpleExprOptGroup::SimpleExprOptGroup0(simple_expr_opt_group_0_built);
        self.push(
            ASTType::SimpleExprOptGroup(simple_expr_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 142:
    ///
    /// SimpleExprOptGroup: "-";
    ///
    #[named]
    fn simple_expr_opt_group_1(
        &mut self,
        minus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = *minus.token(parse_tree)?;
        let simple_expr_opt_group_1_built = SimpleExprOptGroup1Builder::default()
            .minus(minus)
            .build()
            .into_diagnostic()?;
        let simple_expr_opt_group_1_built =
            SimpleExprOptGroup::SimpleExprOptGroup1(simple_expr_opt_group_1_built);
        self.push(
            ASTType::SimpleExprOptGroup(simple_expr_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 143:
    ///
    /// SimpleExprOpt: ; // Option<T>::None
    ///
    #[named]
    fn simple_expr_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SimpleExprOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 144:
    ///
    /// Term: Factor TermList /* Vec */;
    ///
    #[named]
    fn term(
        &mut self,
        _factor: &ParseTreeStackEntry<'t>,
        _term_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_list = if let Some(ASTType::TermList(mut term_list)) = self.pop(context) {
            term_list.reverse();
            term_list
        } else {
            bail!("{}: Expecting ASTType::TermList", context);
        };
        let factor = if let Some(ASTType::Factor(factor)) = self.pop(context) {
            factor
        } else {
            bail!("{}: Expecting ASTType::Factor", context);
        };
        let term_built = TermBuilder::default()
            .factor(Box::new(factor))
            .term_list(term_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.term(&term_built)?;
        self.push(ASTType::Term(term_built), context);
        Ok(())
    }

    /// Semantic action for production 145:
    ///
    /// TermList: MulOp Factor TermList; // Vec<T>::Push
    ///
    #[named]
    fn term_list_0(
        &mut self,
        _mul_op: &ParseTreeStackEntry<'t>,
        _factor: &ParseTreeStackEntry<'t>,
        _term_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut term_list = if let Some(ASTType::TermList(term_list)) = self.pop(context) {
            term_list
        } else {
            bail!("{}: Expecting ASTType::TermList", context);
        };
        let factor = if let Some(ASTType::Factor(factor)) = self.pop(context) {
            factor
        } else {
            bail!("{}: Expecting ASTType::Factor", context);
        };
        let mul_op = if let Some(ASTType::MulOp(mul_op)) = self.pop(context) {
            mul_op
        } else {
            bail!("{}: Expecting ASTType::MulOp", context);
        };
        let term_list_0_built = TermListBuilder::default()
            .factor(Box::new(factor))
            .mul_op(Box::new(mul_op))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        term_list.push(term_list_0_built);
        self.push(ASTType::TermList(term_list), context);
        Ok(())
    }

    /// Semantic action for production 146:
    ///
    /// TermList: ; // Vec<T>::New
    ///
    #[named]
    fn term_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_list_1_built = Vec::new();
        self.push(ASTType::TermList(term_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 147:
    ///
    /// Factor: Designator FactorOpt /* Option */;
    ///
    #[named]
    fn factor_0(
        &mut self,
        _designator: &ParseTreeStackEntry<'t>,
        _factor_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_opt = if let Some(ASTType::FactorOpt(factor_opt)) = self.pop(context) {
            factor_opt
        } else {
            bail!("{}: Expecting ASTType::FactorOpt", context);
        };
        let designator = if let Some(ASTType::Designator(designator)) = self.pop(context) {
            designator
        } else {
            bail!("{}: Expecting ASTType::Designator", context);
        };
        let factor_0_built = Factor0Builder::default()
            .designator(Box::new(designator))
            .factor_opt(factor_opt)
            .build()
            .into_diagnostic()?;
        let factor_0_built = Factor::Factor0(factor_0_built);
        // Calling user action here
        self.user_grammar.factor(&factor_0_built)?;
        self.push(ASTType::Factor(factor_0_built), context);
        Ok(())
    }

    /// Semantic action for production 148:
    ///
    /// Factor: Number;
    ///
    #[named]
    fn factor_1(
        &mut self,
        _number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = if let Some(ASTType::Number(number)) = self.pop(context) {
            number
        } else {
            bail!("{}: Expecting ASTType::Number", context);
        };
        let factor_1_built = Factor1Builder::default()
            .number(Box::new(number))
            .build()
            .into_diagnostic()?;
        let factor_1_built = Factor::Factor1(factor_1_built);
        // Calling user action here
        self.user_grammar.factor(&factor_1_built)?;
        self.push(ASTType::Factor(factor_1_built), context);
        Ok(())
    }

    /// Semantic action for production 149:
    ///
    /// Factor: Character;
    ///
    #[named]
    fn factor_2(
        &mut self,
        _character: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let character = if let Some(ASTType::Character(character)) = self.pop(context) {
            character
        } else {
            bail!("{}: Expecting ASTType::Character", context);
        };
        let factor_2_built = Factor2Builder::default()
            .character(Box::new(character))
            .build()
            .into_diagnostic()?;
        let factor_2_built = Factor::Factor2(factor_2_built);
        // Calling user action here
        self.user_grammar.factor(&factor_2_built)?;
        self.push(ASTType::Factor(factor_2_built), context);
        Ok(())
    }

    /// Semantic action for production 150:
    ///
    /// Factor: String;
    ///
    #[named]
    fn factor_3(
        &mut self,
        _string: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = if let Some(ASTType::String(string)) = self.pop(context) {
            string
        } else {
            bail!("{}: Expecting ASTType::String", context);
        };
        let factor_3_built = Factor3Builder::default()
            .string(Box::new(string))
            .build()
            .into_diagnostic()?;
        let factor_3_built = Factor::Factor3(factor_3_built);
        // Calling user action here
        self.user_grammar.factor(&factor_3_built)?;
        self.push(ASTType::Factor(factor_3_built), context);
        Ok(())
    }

    /// Semantic action for production 151:
    ///
    /// Factor: "NIL";
    ///
    #[named]
    fn factor_4(
        &mut self,
        n_i_l: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let n_i_l = *n_i_l.token(parse_tree)?;
        let factor_4_built = Factor4Builder::default()
            .n_i_l(n_i_l)
            .build()
            .into_diagnostic()?;
        let factor_4_built = Factor::Factor4(factor_4_built);
        // Calling user action here
        self.user_grammar.factor(&factor_4_built)?;
        self.push(ASTType::Factor(factor_4_built), context);
        Ok(())
    }

    /// Semantic action for production 152:
    ///
    /// Factor: Set;
    ///
    #[named]
    fn factor_5(
        &mut self,
        _set: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let set = if let Some(ASTType::Set(set)) = self.pop(context) {
            set
        } else {
            bail!("{}: Expecting ASTType::Set", context);
        };
        let factor_5_built = Factor5Builder::default()
            .set(Box::new(set))
            .build()
            .into_diagnostic()?;
        let factor_5_built = Factor::Factor5(factor_5_built);
        // Calling user action here
        self.user_grammar.factor(&factor_5_built)?;
        self.push(ASTType::Factor(factor_5_built), context);
        Ok(())
    }

    /// Semantic action for production 153:
    ///
    /// Factor: "\(" Expr "\)";
    ///
    #[named]
    fn factor_6(
        &mut self,
        l_paren: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        r_paren: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = *l_paren.token(parse_tree)?;
        let r_paren = *r_paren.token(parse_tree)?;
        let expr = if let Some(ASTType::Expr(expr)) = self.pop(context) {
            expr
        } else {
            bail!("{}: Expecting ASTType::Expr", context);
        };
        let factor_6_built = Factor6Builder::default()
            .l_paren(l_paren)
            .expr(Box::new(expr))
            .r_paren(r_paren)
            .build()
            .into_diagnostic()?;
        let factor_6_built = Factor::Factor6(factor_6_built);
        // Calling user action here
        self.user_grammar.factor(&factor_6_built)?;
        self.push(ASTType::Factor(factor_6_built), context);
        Ok(())
    }

    /// Semantic action for production 154:
    ///
    /// Factor: "~" Factor;
    ///
    #[named]
    fn factor_7(
        &mut self,
        tilde: &ParseTreeStackEntry<'t>,
        _factor: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tilde = *tilde.token(parse_tree)?;
        let factor = if let Some(ASTType::Factor(factor)) = self.pop(context) {
            factor
        } else {
            bail!("{}: Expecting ASTType::Factor", context);
        };
        let factor_7_built = Factor7Builder::default()
            .tilde(tilde)
            .factor(Box::new(factor))
            .build()
            .into_diagnostic()?;
        let factor_7_built = Factor::Factor7(factor_7_built);
        // Calling user action here
        self.user_grammar.factor(&factor_7_built)?;
        self.push(ASTType::Factor(factor_7_built), context);
        Ok(())
    }

    /// Semantic action for production 155:
    ///
    /// FactorOpt: "\(" FactorOpt0 /* Option */ "\)"; // Option<T>::Some
    ///
    #[named]
    fn factor_opt_0(
        &mut self,
        l_paren: &ParseTreeStackEntry<'t>,
        _factor_opt0: &ParseTreeStackEntry<'t>,
        r_paren: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = *l_paren.token(parse_tree)?;
        let r_paren = *r_paren.token(parse_tree)?;
        let factor_opt0 = if let Some(ASTType::FactorOpt0(factor_opt0)) = self.pop(context) {
            factor_opt0
        } else {
            bail!("{}: Expecting ASTType::FactorOpt0", context);
        };
        let factor_opt_0_built = FactorOptBuilder::default()
            .l_paren(l_paren)
            .factor_opt0(factor_opt0)
            .r_paren(r_paren)
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FactorOpt(Some(Box::new(factor_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 156:
    ///
    /// FactorOpt0: ExprList; // Option<T>::Some
    ///
    #[named]
    fn factor_opt0_0(
        &mut self,
        _expr_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr_list = if let Some(ASTType::ExprList(expr_list)) = self.pop(context) {
            expr_list
        } else {
            bail!("{}: Expecting ASTType::ExprList", context);
        };
        let factor_opt0_0_built = FactorOpt0Builder::default()
            .expr_list(Box::new(expr_list))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FactorOpt0(Some(Box::new(factor_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 157:
    ///
    /// FactorOpt0: ; // Option<T>::None
    ///
    #[named]
    fn factor_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FactorOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 158:
    ///
    /// FactorOpt: ; // Option<T>::None
    ///
    #[named]
    fn factor_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FactorOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 159:
    ///
    /// Set: "\{" SetOpt /* Option */ "\}";
    ///
    #[named]
    fn set(
        &mut self,
        l_brace: &ParseTreeStackEntry<'t>,
        _set_opt: &ParseTreeStackEntry<'t>,
        r_brace: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace = *l_brace.token(parse_tree)?;
        let r_brace = *r_brace.token(parse_tree)?;
        let set_opt = if let Some(ASTType::SetOpt(set_opt)) = self.pop(context) {
            set_opt
        } else {
            bail!("{}: Expecting ASTType::SetOpt", context);
        };
        let set_built = SetBuilder::default()
            .l_brace(l_brace)
            .set_opt(set_opt)
            .r_brace(r_brace)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.set(&set_built)?;
        self.push(ASTType::Set(set_built), context);
        Ok(())
    }

    /// Semantic action for production 160:
    ///
    /// SetOpt: Element SetOptList /* Vec */; // Option<T>::Some
    ///
    #[named]
    fn set_opt_0(
        &mut self,
        _element: &ParseTreeStackEntry<'t>,
        _set_opt_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let set_opt_list = if let Some(ASTType::SetOptList(mut set_opt_list)) = self.pop(context) {
            set_opt_list.reverse();
            set_opt_list
        } else {
            bail!("{}: Expecting ASTType::SetOptList", context);
        };
        let element = if let Some(ASTType::Element(element)) = self.pop(context) {
            element
        } else {
            bail!("{}: Expecting ASTType::Element", context);
        };
        let set_opt_0_built = SetOptBuilder::default()
            .element(Box::new(element))
            .set_opt_list(set_opt_list)
            .build()
            .into_diagnostic()?;
        self.push(ASTType::SetOpt(Some(Box::new(set_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 161:
    ///
    /// SetOptList: "," Element SetOptList; // Vec<T>::Push
    ///
    #[named]
    fn set_opt_list_0(
        &mut self,
        comma: &ParseTreeStackEntry<'t>,
        _element: &ParseTreeStackEntry<'t>,
        _set_opt_list: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = *comma.token(parse_tree)?;
        let mut set_opt_list = if let Some(ASTType::SetOptList(set_opt_list)) = self.pop(context) {
            set_opt_list
        } else {
            bail!("{}: Expecting ASTType::SetOptList", context);
        };
        let element = if let Some(ASTType::Element(element)) = self.pop(context) {
            element
        } else {
            bail!("{}: Expecting ASTType::Element", context);
        };
        let set_opt_list_0_built = SetOptListBuilder::default()
            .element(Box::new(element))
            .comma(comma)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        set_opt_list.push(set_opt_list_0_built);
        self.push(ASTType::SetOptList(set_opt_list), context);
        Ok(())
    }

    /// Semantic action for production 162:
    ///
    /// SetOptList: ; // Vec<T>::New
    ///
    #[named]
    fn set_opt_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let set_opt_list_1_built = Vec::new();
        self.push(ASTType::SetOptList(set_opt_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 163:
    ///
    /// SetOpt: ; // Option<T>::None
    ///
    #[named]
    fn set_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SetOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 164:
    ///
    /// Element: Expr ElementOpt /* Option */;
    ///
    #[named]
    fn element(
        &mut self,
        _expr: &ParseTreeStackEntry<'t>,
        _element_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_opt = if let Some(ASTType::ElementOpt(element_opt)) = self.pop(context) {
            element_opt
        } else {
            bail!("{}: Expecting ASTType::ElementOpt", context);
        };
        let expr = if let Some(ASTType::Expr(expr)) = self.pop(context) {
            expr
        } else {
            bail!("{}: Expecting ASTType::Expr", context);
        };
        let element_built = ElementBuilder::default()
            .expr(Box::new(expr))
            .element_opt(element_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.element(&element_built)?;
        self.push(ASTType::Element(element_built), context);
        Ok(())
    }

    /// Semantic action for production 165:
    ///
    /// ElementOpt: "\.\." Expr; // Option<T>::Some
    ///
    #[named]
    fn element_opt_0(
        &mut self,
        dot_dot: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_dot = *dot_dot.token(parse_tree)?;
        let expr = if let Some(ASTType::Expr(expr)) = self.pop(context) {
            expr
        } else {
            bail!("{}: Expecting ASTType::Expr", context);
        };
        let element_opt_0_built = ElementOptBuilder::default()
            .dot_dot(dot_dot)
            .expr(Box::new(expr))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ElementOpt(Some(Box::new(element_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 166:
    ///
    /// ElementOpt: ; // Option<T>::None
    ///
    #[named]
    fn element_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ElementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 167:
    ///
    /// Relation: "=";
    ///
    #[named]
    fn relation_0(
        &mut self,
        equ: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ = *equ.token(parse_tree)?;
        let relation_0_built = Relation0Builder::default()
            .equ(equ)
            .build()
            .into_diagnostic()?;
        let relation_0_built = Relation::Relation0(relation_0_built);
        // Calling user action here
        self.user_grammar.relation(&relation_0_built)?;
        self.push(ASTType::Relation(relation_0_built), context);
        Ok(())
    }

    /// Semantic action for production 168:
    ///
    /// Relation: "#";
    ///
    #[named]
    fn relation_1(
        &mut self,
        hash: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash = *hash.token(parse_tree)?;
        let relation_1_built = Relation1Builder::default()
            .hash(hash)
            .build()
            .into_diagnostic()?;
        let relation_1_built = Relation::Relation1(relation_1_built);
        // Calling user action here
        self.user_grammar.relation(&relation_1_built)?;
        self.push(ASTType::Relation(relation_1_built), context);
        Ok(())
    }

    /// Semantic action for production 169:
    ///
    /// Relation: "<";
    ///
    #[named]
    fn relation_2(
        &mut self,
        l_t: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t = *l_t.token(parse_tree)?;
        let relation_2_built = Relation2Builder::default()
            .l_t(l_t)
            .build()
            .into_diagnostic()?;
        let relation_2_built = Relation::Relation2(relation_2_built);
        // Calling user action here
        self.user_grammar.relation(&relation_2_built)?;
        self.push(ASTType::Relation(relation_2_built), context);
        Ok(())
    }

    /// Semantic action for production 170:
    ///
    /// Relation: "<=";
    ///
    #[named]
    fn relation_3(
        &mut self,
        l_t_equ: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_equ = *l_t_equ.token(parse_tree)?;
        let relation_3_built = Relation3Builder::default()
            .l_t_equ(l_t_equ)
            .build()
            .into_diagnostic()?;
        let relation_3_built = Relation::Relation3(relation_3_built);
        // Calling user action here
        self.user_grammar.relation(&relation_3_built)?;
        self.push(ASTType::Relation(relation_3_built), context);
        Ok(())
    }

    /// Semantic action for production 171:
    ///
    /// Relation: ">";
    ///
    #[named]
    fn relation_4(
        &mut self,
        g_t: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t = *g_t.token(parse_tree)?;
        let relation_4_built = Relation4Builder::default()
            .g_t(g_t)
            .build()
            .into_diagnostic()?;
        let relation_4_built = Relation::Relation4(relation_4_built);
        // Calling user action here
        self.user_grammar.relation(&relation_4_built)?;
        self.push(ASTType::Relation(relation_4_built), context);
        Ok(())
    }

    /// Semantic action for production 172:
    ///
    /// Relation: ">=";
    ///
    #[named]
    fn relation_5(
        &mut self,
        g_t_equ: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t_equ = *g_t_equ.token(parse_tree)?;
        let relation_5_built = Relation5Builder::default()
            .g_t_equ(g_t_equ)
            .build()
            .into_diagnostic()?;
        let relation_5_built = Relation::Relation5(relation_5_built);
        // Calling user action here
        self.user_grammar.relation(&relation_5_built)?;
        self.push(ASTType::Relation(relation_5_built), context);
        Ok(())
    }

    /// Semantic action for production 173:
    ///
    /// Relation: "IN";
    ///
    #[named]
    fn relation_6(
        &mut self,
        i_n: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i_n = *i_n.token(parse_tree)?;
        let relation_6_built = Relation6Builder::default()
            .i_n(i_n)
            .build()
            .into_diagnostic()?;
        let relation_6_built = Relation::Relation6(relation_6_built);
        // Calling user action here
        self.user_grammar.relation(&relation_6_built)?;
        self.push(ASTType::Relation(relation_6_built), context);
        Ok(())
    }

    /// Semantic action for production 174:
    ///
    /// Relation: "IS";
    ///
    #[named]
    fn relation_7(
        &mut self,
        i_s: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i_s = *i_s.token(parse_tree)?;
        let relation_7_built = Relation7Builder::default()
            .i_s(i_s)
            .build()
            .into_diagnostic()?;
        let relation_7_built = Relation::Relation7(relation_7_built);
        // Calling user action here
        self.user_grammar.relation(&relation_7_built)?;
        self.push(ASTType::Relation(relation_7_built), context);
        Ok(())
    }

    /// Semantic action for production 175:
    ///
    /// AddOp: "\+";
    ///
    #[named]
    fn add_op_0(
        &mut self,
        plus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = *plus.token(parse_tree)?;
        let add_op_0_built = AddOp0Builder::default()
            .plus(plus)
            .build()
            .into_diagnostic()?;
        let add_op_0_built = AddOp::AddOp0(add_op_0_built);
        // Calling user action here
        self.user_grammar.add_op(&add_op_0_built)?;
        self.push(ASTType::AddOp(add_op_0_built), context);
        Ok(())
    }

    /// Semantic action for production 176:
    ///
    /// AddOp: "-";
    ///
    #[named]
    fn add_op_1(
        &mut self,
        minus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = *minus.token(parse_tree)?;
        let add_op_1_built = AddOp1Builder::default()
            .minus(minus)
            .build()
            .into_diagnostic()?;
        let add_op_1_built = AddOp::AddOp1(add_op_1_built);
        // Calling user action here
        self.user_grammar.add_op(&add_op_1_built)?;
        self.push(ASTType::AddOp(add_op_1_built), context);
        Ok(())
    }

    /// Semantic action for production 177:
    ///
    /// AddOp: "OR";
    ///
    #[named]
    fn add_op_2(
        &mut self,
        o_r: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let o_r = *o_r.token(parse_tree)?;
        let add_op_2_built = AddOp2Builder::default()
            .o_r(o_r)
            .build()
            .into_diagnostic()?;
        let add_op_2_built = AddOp::AddOp2(add_op_2_built);
        // Calling user action here
        self.user_grammar.add_op(&add_op_2_built)?;
        self.push(ASTType::AddOp(add_op_2_built), context);
        Ok(())
    }

    /// Semantic action for production 178:
    ///
    /// MulOp: "\*";
    ///
    #[named]
    fn mul_op_0(
        &mut self,
        star: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = *star.token(parse_tree)?;
        let mul_op_0_built = MulOp0Builder::default()
            .star(star)
            .build()
            .into_diagnostic()?;
        let mul_op_0_built = MulOp::MulOp0(mul_op_0_built);
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_0_built)?;
        self.push(ASTType::MulOp(mul_op_0_built), context);
        Ok(())
    }

    /// Semantic action for production 179:
    ///
    /// MulOp: "/";
    ///
    #[named]
    fn mul_op_1(
        &mut self,
        slash: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let slash = *slash.token(parse_tree)?;
        let mul_op_1_built = MulOp1Builder::default()
            .slash(slash)
            .build()
            .into_diagnostic()?;
        let mul_op_1_built = MulOp::MulOp1(mul_op_1_built);
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_1_built)?;
        self.push(ASTType::MulOp(mul_op_1_built), context);
        Ok(())
    }

    /// Semantic action for production 180:
    ///
    /// MulOp: "DIV";
    ///
    #[named]
    fn mul_op_2(
        &mut self,
        d_i_v: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let d_i_v = *d_i_v.token(parse_tree)?;
        let mul_op_2_built = MulOp2Builder::default()
            .d_i_v(d_i_v)
            .build()
            .into_diagnostic()?;
        let mul_op_2_built = MulOp::MulOp2(mul_op_2_built);
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_2_built)?;
        self.push(ASTType::MulOp(mul_op_2_built), context);
        Ok(())
    }

    /// Semantic action for production 181:
    ///
    /// MulOp: "MOD";
    ///
    #[named]
    fn mul_op_3(
        &mut self,
        m_o_d: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_o_d = *m_o_d.token(parse_tree)?;
        let mul_op_3_built = MulOp3Builder::default()
            .m_o_d(m_o_d)
            .build()
            .into_diagnostic()?;
        let mul_op_3_built = MulOp::MulOp3(mul_op_3_built);
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_3_built)?;
        self.push(ASTType::MulOp(mul_op_3_built), context);
        Ok(())
    }

    /// Semantic action for production 182:
    ///
    /// MulOp: "&";
    ///
    #[named]
    fn mul_op_4(
        &mut self,
        amp: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let amp = *amp.token(parse_tree)?;
        let mul_op_4_built = MulOp4Builder::default()
            .amp(amp)
            .build()
            .into_diagnostic()?;
        let mul_op_4_built = MulOp::MulOp4(mul_op_4_built);
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_4_built)?;
        self.push(ASTType::MulOp(mul_op_4_built), context);
        Ok(())
    }

    /// Semantic action for production 183:
    ///
    /// Designator: QualIdent DesignatorList /* Vec */;
    ///
    #[named]
    fn designator(
        &mut self,
        _qual_ident: &ParseTreeStackEntry<'t>,
        _designator_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let designator_list =
            if let Some(ASTType::DesignatorList(mut designator_list)) = self.pop(context) {
                designator_list.reverse();
                designator_list
            } else {
                bail!("{}: Expecting ASTType::DesignatorList", context);
            };
        let qual_ident = if let Some(ASTType::QualIdent(qual_ident)) = self.pop(context) {
            qual_ident
        } else {
            bail!("{}: Expecting ASTType::QualIdent", context);
        };
        let designator_built = DesignatorBuilder::default()
            .qual_ident(Box::new(qual_ident))
            .designator_list(designator_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.designator(&designator_built)?;
        self.push(ASTType::Designator(designator_built), context);
        Ok(())
    }

    /// Semantic action for production 184:
    ///
    /// DesignatorList: DesignatorSuffix DesignatorList; // Vec<T>::Push
    ///
    #[named]
    fn designator_list_0(
        &mut self,
        _designator_suffix: &ParseTreeStackEntry<'t>,
        _designator_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut designator_list =
            if let Some(ASTType::DesignatorList(designator_list)) = self.pop(context) {
                designator_list
            } else {
                bail!("{}: Expecting ASTType::DesignatorList", context);
            };
        let designator_suffix =
            if let Some(ASTType::DesignatorSuffix(designator_suffix)) = self.pop(context) {
                designator_suffix
            } else {
                bail!("{}: Expecting ASTType::DesignatorSuffix", context);
            };
        let designator_list_0_built = DesignatorListBuilder::default()
            .designator_suffix(Box::new(designator_suffix))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        designator_list.push(designator_list_0_built);
        self.push(ASTType::DesignatorList(designator_list), context);
        Ok(())
    }

    /// Semantic action for production 185:
    ///
    /// DesignatorList: ; // Vec<T>::New
    ///
    #[named]
    fn designator_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let designator_list_1_built = Vec::new();
        self.push(ASTType::DesignatorList(designator_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 186:
    ///
    /// DesignatorSuffix: "\." Ident;
    ///
    #[named]
    fn designator_suffix_0(
        &mut self,
        dot: &ParseTreeStackEntry<'t>,
        _ident: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot = *dot.token(parse_tree)?;
        let ident = if let Some(ASTType::Ident(ident)) = self.pop(context) {
            ident
        } else {
            bail!("{}: Expecting ASTType::Ident", context);
        };
        let designator_suffix_0_built = DesignatorSuffix0Builder::default()
            .dot(dot)
            .ident(Box::new(ident))
            .build()
            .into_diagnostic()?;
        let designator_suffix_0_built =
            DesignatorSuffix::DesignatorSuffix0(designator_suffix_0_built);
        // Calling user action here
        self.user_grammar
            .designator_suffix(&designator_suffix_0_built)?;
        self.push(
            ASTType::DesignatorSuffix(designator_suffix_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 187:
    ///
    /// DesignatorSuffix: "\[" ExprList "\]";
    ///
    #[named]
    fn designator_suffix_1(
        &mut self,
        l_bracket: &ParseTreeStackEntry<'t>,
        _expr_list: &ParseTreeStackEntry<'t>,
        r_bracket: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket = *l_bracket.token(parse_tree)?;
        let r_bracket = *r_bracket.token(parse_tree)?;
        let expr_list = if let Some(ASTType::ExprList(expr_list)) = self.pop(context) {
            expr_list
        } else {
            bail!("{}: Expecting ASTType::ExprList", context);
        };
        let designator_suffix_1_built = DesignatorSuffix1Builder::default()
            .l_bracket(l_bracket)
            .expr_list(Box::new(expr_list))
            .r_bracket(r_bracket)
            .build()
            .into_diagnostic()?;
        let designator_suffix_1_built =
            DesignatorSuffix::DesignatorSuffix1(designator_suffix_1_built);
        // Calling user action here
        self.user_grammar
            .designator_suffix(&designator_suffix_1_built)?;
        self.push(
            ASTType::DesignatorSuffix(designator_suffix_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 188:
    ///
    /// DesignatorSuffix: "\^";
    ///
    #[named]
    fn designator_suffix_2(
        &mut self,
        circumflex: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let circumflex = *circumflex.token(parse_tree)?;
        let designator_suffix_2_built = DesignatorSuffix2Builder::default()
            .circumflex(circumflex)
            .build()
            .into_diagnostic()?;
        let designator_suffix_2_built =
            DesignatorSuffix::DesignatorSuffix2(designator_suffix_2_built);
        // Calling user action here
        self.user_grammar
            .designator_suffix(&designator_suffix_2_built)?;
        self.push(
            ASTType::DesignatorSuffix(designator_suffix_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 189:
    ///
    /// ExprList: Expr ExprListList /* Vec */;
    ///
    #[named]
    fn expr_list(
        &mut self,
        _expr: &ParseTreeStackEntry<'t>,
        _expr_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr_list_list =
            if let Some(ASTType::ExprListList(mut expr_list_list)) = self.pop(context) {
                expr_list_list.reverse();
                expr_list_list
            } else {
                bail!("{}: Expecting ASTType::ExprListList", context);
            };
        let expr = if let Some(ASTType::Expr(expr)) = self.pop(context) {
            expr
        } else {
            bail!("{}: Expecting ASTType::Expr", context);
        };
        let expr_list_built = ExprListBuilder::default()
            .expr(Box::new(expr))
            .expr_list_list(expr_list_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expr_list(&expr_list_built)?;
        self.push(ASTType::ExprList(expr_list_built), context);
        Ok(())
    }

    /// Semantic action for production 190:
    ///
    /// ExprListList: "," Expr ExprListList; // Vec<T>::Push
    ///
    #[named]
    fn expr_list_list_0(
        &mut self,
        comma: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        _expr_list_list: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = *comma.token(parse_tree)?;
        let mut expr_list_list =
            if let Some(ASTType::ExprListList(expr_list_list)) = self.pop(context) {
                expr_list_list
            } else {
                bail!("{}: Expecting ASTType::ExprListList", context);
            };
        let expr = if let Some(ASTType::Expr(expr)) = self.pop(context) {
            expr
        } else {
            bail!("{}: Expecting ASTType::Expr", context);
        };
        let expr_list_list_0_built = ExprListListBuilder::default()
            .expr(Box::new(expr))
            .comma(comma)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expr_list_list.push(expr_list_list_0_built);
        self.push(ASTType::ExprListList(expr_list_list), context);
        Ok(())
    }

    /// Semantic action for production 191:
    ///
    /// ExprListList: ; // Vec<T>::New
    ///
    #[named]
    fn expr_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr_list_list_1_built = Vec::new();
        self.push(ASTType::ExprListList(expr_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 192:
    ///
    /// IdentList: IdentDef IdentListList /* Vec */;
    ///
    #[named]
    fn ident_list(
        &mut self,
        _ident_def: &ParseTreeStackEntry<'t>,
        _ident_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident_list_list =
            if let Some(ASTType::IdentListList(mut ident_list_list)) = self.pop(context) {
                ident_list_list.reverse();
                ident_list_list
            } else {
                bail!("{}: Expecting ASTType::IdentListList", context);
            };
        let ident_def = if let Some(ASTType::IdentDef(ident_def)) = self.pop(context) {
            ident_def
        } else {
            bail!("{}: Expecting ASTType::IdentDef", context);
        };
        let ident_list_built = IdentListBuilder::default()
            .ident_def(Box::new(ident_def))
            .ident_list_list(ident_list_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.ident_list(&ident_list_built)?;
        self.push(ASTType::IdentList(ident_list_built), context);
        Ok(())
    }

    /// Semantic action for production 193:
    ///
    /// IdentListList: "," IdentDef IdentListList; // Vec<T>::Push
    ///
    #[named]
    fn ident_list_list_0(
        &mut self,
        comma: &ParseTreeStackEntry<'t>,
        _ident_def: &ParseTreeStackEntry<'t>,
        _ident_list_list: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = *comma.token(parse_tree)?;
        let mut ident_list_list =
            if let Some(ASTType::IdentListList(ident_list_list)) = self.pop(context) {
                ident_list_list
            } else {
                bail!("{}: Expecting ASTType::IdentListList", context);
            };
        let ident_def = if let Some(ASTType::IdentDef(ident_def)) = self.pop(context) {
            ident_def
        } else {
            bail!("{}: Expecting ASTType::IdentDef", context);
        };
        let ident_list_list_0_built = IdentListListBuilder::default()
            .ident_def(Box::new(ident_def))
            .comma(comma)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        ident_list_list.push(ident_list_list_0_built);
        self.push(ASTType::IdentListList(ident_list_list), context);
        Ok(())
    }

    /// Semantic action for production 194:
    ///
    /// IdentListList: ; // Vec<T>::New
    ///
    #[named]
    fn ident_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident_list_list_1_built = Vec::new();
        self.push(ASTType::IdentListList(ident_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 195:
    ///
    /// QualIdent: Ident;
    ///
    #[named]
    fn qual_ident_0(
        &mut self,
        _ident: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = if let Some(ASTType::Ident(ident)) = self.pop(context) {
            ident
        } else {
            bail!("{}: Expecting ASTType::Ident", context);
        };
        let qual_ident_0_built = QualIdent0Builder::default()
            .ident(Box::new(ident))
            .build()
            .into_diagnostic()?;
        let qual_ident_0_built = QualIdent::QualIdent0(qual_ident_0_built);
        // Calling user action here
        self.user_grammar.qual_ident(&qual_ident_0_built)?;
        self.push(ASTType::QualIdent(qual_ident_0_built), context);
        Ok(())
    }

    /// Semantic action for production 196:
    ///
    /// QualIdent: QIdent;
    ///
    #[named]
    fn qual_ident_1(
        &mut self,
        _q_ident: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let q_ident = if let Some(ASTType::QIdent(q_ident)) = self.pop(context) {
            q_ident
        } else {
            bail!("{}: Expecting ASTType::QIdent", context);
        };
        let qual_ident_1_built = QualIdent1Builder::default()
            .q_ident(Box::new(q_ident))
            .build()
            .into_diagnostic()?;
        let qual_ident_1_built = QualIdent::QualIdent1(qual_ident_1_built);
        // Calling user action here
        self.user_grammar.qual_ident(&qual_ident_1_built)?;
        self.push(ASTType::QualIdent(qual_ident_1_built), context);
        Ok(())
    }

    /// Semantic action for production 197:
    ///
    /// IdentDef: Ident IdentDefOpt /* Option */;
    ///
    #[named]
    fn ident_def(
        &mut self,
        _ident: &ParseTreeStackEntry<'t>,
        _ident_def_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident_def_opt = if let Some(ASTType::IdentDefOpt(ident_def_opt)) = self.pop(context) {
            ident_def_opt
        } else {
            bail!("{}: Expecting ASTType::IdentDefOpt", context);
        };
        let ident = if let Some(ASTType::Ident(ident)) = self.pop(context) {
            ident
        } else {
            bail!("{}: Expecting ASTType::Ident", context);
        };
        let ident_def_built = IdentDefBuilder::default()
            .ident(Box::new(ident))
            .ident_def_opt(ident_def_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.ident_def(&ident_def_built)?;
        self.push(ASTType::IdentDef(ident_def_built), context);
        Ok(())
    }

    /// Semantic action for production 198:
    ///
    /// IdentDefOpt: IdentDefOptGroup; // Option<T>::Some
    ///
    #[named]
    fn ident_def_opt_0(
        &mut self,
        _ident_def_opt_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident_def_opt_group =
            if let Some(ASTType::IdentDefOptGroup(ident_def_opt_group)) = self.pop(context) {
                ident_def_opt_group
            } else {
                bail!("{}: Expecting ASTType::IdentDefOptGroup", context);
            };
        let ident_def_opt_0_built = IdentDefOptBuilder::default()
            .ident_def_opt_group(Box::new(ident_def_opt_group))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::IdentDefOpt(Some(Box::new(ident_def_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 199:
    ///
    /// IdentDefOptGroup: "\*";
    ///
    #[named]
    fn ident_def_opt_group_0(
        &mut self,
        star: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = *star.token(parse_tree)?;
        let ident_def_opt_group_0_built = IdentDefOptGroup0Builder::default()
            .star(star)
            .build()
            .into_diagnostic()?;
        let ident_def_opt_group_0_built =
            IdentDefOptGroup::IdentDefOptGroup0(ident_def_opt_group_0_built);
        self.push(
            ASTType::IdentDefOptGroup(ident_def_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 200:
    ///
    /// IdentDefOptGroup: "-";
    ///
    #[named]
    fn ident_def_opt_group_1(
        &mut self,
        minus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = *minus.token(parse_tree)?;
        let ident_def_opt_group_1_built = IdentDefOptGroup1Builder::default()
            .minus(minus)
            .build()
            .into_diagnostic()?;
        let ident_def_opt_group_1_built =
            IdentDefOptGroup::IdentDefOptGroup1(ident_def_opt_group_1_built);
        self.push(
            ASTType::IdentDefOptGroup(ident_def_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 201:
    ///
    /// IdentDefOpt: ; // Option<T>::None
    ///
    #[named]
    fn ident_def_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::IdentDefOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 202:
    ///
    /// Number: Integer;
    ///
    #[named]
    fn number_0(
        &mut self,
        _integer: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = if let Some(ASTType::Integer(integer)) = self.pop(context) {
            integer
        } else {
            bail!("{}: Expecting ASTType::Integer", context);
        };
        let number_0_built = Number0Builder::default()
            .integer(Box::new(integer))
            .build()
            .into_diagnostic()?;
        let number_0_built = Number::Number0(number_0_built);
        // Calling user action here
        self.user_grammar.number(&number_0_built)?;
        self.push(ASTType::Number(number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 203:
    ///
    /// Number: Real;
    ///
    #[named]
    fn number_1(
        &mut self,
        _real: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let real = if let Some(ASTType::Real(real)) = self.pop(context) {
            real
        } else {
            bail!("{}: Expecting ASTType::Real", context);
        };
        let number_1_built = Number1Builder::default()
            .real(Box::new(real))
            .build()
            .into_diagnostic()?;
        let number_1_built = Number::Number1(number_1_built);
        // Calling user action here
        self.user_grammar.number(&number_1_built)?;
        self.push(ASTType::Number(number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 204:
    ///
    /// Real: "[0-9][0-9]*\.[0-9]*(ED[+-]?[0-9][0-9]*)?";
    ///
    #[named]
    fn real(
        &mut self,
        real: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let real = *real.token(parse_tree)?;
        let real_built = RealBuilder::default()
            .real(real)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.real(&real_built)?;
        self.push(ASTType::Real(real_built), context);
        Ok(())
    }

    /// Semantic action for production 205:
    ///
    /// Character: "[0-9][0-9A-F]*X";
    ///
    #[named]
    fn character(
        &mut self,
        character: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let character = *character.token(parse_tree)?;
        let character_built = CharacterBuilder::default()
            .character(character)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.character(&character_built)?;
        self.push(ASTType::Character(character_built), context);
        Ok(())
    }

    /// Semantic action for production 206:
    ///
    /// Integer: "[0-9][0-9]*|[0-9][0-9A-F]*H";
    ///
    #[named]
    fn integer(
        &mut self,
        integer: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = *integer.token(parse_tree)?;
        let integer_built = IntegerBuilder::default()
            .integer(integer)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.integer(&integer_built)?;
        self.push(ASTType::Integer(integer_built), context);
        Ok(())
    }

    /// Semantic action for production 207:
    ///
    /// QIdent: "[a-zA-Z_]\w*\.[a-zA-Z_]\w*";
    ///
    #[named]
    fn q_ident(
        &mut self,
        q_ident: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let q_ident = *q_ident.token(parse_tree)?;
        let q_ident_built = QIdentBuilder::default()
            .q_ident(q_ident)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.q_ident(&q_ident_built)?;
        self.push(ASTType::QIdent(q_ident_built), context);
        Ok(())
    }

    /// Semantic action for production 208:
    ///
    /// Ident: "[a-zA-Z_]\w*";
    ///
    #[named]
    fn ident(
        &mut self,
        ident: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = *ident.token(parse_tree)?;
        let ident_built = IdentBuilder::default()
            .ident(ident)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.ident(&ident_built)?;
        self.push(ASTType::Ident(ident_built), context);
        Ok(())
    }

    /// Semantic action for production 209:
    ///
    /// String: "\u{0022}[^\u{0022}]*\u{0022}|'[^']*'";
    ///
    #[named]
    fn string(
        &mut self,
        string: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = *string.token(parse_tree)?;
        let string_built = StringBuilder::default()
            .string(string)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.string(&string_built)?;
        self.push(ASTType::String(string_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for Oberon2GrammarAuto<'t, '_> {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// It is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, file_name: &Path) {
        self.file_name = file_name.to_owned();
        self.user_grammar.init(file_name);
    }

    ///
    /// This function is implemented automatically for the user's item Oberon2Grammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.b_e_g_i_n(&children[0], parse_tree),
            1 => self.c_a_s_e(&children[0], parse_tree),
            2 => self.d_o(&children[0], parse_tree),
            3 => self.e_l_s_e(&children[0], parse_tree),
            4 => self.e_l_s_i_f(&children[0], parse_tree),
            5 => self.e_n_d(&children[0], parse_tree),
            6 => self.i_f(&children[0], parse_tree),
            7 => self.o_f(&children[0], parse_tree),
            8 => self.p_r_o_c_e_d_u_r_e(&children[0], parse_tree),
            9 => self.t_h_e_n(&children[0], parse_tree),
            10 => self.t_o(&children[0], parse_tree),
            11 => self.v_a_r(&children[0], parse_tree),
            12 => self.oberon2(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                &children[8],
                parse_tree,
            ),
            13 => self.oberon2_opt0_0(&children[0], &children[1], parse_tree),
            14 => self.oberon2_opt0_1(parse_tree),
            15 => self.oberon2_opt_0(&children[0], parse_tree),
            16 => self.oberon2_opt_1(parse_tree),
            17 => self.import_list(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            18 => self.import_list_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            19 => self.import_list_list_1(parse_tree),
            20 => self.import_list_opt0_0(&children[0], &children[1], parse_tree),
            21 => self.import_list_opt0_1(parse_tree),
            22 => self.import_list_opt_0(&children[0], &children[1], parse_tree),
            23 => self.import_list_opt_1(parse_tree),
            24 => self.decl_seq(&children[0], &children[1], parse_tree),
            25 => self.decl_seq_list0_0(&children[0], &children[1], parse_tree),
            26 => self.decl_seq_list0_group_0(&children[0], &children[1], parse_tree),
            27 => self.decl_seq_list0_group_1(&children[0], &children[1], parse_tree),
            28 => self.decl_seq_list0_1(parse_tree),
            29 => self.decl_seq_list_0(&children[0], &children[1], parse_tree),
            30 => self.decl_seq_list_group_0(&children[0], &children[1], parse_tree),
            31 => self.decl_seq_list_group_list_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            32 => self.decl_seq_list_group_list_1(parse_tree),
            33 => self.decl_seq_list_group_1(&children[0], &children[1], parse_tree),
            34 => self.decl_seq_list_group_list0_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            35 => self.decl_seq_list_group_list0_1(parse_tree),
            36 => self.decl_seq_list_group_2(&children[0], &children[1], parse_tree),
            37 => self.decl_seq_list_group_list1_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            38 => self.decl_seq_list_group_list1_1(parse_tree),
            39 => self.decl_seq_list_1(parse_tree),
            40 => self.const_decl(&children[0], &children[1], &children[2], parse_tree),
            41 => self.type_decl(&children[0], &children[1], &children[2], parse_tree),
            42 => self.var_decl(&children[0], &children[1], &children[2], parse_tree),
            43 => self.proc_decl(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                &children[8],
                parse_tree,
            ),
            44 => self.proc_decl_opt1_0(&children[0], &children[1], parse_tree),
            45 => self.proc_decl_opt1_1(parse_tree),
            46 => self.proc_decl_opt0_0(&children[0], parse_tree),
            47 => self.proc_decl_opt0_1(parse_tree),
            48 => self.proc_decl_opt_0(&children[0], parse_tree),
            49 => self.proc_decl_opt_1(parse_tree),
            50 => self.forward_decl(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            51 => self.forward_decl_opt0_0(&children[0], parse_tree),
            52 => self.forward_decl_opt0_1(parse_tree),
            53 => self.forward_decl_opt_0(&children[0], parse_tree),
            54 => self.forward_decl_opt_1(parse_tree),
            55 => self.formal_pars(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            56 => self.formal_pars_opt0_0(&children[0], &children[1], parse_tree),
            57 => self.formal_pars_opt0_1(parse_tree),
            58 => self.formal_pars_opt_0(&children[0], &children[1], parse_tree),
            59 => self.formal_pars_opt_list_0(&children[0], &children[1], &children[2], parse_tree),
            60 => self.formal_pars_opt_list_1(parse_tree),
            61 => self.formal_pars_opt_1(parse_tree),
            62 => self.f_p_section(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            63 => self.f_p_section_list_0(&children[0], &children[1], &children[2], parse_tree),
            64 => self.f_p_section_list_1(parse_tree),
            65 => self.f_p_section_opt_0(&children[0], parse_tree),
            66 => self.f_p_section_opt_1(parse_tree),
            67 => self.receiver(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                parse_tree,
            ),
            68 => self.receiver_opt_0(&children[0], parse_tree),
            69 => self.receiver_opt_1(parse_tree),
            70 => self.type_def_0(&children[0], parse_tree),
            71 => self.type_def_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            72 => self.type_def_2(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            73 => self.type_def_list_0(&children[0], &children[1], &children[2], parse_tree),
            74 => self.type_def_list_1(parse_tree),
            75 => self.type_def_3(&children[0], &children[1], &children[2], parse_tree),
            76 => self.type_def_4(&children[0], &children[1], parse_tree),
            77 => self.type_def_opt1_0(&children[0], parse_tree),
            78 => self.type_def_opt1_1(parse_tree),
            79 => self.type_def_opt0_0(&children[0], &children[1], &children[2], parse_tree),
            80 => self.type_def_opt0_1(parse_tree),
            81 => self.type_def_opt_0(&children[0], &children[1], parse_tree),
            82 => self.type_def_opt_list_0(&children[0], &children[1], &children[2], parse_tree),
            83 => self.type_def_opt_list_1(parse_tree),
            84 => self.type_def_opt_1(parse_tree),
            85 => self.field_list(&children[0], parse_tree),
            86 => self.field_list_opt_0(&children[0], &children[1], &children[2], parse_tree),
            87 => self.field_list_opt_1(parse_tree),
            88 => self.statement_seq(&children[0], &children[1], parse_tree),
            89 => self.statement_seq_list_0(&children[0], &children[1], &children[2], parse_tree),
            90 => self.statement_seq_list_1(parse_tree),
            91 => self.statement_0(&children[0], &children[1], parse_tree),
            92 => self.statement_suffix_0(&children[0], &children[1], parse_tree),
            93 => self.statement_suffix_1(&children[0], parse_tree),
            94 => self.statement_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            95 => self.statement_2(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            96 => self.statement_3(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            97 => self.statement_4(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            98 => self.statement_5(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                &children[8],
                &children[9],
                parse_tree,
            ),
            99 => self.statement_6(&children[0], &children[1], &children[2], parse_tree),
            100 => self.statement_7(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            101 => self.statement_8(&children[0], parse_tree),
            102 => self.statement_9(&children[0], &children[1], parse_tree),
            103 => self.statement_10(&children[0], parse_tree),
            104 => self.statement_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            105 => self.statement_list_1(parse_tree),
            106 => self.statement_list0_0(&children[0], &children[1], &children[2], parse_tree),
            107 => self.statement_list0_1(parse_tree),
            108 => self.statement_list1_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            109 => self.statement_list1_1(parse_tree),
            110 => self.statement_opt4_0(&children[0], parse_tree),
            111 => self.statement_opt4_1(parse_tree),
            112 => self.statement_opt3_0(&children[0], &children[1], parse_tree),
            113 => self.statement_opt3_1(parse_tree),
            114 => self.statement_opt2_0(&children[0], &children[1], parse_tree),
            115 => self.statement_opt2_1(parse_tree),
            116 => self.statement_opt1_0(&children[0], &children[1], parse_tree),
            117 => self.statement_opt1_1(parse_tree),
            118 => self.statement_opt0_0(&children[0], &children[1], parse_tree),
            119 => self.statement_opt0_1(parse_tree),
            120 => self.statement_opt_0(&children[0], &children[1], &children[2], parse_tree),
            121 => self.statement_opt5_0(&children[0], parse_tree),
            122 => self.statement_opt5_1(parse_tree),
            123 => self.statement_opt_1(parse_tree),
            124 => self.case(&children[0], parse_tree),
            125 => self.case_opt_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            126 => self.case_opt_list_0(&children[0], &children[1], &children[2], parse_tree),
            127 => self.case_opt_list_1(parse_tree),
            128 => self.case_opt_1(parse_tree),
            129 => self.case_labels(&children[0], &children[1], parse_tree),
            130 => self.case_labels_opt_0(&children[0], &children[1], parse_tree),
            131 => self.case_labels_opt_1(parse_tree),
            132 => self.guard(&children[0], &children[1], &children[2], parse_tree),
            133 => self.const_expr(&children[0], parse_tree),
            134 => self.expr(&children[0], &children[1], parse_tree),
            135 => self.expr_opt_0(&children[0], &children[1], parse_tree),
            136 => self.expr_opt_1(parse_tree),
            137 => self.simple_expr(&children[0], &children[1], &children[2], parse_tree),
            138 => self.simple_expr_list_0(&children[0], &children[1], &children[2], parse_tree),
            139 => self.simple_expr_list_1(parse_tree),
            140 => self.simple_expr_opt_0(&children[0], parse_tree),
            141 => self.simple_expr_opt_group_0(&children[0], parse_tree),
            142 => self.simple_expr_opt_group_1(&children[0], parse_tree),
            143 => self.simple_expr_opt_1(parse_tree),
            144 => self.term(&children[0], &children[1], parse_tree),
            145 => self.term_list_0(&children[0], &children[1], &children[2], parse_tree),
            146 => self.term_list_1(parse_tree),
            147 => self.factor_0(&children[0], &children[1], parse_tree),
            148 => self.factor_1(&children[0], parse_tree),
            149 => self.factor_2(&children[0], parse_tree),
            150 => self.factor_3(&children[0], parse_tree),
            151 => self.factor_4(&children[0], parse_tree),
            152 => self.factor_5(&children[0], parse_tree),
            153 => self.factor_6(&children[0], &children[1], &children[2], parse_tree),
            154 => self.factor_7(&children[0], &children[1], parse_tree),
            155 => self.factor_opt_0(&children[0], &children[1], &children[2], parse_tree),
            156 => self.factor_opt0_0(&children[0], parse_tree),
            157 => self.factor_opt0_1(parse_tree),
            158 => self.factor_opt_1(parse_tree),
            159 => self.set(&children[0], &children[1], &children[2], parse_tree),
            160 => self.set_opt_0(&children[0], &children[1], parse_tree),
            161 => self.set_opt_list_0(&children[0], &children[1], &children[2], parse_tree),
            162 => self.set_opt_list_1(parse_tree),
            163 => self.set_opt_1(parse_tree),
            164 => self.element(&children[0], &children[1], parse_tree),
            165 => self.element_opt_0(&children[0], &children[1], parse_tree),
            166 => self.element_opt_1(parse_tree),
            167 => self.relation_0(&children[0], parse_tree),
            168 => self.relation_1(&children[0], parse_tree),
            169 => self.relation_2(&children[0], parse_tree),
            170 => self.relation_3(&children[0], parse_tree),
            171 => self.relation_4(&children[0], parse_tree),
            172 => self.relation_5(&children[0], parse_tree),
            173 => self.relation_6(&children[0], parse_tree),
            174 => self.relation_7(&children[0], parse_tree),
            175 => self.add_op_0(&children[0], parse_tree),
            176 => self.add_op_1(&children[0], parse_tree),
            177 => self.add_op_2(&children[0], parse_tree),
            178 => self.mul_op_0(&children[0], parse_tree),
            179 => self.mul_op_1(&children[0], parse_tree),
            180 => self.mul_op_2(&children[0], parse_tree),
            181 => self.mul_op_3(&children[0], parse_tree),
            182 => self.mul_op_4(&children[0], parse_tree),
            183 => self.designator(&children[0], &children[1], parse_tree),
            184 => self.designator_list_0(&children[0], &children[1], parse_tree),
            185 => self.designator_list_1(parse_tree),
            186 => self.designator_suffix_0(&children[0], &children[1], parse_tree),
            187 => self.designator_suffix_1(&children[0], &children[1], &children[2], parse_tree),
            188 => self.designator_suffix_2(&children[0], parse_tree),
            189 => self.expr_list(&children[0], &children[1], parse_tree),
            190 => self.expr_list_list_0(&children[0], &children[1], &children[2], parse_tree),
            191 => self.expr_list_list_1(parse_tree),
            192 => self.ident_list(&children[0], &children[1], parse_tree),
            193 => self.ident_list_list_0(&children[0], &children[1], &children[2], parse_tree),
            194 => self.ident_list_list_1(parse_tree),
            195 => self.qual_ident_0(&children[0], parse_tree),
            196 => self.qual_ident_1(&children[0], parse_tree),
            197 => self.ident_def(&children[0], &children[1], parse_tree),
            198 => self.ident_def_opt_0(&children[0], parse_tree),
            199 => self.ident_def_opt_group_0(&children[0], parse_tree),
            200 => self.ident_def_opt_group_1(&children[0], parse_tree),
            201 => self.ident_def_opt_1(parse_tree),
            202 => self.number_0(&children[0], parse_tree),
            203 => self.number_1(&children[0], parse_tree),
            204 => self.real(&children[0], parse_tree),
            205 => self.character(&children[0], parse_tree),
            206 => self.integer(&children[0], parse_tree),
            207 => self.q_ident(&children[0], parse_tree),
            208 => self.ident(&children[0], parse_tree),
            209 => self.string(&children[0], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
