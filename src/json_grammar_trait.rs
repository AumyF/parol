// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

#[allow(unused_imports)]
use crate::json_grammar::JsonGrammar;
use id_tree::Tree;
use log::trace;
use miette::{miette, IntoDiagnostic, Result};
use parol_runtime::lexer::OwnedToken;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};
use std::path::{Path, PathBuf};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait JsonGrammarTrait {
    fn init(&mut self, _file_name: &Path) {}

    /// Semantic action for user production 0:
    ///
    /// Json: Value;
    ///
    fn json(&mut self, _arg: Json) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 1:
    ///
    /// Object: <0>"\{" Pair {<0>"," Pair} <0>"\}" | <0>"\{" <0>"\}";
    ///
    fn object(&mut self, _arg: Object) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 2:
    ///
    /// Pair: String <0>":" Value;
    ///
    fn pair(&mut self, _arg: Pair) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 3:
    ///
    /// Array: <0>"\[" Value {<0>"," Value} <0>"\]" | <0>"\[" <0>"\]";
    ///
    fn array(&mut self, _arg: Array) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 4:
    ///
    /// Value: String | Number | Object | Array | <0>"true" | <0>"false" | <0>"null";
    ///
    fn value(&mut self, _arg: Value) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 5:
    ///
    /// String: <0>"\u{0022}(?:\\[\u{0022}\\/bfnrt]|u[0-9a-fA-F]{4}|[^\u{0022}\\\u0000-\u001F])*\u{0022}";
    ///
    fn string(&mut self, _arg: String) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 6:
    ///
    /// Number: <0>"-?(?:0|[1-9][0-9]*)(?:\.[0-9]+)?(?:[eE][-+]?(?:0|[1-9][0-9]*)?)?";
    ///
    fn number(&mut self, _arg: Number) -> Result<()> {
        Ok(())
    }
}

//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 2
///
/// ObjectSuffix: Pair ObjectList /* Vec */ "\}";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ObjectSuffix2 {
    pair_0: Box<Pair>,
    object_list_1: Vec<ObjectList>,
    r_brace_2: OwnedToken, /* \} */
}

///
/// Type derived for production 3
///
/// ObjectSuffix: "\}";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ObjectSuffix3 {
    r_brace_0: OwnedToken, /* \} */
}

///
/// Type derived for production 8
///
/// ArraySuffix: Value ArrayList /* Vec */ "\]";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ArraySuffix8 {
    value_0: Box<Value>,
    array_list_1: Vec<ArrayList>,
    r_bracket_2: OwnedToken, /* \] */
}

///
/// Type derived for production 9
///
/// ArraySuffix: "\]";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ArraySuffix9 {
    r_bracket_0: OwnedToken, /* \] */
}

///
/// Type derived for production 12
///
/// Value: String;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Value12 {
    string_0: Box<String>,
}

///
/// Type derived for production 13
///
/// Value: Number;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Value13 {
    number_0: Box<Number>,
}

///
/// Type derived for production 14
///
/// Value: Object;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Value14 {
    object_0: Box<Object>,
}

///
/// Type derived for production 15
///
/// Value: Array;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Value15 {
    array_0: Box<Array>,
}

///
/// Type derived for production 16
///
/// Value: "true";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Value16 {
    r#true_0: OwnedToken, /* true */
}

///
/// Type derived for production 17
///
/// Value: "false";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Value17 {
    r#false_0: OwnedToken, /* false */
}

///
/// Type derived for production 18
///
/// Value: "null";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Value18 {
    null_0: OwnedToken, /* null */
}

//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal Array
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Array {
    l_bracket_0: OwnedToken, /* \[ */
    array_suffix_1: Box<ArraySuffix>,
}

///
/// Type derived for non-terminal ArrayList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ArrayList {
    comma_0: OwnedToken, /* , */
    value_1: Box<Value>,
}

///
/// Type derived for non-terminal ArraySuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ArraySuffix {
    ArraySuffix8(ArraySuffix8),
    ArraySuffix9(ArraySuffix9),
}

///
/// Type derived for non-terminal Json
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Json {
    value_0: Box<Value>,
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number {
    number_0: OwnedToken, /* -?(?:0|[1-9][0-9]*)(?:\.[0-9]+)?(?:[eE][-+]?(?:0|[1-9][0-9]*)?)? */
}

///
/// Type derived for non-terminal Object
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Object {
    l_brace_0: OwnedToken, /* \{ */
    object_suffix_1: Box<ObjectSuffix>,
}

///
/// Type derived for non-terminal ObjectList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ObjectList {
    comma_0: OwnedToken, /* , */
    pair_1: Box<Pair>,
}

///
/// Type derived for non-terminal ObjectSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ObjectSuffix {
    ObjectSuffix2(ObjectSuffix2),
    ObjectSuffix3(ObjectSuffix3),
}

///
/// Type derived for non-terminal Pair
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Pair {
    string_0: Box<String>,
    colon_1: OwnedToken, /* : */
    value_2: Box<Value>,
}

///
/// Type derived for non-terminal String
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct String {
    string_0: OwnedToken, /* \u{0022}(?:\\[\u{0022}\\/bfnrt]|u[0-9a-fA-F]{4}|[^\u{0022}\\\u0000-\u001F])*\u{0022} */
}

///
/// Type derived for non-terminal Value
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Value {
    Value12(Value12),
    Value13(Value13),
    Value14(Value14),
    Value15(Value15),
    Value16(Value16),
    Value17(Value17),
    Value18(Value18),
}

//
// AST type of the transformed grammar
//

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType {
    Array(Array),
    ArrayList(Vec<ArrayList>),
    ArraySuffix(ArraySuffix),
    Json(Json),
    Number(Number),
    Object(Object),
    ObjectList(Vec<ObjectList>),
    ObjectSuffix(ObjectSuffix),
    Pair(Pair),
    String(String),
    Value(Value),
}

/// Auto-implemented adapter grammar
#[allow(dead_code)]
pub struct JsonGrammarAuto<'a> {
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'a mut dyn JsonGrammarTrait,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType>,
    // Path of the input file. Used for diagnostics.
    file_name: PathBuf,
}

///
/// The `JsonGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'a> JsonGrammarAuto<'a> {
    pub fn new(user_grammar: &'a mut dyn JsonGrammarTrait) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            file_name: PathBuf::default(),
        }
    }

    fn push(&mut self, item: ASTType, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    fn pop(&mut self, context: &str) -> Option<ASTType> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// Json: Value;
    ///
    fn json_0(
        &mut self,
        _value_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "json_0";
        trace!("{}", self.trace_item_stack(context));
        let value_0 = if let Some(ASTType::Value(value_0)) = self.pop(context) {
            value_0
        } else {
            Err(miette!("{}: Expecting ASTType::Value", context))?
        };
        let json_0 = JsonBuilder::default()
            .value_0(Box::new(value_0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.json(json_0.clone())?;
        self.push(ASTType::Json(json_0), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Object: "\{" ObjectSuffix;
    ///
    fn object_1(
        &mut self,
        l_brace_0: &ParseTreeStackEntry,
        _object_suffix_1: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "object_1";
        trace!("{}", self.trace_item_stack(context));
        let l_brace_0 = l_brace_0.token(parse_tree)?.to_owned();
        let object_suffix_1 =
            if let Some(ASTType::ObjectSuffix(object_suffix_1)) = self.pop(context) {
                object_suffix_1
            } else {
                Err(miette!("{}: Expecting ASTType::ObjectSuffix", context))?
            };
        let object_1 = ObjectBuilder::default()
            .l_brace_0(l_brace_0)
            .object_suffix_1(Box::new(object_suffix_1))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.object(object_1.clone())?;
        self.push(ASTType::Object(object_1), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// ObjectSuffix: Pair ObjectList /* Vec */ "\}";
    ///
    fn object_suffix_2(
        &mut self,
        _pair_0: &ParseTreeStackEntry,
        _object_list_1: &ParseTreeStackEntry,
        r_brace_2: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "object_suffix_2";
        trace!("{}", self.trace_item_stack(context));
        let r_brace_2 = r_brace_2.token(parse_tree)?.to_owned();
        let object_list_1 = if let Some(ASTType::ObjectList(mut object_list_1)) = self.pop(context)
        {
            object_list_1.reverse();
            object_list_1
        } else {
            Err(miette!("{}: Expecting ASTType::ObjectList", context))?
        };
        let pair_0 = if let Some(ASTType::Pair(pair_0)) = self.pop(context) {
            pair_0
        } else {
            Err(miette!("{}: Expecting ASTType::Pair", context))?
        };
        let object_suffix_2 = ObjectSuffix2Builder::default()
            .pair_0(Box::new(pair_0))
            .object_list_1(object_list_1)
            .r_brace_2(r_brace_2)
            .build()
            .into_diagnostic()?;
        let object_suffix_2 = ObjectSuffix::ObjectSuffix2(object_suffix_2);
        self.push(ASTType::ObjectSuffix(object_suffix_2), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// ObjectSuffix: "\}";
    ///
    fn object_suffix_3(
        &mut self,
        r_brace_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "object_suffix_3";
        trace!("{}", self.trace_item_stack(context));
        let r_brace_0 = r_brace_0.token(parse_tree)?.to_owned();
        let object_suffix_3 = ObjectSuffix3Builder::default()
            .r_brace_0(r_brace_0)
            .build()
            .into_diagnostic()?;
        let object_suffix_3 = ObjectSuffix::ObjectSuffix3(object_suffix_3);
        self.push(ASTType::ObjectSuffix(object_suffix_3), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// ObjectList: "," Pair ObjectList; // Vec<T>::Push
    ///
    fn object_list_4(
        &mut self,
        comma_0: &ParseTreeStackEntry,
        _pair_1: &ParseTreeStackEntry,
        _object_list_2: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "object_list_4";
        trace!("{}", self.trace_item_stack(context));
        let comma_0 = comma_0.token(parse_tree)?.to_owned();
        let mut object_list_2 = if let Some(ASTType::ObjectList(object_list_2)) = self.pop(context)
        {
            object_list_2
        } else {
            Err(miette!("{}: Expecting ASTType::ObjectList", context))?
        };
        let pair_1 = if let Some(ASTType::Pair(pair_1)) = self.pop(context) {
            pair_1
        } else {
            Err(miette!("{}: Expecting ASTType::Pair", context))?
        };
        let object_list_4 = ObjectListBuilder::default()
            .pair_1(Box::new(pair_1))
            .comma_0(comma_0)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        object_list_2.push(object_list_4);
        self.push(ASTType::ObjectList(object_list_2), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// ObjectList: ; // Vec<T>::New
    ///
    fn object_list_5(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        let context = "object_list_5";
        trace!("{}", self.trace_item_stack(context));
        let object_list_5 = Vec::new();
        self.push(ASTType::ObjectList(object_list_5), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// Pair: String ":" Value;
    ///
    fn pair_6(
        &mut self,
        _string_0: &ParseTreeStackEntry,
        colon_1: &ParseTreeStackEntry,
        _value_2: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "pair_6";
        trace!("{}", self.trace_item_stack(context));
        let colon_1 = colon_1.token(parse_tree)?.to_owned();
        let value_2 = if let Some(ASTType::Value(value_2)) = self.pop(context) {
            value_2
        } else {
            Err(miette!("{}: Expecting ASTType::Value", context))?
        };
        let string_0 = if let Some(ASTType::String(string_0)) = self.pop(context) {
            string_0
        } else {
            Err(miette!("{}: Expecting ASTType::String", context))?
        };
        let pair_6 = PairBuilder::default()
            .string_0(Box::new(string_0))
            .colon_1(colon_1)
            .value_2(Box::new(value_2))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.pair(pair_6.clone())?;
        self.push(ASTType::Pair(pair_6), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// Array: "\[" ArraySuffix;
    ///
    fn array_7(
        &mut self,
        l_bracket_0: &ParseTreeStackEntry,
        _array_suffix_1: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "array_7";
        trace!("{}", self.trace_item_stack(context));
        let l_bracket_0 = l_bracket_0.token(parse_tree)?.to_owned();
        let array_suffix_1 = if let Some(ASTType::ArraySuffix(array_suffix_1)) = self.pop(context) {
            array_suffix_1
        } else {
            Err(miette!("{}: Expecting ASTType::ArraySuffix", context))?
        };
        let array_7 = ArrayBuilder::default()
            .l_bracket_0(l_bracket_0)
            .array_suffix_1(Box::new(array_suffix_1))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.array(array_7.clone())?;
        self.push(ASTType::Array(array_7), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// ArraySuffix: Value ArrayList /* Vec */ "\]";
    ///
    fn array_suffix_8(
        &mut self,
        _value_0: &ParseTreeStackEntry,
        _array_list_1: &ParseTreeStackEntry,
        r_bracket_2: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "array_suffix_8";
        trace!("{}", self.trace_item_stack(context));
        let r_bracket_2 = r_bracket_2.token(parse_tree)?.to_owned();
        let array_list_1 = if let Some(ASTType::ArrayList(mut array_list_1)) = self.pop(context) {
            array_list_1.reverse();
            array_list_1
        } else {
            Err(miette!("{}: Expecting ASTType::ArrayList", context))?
        };
        let value_0 = if let Some(ASTType::Value(value_0)) = self.pop(context) {
            value_0
        } else {
            Err(miette!("{}: Expecting ASTType::Value", context))?
        };
        let array_suffix_8 = ArraySuffix8Builder::default()
            .value_0(Box::new(value_0))
            .array_list_1(array_list_1)
            .r_bracket_2(r_bracket_2)
            .build()
            .into_diagnostic()?;
        let array_suffix_8 = ArraySuffix::ArraySuffix8(array_suffix_8);
        self.push(ASTType::ArraySuffix(array_suffix_8), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// ArraySuffix: "\]";
    ///
    fn array_suffix_9(
        &mut self,
        r_bracket_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "array_suffix_9";
        trace!("{}", self.trace_item_stack(context));
        let r_bracket_0 = r_bracket_0.token(parse_tree)?.to_owned();
        let array_suffix_9 = ArraySuffix9Builder::default()
            .r_bracket_0(r_bracket_0)
            .build()
            .into_diagnostic()?;
        let array_suffix_9 = ArraySuffix::ArraySuffix9(array_suffix_9);
        self.push(ASTType::ArraySuffix(array_suffix_9), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// ArrayList: "," Value ArrayList; // Vec<T>::Push
    ///
    fn array_list_10(
        &mut self,
        comma_0: &ParseTreeStackEntry,
        _value_1: &ParseTreeStackEntry,
        _array_list_2: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "array_list_10";
        trace!("{}", self.trace_item_stack(context));
        let comma_0 = comma_0.token(parse_tree)?.to_owned();
        let mut array_list_2 = if let Some(ASTType::ArrayList(array_list_2)) = self.pop(context) {
            array_list_2
        } else {
            Err(miette!("{}: Expecting ASTType::ArrayList", context))?
        };
        let value_1 = if let Some(ASTType::Value(value_1)) = self.pop(context) {
            value_1
        } else {
            Err(miette!("{}: Expecting ASTType::Value", context))?
        };
        let array_list_10 = ArrayListBuilder::default()
            .value_1(Box::new(value_1))
            .comma_0(comma_0)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        array_list_2.push(array_list_10);
        self.push(ASTType::ArrayList(array_list_2), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// ArrayList: ; // Vec<T>::New
    ///
    fn array_list_11(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        let context = "array_list_11";
        trace!("{}", self.trace_item_stack(context));
        let array_list_11 = Vec::new();
        self.push(ASTType::ArrayList(array_list_11), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// Value: String;
    ///
    fn value_12(
        &mut self,
        _string_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "value_12";
        trace!("{}", self.trace_item_stack(context));
        let string_0 = if let Some(ASTType::String(string_0)) = self.pop(context) {
            string_0
        } else {
            Err(miette!("{}: Expecting ASTType::String", context))?
        };
        let value_12 = Value12Builder::default()
            .string_0(Box::new(string_0))
            .build()
            .into_diagnostic()?;
        let value_12 = Value::Value12(value_12);
        // Calling user action here
        self.user_grammar.value(value_12.clone())?;
        self.push(ASTType::Value(value_12), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// Value: Number;
    ///
    fn value_13(
        &mut self,
        _number_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "value_13";
        trace!("{}", self.trace_item_stack(context));
        let number_0 = if let Some(ASTType::Number(number_0)) = self.pop(context) {
            number_0
        } else {
            Err(miette!("{}: Expecting ASTType::Number", context))?
        };
        let value_13 = Value13Builder::default()
            .number_0(Box::new(number_0))
            .build()
            .into_diagnostic()?;
        let value_13 = Value::Value13(value_13);
        // Calling user action here
        self.user_grammar.value(value_13.clone())?;
        self.push(ASTType::Value(value_13), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// Value: Object;
    ///
    fn value_14(
        &mut self,
        _object_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "value_14";
        trace!("{}", self.trace_item_stack(context));
        let object_0 = if let Some(ASTType::Object(object_0)) = self.pop(context) {
            object_0
        } else {
            Err(miette!("{}: Expecting ASTType::Object", context))?
        };
        let value_14 = Value14Builder::default()
            .object_0(Box::new(object_0))
            .build()
            .into_diagnostic()?;
        let value_14 = Value::Value14(value_14);
        // Calling user action here
        self.user_grammar.value(value_14.clone())?;
        self.push(ASTType::Value(value_14), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// Value: Array;
    ///
    fn value_15(
        &mut self,
        _array_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "value_15";
        trace!("{}", self.trace_item_stack(context));
        let array_0 = if let Some(ASTType::Array(array_0)) = self.pop(context) {
            array_0
        } else {
            Err(miette!("{}: Expecting ASTType::Array", context))?
        };
        let value_15 = Value15Builder::default()
            .array_0(Box::new(array_0))
            .build()
            .into_diagnostic()?;
        let value_15 = Value::Value15(value_15);
        // Calling user action here
        self.user_grammar.value(value_15.clone())?;
        self.push(ASTType::Value(value_15), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// Value: "true";
    ///
    fn value_16(
        &mut self,
        r#true_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "value_16";
        trace!("{}", self.trace_item_stack(context));
        let r#true_0 = r#true_0.token(parse_tree)?.to_owned();
        let value_16 = Value16Builder::default()
            .r#true_0(r#true_0)
            .build()
            .into_diagnostic()?;
        let value_16 = Value::Value16(value_16);
        // Calling user action here
        self.user_grammar.value(value_16.clone())?;
        self.push(ASTType::Value(value_16), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// Value: "false";
    ///
    fn value_17(
        &mut self,
        r#false_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "value_17";
        trace!("{}", self.trace_item_stack(context));
        let r#false_0 = r#false_0.token(parse_tree)?.to_owned();
        let value_17 = Value17Builder::default()
            .r#false_0(r#false_0)
            .build()
            .into_diagnostic()?;
        let value_17 = Value::Value17(value_17);
        // Calling user action here
        self.user_grammar.value(value_17.clone())?;
        self.push(ASTType::Value(value_17), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// Value: "null";
    ///
    fn value_18(
        &mut self,
        null_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "value_18";
        trace!("{}", self.trace_item_stack(context));
        let null_0 = null_0.token(parse_tree)?.to_owned();
        let value_18 = Value18Builder::default()
            .null_0(null_0)
            .build()
            .into_diagnostic()?;
        let value_18 = Value::Value18(value_18);
        // Calling user action here
        self.user_grammar.value(value_18.clone())?;
        self.push(ASTType::Value(value_18), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// String: "\u{0022}(?:\\[\u{0022}\\/bfnrt]|u[0-9a-fA-F]{4}|[^\u{0022}\\\u0000-\u001F])*\u{0022}";
    ///
    fn string_19(
        &mut self,
        string_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "string_19";
        trace!("{}", self.trace_item_stack(context));
        let string_0 = string_0.token(parse_tree)?.to_owned();
        let string_19 = StringBuilder::default()
            .string_0(string_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.string(string_19.clone())?;
        self.push(ASTType::String(string_19), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// Number: "-?(?:0|[1-9][0-9]*)(?:\.[0-9]+)?(?:[eE][-+]?(?:0|[1-9][0-9]*)?)?";
    ///
    fn number_20(
        &mut self,
        number_0: &ParseTreeStackEntry,
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        let context = "number_20";
        trace!("{}", self.trace_item_stack(context));
        let number_0 = number_0.token(parse_tree)?.to_owned();
        let number_20 = NumberBuilder::default()
            .number_0(number_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.number(number_20.clone())?;
        self.push(ASTType::Number(number_20), context);
        Ok(())
    }
}

impl UserActionsTrait for JsonGrammarAuto<'_> {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// Is is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, file_name: &Path) {
        self.file_name = file_name.to_owned();
        self.user_grammar.init(file_name);
    }

    ///
    /// This function is implemented automatically for the user's item JsonGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry],
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        match prod_num {
            0 => self.json_0(&children[0], parse_tree),
            1 => self.object_1(&children[0], &children[1], parse_tree),
            2 => self.object_suffix_2(&children[0], &children[1], &children[2], parse_tree),
            3 => self.object_suffix_3(&children[0], parse_tree),
            4 => self.object_list_4(&children[0], &children[1], &children[2], parse_tree),
            5 => self.object_list_5(parse_tree),
            6 => self.pair_6(&children[0], &children[1], &children[2], parse_tree),
            7 => self.array_7(&children[0], &children[1], parse_tree),
            8 => self.array_suffix_8(&children[0], &children[1], &children[2], parse_tree),
            9 => self.array_suffix_9(&children[0], parse_tree),
            10 => self.array_list_10(&children[0], &children[1], &children[2], parse_tree),
            11 => self.array_list_11(parse_tree),
            12 => self.value_12(&children[0], parse_tree),
            13 => self.value_13(&children[0], parse_tree),
            14 => self.value_14(&children[0], parse_tree),
            15 => self.value_15(&children[0], parse_tree),
            16 => self.value_16(&children[0], parse_tree),
            17 => self.value_17(&children[0], parse_tree),
            18 => self.value_18(&children[0], parse_tree),
            19 => self.string_19(&children[0], parse_tree),
            20 => self.number_20(&children[0], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
