// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

#[allow(unused_imports)]
use crate::json_grammar::JsonGrammar;
use id_tree::Tree;
use log::trace;
use miette::{miette, IntoDiagnostic, Result};
use parol_runtime::lexer::Token;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};
use std::path::{Path, PathBuf};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait JsonGrammarTrait<'t> {
    fn init(&mut self, _file_name: &Path) {}

    /// Semantic action for user production 0:
    ///
    /// Json: Value;
    ///
    fn json(&mut self, _arg: &Json<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 1:
    ///
    /// Object: <0>"\{" Pair {<0>"," Pair} <0>"\}" | <0>"\{" <0>"\}";
    ///
    fn object(&mut self, _arg: &Object<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 2:
    ///
    /// Pair: String <0>":" Value;
    ///
    fn pair(&mut self, _arg: &Pair<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 3:
    ///
    /// Array: <0>"\[" Value {<0>"," Value} <0>"\]" | <0>"\[" <0>"\]";
    ///
    fn array(&mut self, _arg: &Array<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 4:
    ///
    /// Value: String | Number | Object | Array | <0>"true" | <0>"false" | <0>"null";
    ///
    fn value(&mut self, _arg: &Value<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 5:
    ///
    /// String: <0>"\u{0022}(?:\\[\u{0022}\\/bfnrt]|u[0-9a-fA-F]{4}|[^\u{0022}\\\u0000-\u001F])*\u{0022}";
    ///
    fn string(&mut self, _arg: &String<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 6:
    ///
    /// Number: <0>"-?(?:0|[1-9][0-9]*)(?:\.[0-9]+)?(?:[eE][-+]?(?:0|[1-9][0-9]*)?)?";
    ///
    fn number(&mut self, _arg: &Number<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 2
///
/// ObjectSuffix: Pair ObjectList /* Vec */ "\}";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ObjectSuffix2<'t> {
    pub pair_0: Box<Pair<'t>>,
    pub object_list_1: Vec<ObjectList<'t>>,
    pub r_brace_2: Token<'t>, /* \} */
}

///
/// Type derived for production 3
///
/// ObjectSuffix: "\}";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ObjectSuffix3<'t> {
    pub r_brace_0: Token<'t>, /* \} */
}

///
/// Type derived for production 8
///
/// ArraySuffix: Value ArrayList /* Vec */ "\]";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ArraySuffix8<'t> {
    pub value_0: Box<Value<'t>>,
    pub array_list_1: Vec<ArrayList<'t>>,
    pub r_bracket_2: Token<'t>, /* \] */
}

///
/// Type derived for production 9
///
/// ArraySuffix: "\]";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ArraySuffix9<'t> {
    pub r_bracket_0: Token<'t>, /* \] */
}

///
/// Type derived for production 12
///
/// Value: String;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Value12<'t> {
    pub string_0: Box<String<'t>>,
}

///
/// Type derived for production 13
///
/// Value: Number;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Value13<'t> {
    pub number_0: Box<Number<'t>>,
}

///
/// Type derived for production 14
///
/// Value: Object;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Value14<'t> {
    pub object_0: Box<Object<'t>>,
}

///
/// Type derived for production 15
///
/// Value: Array;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Value15<'t> {
    pub array_0: Box<Array<'t>>,
}

///
/// Type derived for production 16
///
/// Value: "true";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Value16<'t> {
    pub r#true_0: Token<'t>, /* true */
}

///
/// Type derived for production 17
///
/// Value: "false";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Value17<'t> {
    pub r#false_0: Token<'t>, /* false */
}

///
/// Type derived for production 18
///
/// Value: "null";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Value18<'t> {
    pub null_0: Token<'t>, /* null */
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal Array
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Array<'t> {
    pub l_bracket_0: Token<'t>, /* \[ */
    pub array_suffix_1: Box<ArraySuffix<'t>>,
}

///
/// Type derived for non-terminal ArrayList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ArrayList<'t> {
    pub comma_0: Token<'t>, /* , */
    pub value_1: Box<Value<'t>>,
}

///
/// Type derived for non-terminal ArraySuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ArraySuffix<'t> {
    ArraySuffix8(ArraySuffix8<'t>),
    ArraySuffix9(ArraySuffix9<'t>),
}

///
/// Type derived for non-terminal Json
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Json<'t> {
    pub value_0: Box<Value<'t>>,
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number<'t> {
    pub number_0: Token<'t>, /* -?(?:0|[1-9][0-9]*)(?:\.[0-9]+)?(?:[eE][-+]?(?:0|[1-9][0-9]*)?)? */
}

///
/// Type derived for non-terminal Object
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Object<'t> {
    pub l_brace_0: Token<'t>, /* \{ */
    pub object_suffix_1: Box<ObjectSuffix<'t>>,
}

///
/// Type derived for non-terminal ObjectList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ObjectList<'t> {
    pub comma_0: Token<'t>, /* , */
    pub pair_1: Box<Pair<'t>>,
}

///
/// Type derived for non-terminal ObjectSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ObjectSuffix<'t> {
    ObjectSuffix2(ObjectSuffix2<'t>),
    ObjectSuffix3(ObjectSuffix3<'t>),
}

///
/// Type derived for non-terminal Pair
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Pair<'t> {
    pub string_0: Box<String<'t>>,
    pub colon_1: Token<'t>, /* : */
    pub value_2: Box<Value<'t>>,
}

///
/// Type derived for non-terminal String
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct String<'t> {
    pub string_0: Token<'t>, /* \u{0022}(?:\\[\u{0022}\\/bfnrt]|u[0-9a-fA-F]{4}|[^\u{0022}\\\u0000-\u001F])*\u{0022} */
}

///
/// Type derived for non-terminal Value
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Value<'t> {
    Value12(Value12<'t>),
    Value13(Value13<'t>),
    Value14(Value14<'t>),
    Value15(Value15<'t>),
    Value16(Value16<'t>),
    Value17(Value17<'t>),
    Value18(Value18<'t>),
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    Array(Array<'t>),
    ArrayList(Vec<ArrayList<'t>>),
    ArraySuffix(ArraySuffix<'t>),
    Json(Json<'t>),
    Number(Number<'t>),
    Object(Object<'t>),
    ObjectList(Vec<ObjectList<'t>>),
    ObjectSuffix(ObjectSuffix<'t>),
    Pair(Pair<'t>),
    String(String<'t>),
    Value(Value<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct JsonGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn JsonGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
    // Path of the input file. Used for diagnostics.
    file_name: PathBuf,
}

///
/// The `JsonGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> JsonGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn JsonGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            file_name: PathBuf::default(),
        }
    }

    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// Json: Value;
    ///
    fn json_0(
        &mut self,
        _value_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "json_0";
        trace!("{}", self.trace_item_stack(context));
        let value_0 = if let Some(ASTType::Value(value_0)) = self.pop(context) {
            value_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Value", context));
        };
        let json_0_built = JsonBuilder::default()
            .value_0(Box::new(value_0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.json(&json_0_built)?;
        self.push(ASTType::Json(json_0_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Object: "\{" ObjectSuffix;
    ///
    fn object_1(
        &mut self,
        l_brace_0: &ParseTreeStackEntry<'t>,
        _object_suffix_1: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "object_1";
        trace!("{}", self.trace_item_stack(context));
        let l_brace_0 = *l_brace_0.token(parse_tree)?;
        let object_suffix_1 =
            if let Some(ASTType::ObjectSuffix(object_suffix_1)) = self.pop(context) {
                object_suffix_1
            } else {
                return Err(miette!("{}: Expecting ASTType::ObjectSuffix", context));
            };
        let object_1_built = ObjectBuilder::default()
            .l_brace_0(l_brace_0)
            .object_suffix_1(Box::new(object_suffix_1))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.object(&object_1_built)?;
        self.push(ASTType::Object(object_1_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// ObjectSuffix: Pair ObjectList /* Vec */ "\}";
    ///
    fn object_suffix_2(
        &mut self,
        _pair_0: &ParseTreeStackEntry<'t>,
        _object_list_1: &ParseTreeStackEntry<'t>,
        r_brace_2: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "object_suffix_2";
        trace!("{}", self.trace_item_stack(context));
        let r_brace_2 = *r_brace_2.token(parse_tree)?;
        let object_list_1 = if let Some(ASTType::ObjectList(mut object_list_1)) = self.pop(context)
        {
            object_list_1.reverse();
            object_list_1
        } else {
            return Err(miette!("{}: Expecting ASTType::ObjectList", context));
        };
        let pair_0 = if let Some(ASTType::Pair(pair_0)) = self.pop(context) {
            pair_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Pair", context));
        };
        let object_suffix_2_built = ObjectSuffix2Builder::default()
            .pair_0(Box::new(pair_0))
            .object_list_1(object_list_1)
            .r_brace_2(r_brace_2)
            .build()
            .into_diagnostic()?;
        let object_suffix_2_built = ObjectSuffix::ObjectSuffix2(object_suffix_2_built);
        self.push(ASTType::ObjectSuffix(object_suffix_2_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// ObjectSuffix: "\}";
    ///
    fn object_suffix_3(
        &mut self,
        r_brace_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "object_suffix_3";
        trace!("{}", self.trace_item_stack(context));
        let r_brace_0 = *r_brace_0.token(parse_tree)?;
        let object_suffix_3_built = ObjectSuffix3Builder::default()
            .r_brace_0(r_brace_0)
            .build()
            .into_diagnostic()?;
        let object_suffix_3_built = ObjectSuffix::ObjectSuffix3(object_suffix_3_built);
        self.push(ASTType::ObjectSuffix(object_suffix_3_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// ObjectList: "," Pair ObjectList; // Vec<T>::Push
    ///
    fn object_list_4(
        &mut self,
        comma_0: &ParseTreeStackEntry<'t>,
        _pair_1: &ParseTreeStackEntry<'t>,
        _object_list_2: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "object_list_4";
        trace!("{}", self.trace_item_stack(context));
        let comma_0 = *comma_0.token(parse_tree)?;
        let mut object_list_2 = if let Some(ASTType::ObjectList(object_list_2)) = self.pop(context)
        {
            object_list_2
        } else {
            return Err(miette!("{}: Expecting ASTType::ObjectList", context));
        };
        let pair_1 = if let Some(ASTType::Pair(pair_1)) = self.pop(context) {
            pair_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Pair", context));
        };
        let object_list_4_built = ObjectListBuilder::default()
            .pair_1(Box::new(pair_1))
            .comma_0(comma_0)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        object_list_2.push(object_list_4_built);
        self.push(ASTType::ObjectList(object_list_2), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// ObjectList: ; // Vec<T>::New
    ///
    fn object_list_5(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "object_list_5";
        trace!("{}", self.trace_item_stack(context));
        let object_list_5_built = Vec::new();
        self.push(ASTType::ObjectList(object_list_5_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// Pair: String ":" Value;
    ///
    fn pair_6(
        &mut self,
        _string_0: &ParseTreeStackEntry<'t>,
        colon_1: &ParseTreeStackEntry<'t>,
        _value_2: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "pair_6";
        trace!("{}", self.trace_item_stack(context));
        let colon_1 = *colon_1.token(parse_tree)?;
        let value_2 = if let Some(ASTType::Value(value_2)) = self.pop(context) {
            value_2
        } else {
            return Err(miette!("{}: Expecting ASTType::Value", context));
        };
        let string_0 = if let Some(ASTType::String(string_0)) = self.pop(context) {
            string_0
        } else {
            return Err(miette!("{}: Expecting ASTType::String", context));
        };
        let pair_6_built = PairBuilder::default()
            .string_0(Box::new(string_0))
            .colon_1(colon_1)
            .value_2(Box::new(value_2))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.pair(&pair_6_built)?;
        self.push(ASTType::Pair(pair_6_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// Array: "\[" ArraySuffix;
    ///
    fn array_7(
        &mut self,
        l_bracket_0: &ParseTreeStackEntry<'t>,
        _array_suffix_1: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "array_7";
        trace!("{}", self.trace_item_stack(context));
        let l_bracket_0 = *l_bracket_0.token(parse_tree)?;
        let array_suffix_1 = if let Some(ASTType::ArraySuffix(array_suffix_1)) = self.pop(context) {
            array_suffix_1
        } else {
            return Err(miette!("{}: Expecting ASTType::ArraySuffix", context));
        };
        let array_7_built = ArrayBuilder::default()
            .l_bracket_0(l_bracket_0)
            .array_suffix_1(Box::new(array_suffix_1))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.array(&array_7_built)?;
        self.push(ASTType::Array(array_7_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// ArraySuffix: Value ArrayList /* Vec */ "\]";
    ///
    fn array_suffix_8(
        &mut self,
        _value_0: &ParseTreeStackEntry<'t>,
        _array_list_1: &ParseTreeStackEntry<'t>,
        r_bracket_2: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "array_suffix_8";
        trace!("{}", self.trace_item_stack(context));
        let r_bracket_2 = *r_bracket_2.token(parse_tree)?;
        let array_list_1 = if let Some(ASTType::ArrayList(mut array_list_1)) = self.pop(context) {
            array_list_1.reverse();
            array_list_1
        } else {
            return Err(miette!("{}: Expecting ASTType::ArrayList", context));
        };
        let value_0 = if let Some(ASTType::Value(value_0)) = self.pop(context) {
            value_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Value", context));
        };
        let array_suffix_8_built = ArraySuffix8Builder::default()
            .value_0(Box::new(value_0))
            .array_list_1(array_list_1)
            .r_bracket_2(r_bracket_2)
            .build()
            .into_diagnostic()?;
        let array_suffix_8_built = ArraySuffix::ArraySuffix8(array_suffix_8_built);
        self.push(ASTType::ArraySuffix(array_suffix_8_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// ArraySuffix: "\]";
    ///
    fn array_suffix_9(
        &mut self,
        r_bracket_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "array_suffix_9";
        trace!("{}", self.trace_item_stack(context));
        let r_bracket_0 = *r_bracket_0.token(parse_tree)?;
        let array_suffix_9_built = ArraySuffix9Builder::default()
            .r_bracket_0(r_bracket_0)
            .build()
            .into_diagnostic()?;
        let array_suffix_9_built = ArraySuffix::ArraySuffix9(array_suffix_9_built);
        self.push(ASTType::ArraySuffix(array_suffix_9_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// ArrayList: "," Value ArrayList; // Vec<T>::Push
    ///
    fn array_list_10(
        &mut self,
        comma_0: &ParseTreeStackEntry<'t>,
        _value_1: &ParseTreeStackEntry<'t>,
        _array_list_2: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "array_list_10";
        trace!("{}", self.trace_item_stack(context));
        let comma_0 = *comma_0.token(parse_tree)?;
        let mut array_list_2 = if let Some(ASTType::ArrayList(array_list_2)) = self.pop(context) {
            array_list_2
        } else {
            return Err(miette!("{}: Expecting ASTType::ArrayList", context));
        };
        let value_1 = if let Some(ASTType::Value(value_1)) = self.pop(context) {
            value_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Value", context));
        };
        let array_list_10_built = ArrayListBuilder::default()
            .value_1(Box::new(value_1))
            .comma_0(comma_0)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        array_list_2.push(array_list_10_built);
        self.push(ASTType::ArrayList(array_list_2), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// ArrayList: ; // Vec<T>::New
    ///
    fn array_list_11(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "array_list_11";
        trace!("{}", self.trace_item_stack(context));
        let array_list_11_built = Vec::new();
        self.push(ASTType::ArrayList(array_list_11_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// Value: String;
    ///
    fn value_12(
        &mut self,
        _string_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "value_12";
        trace!("{}", self.trace_item_stack(context));
        let string_0 = if let Some(ASTType::String(string_0)) = self.pop(context) {
            string_0
        } else {
            return Err(miette!("{}: Expecting ASTType::String", context));
        };
        let value_12_built = Value12Builder::default()
            .string_0(Box::new(string_0))
            .build()
            .into_diagnostic()?;
        let value_12_built = Value::Value12(value_12_built);
        // Calling user action here
        self.user_grammar.value(&value_12_built)?;
        self.push(ASTType::Value(value_12_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// Value: Number;
    ///
    fn value_13(
        &mut self,
        _number_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "value_13";
        trace!("{}", self.trace_item_stack(context));
        let number_0 = if let Some(ASTType::Number(number_0)) = self.pop(context) {
            number_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Number", context));
        };
        let value_13_built = Value13Builder::default()
            .number_0(Box::new(number_0))
            .build()
            .into_diagnostic()?;
        let value_13_built = Value::Value13(value_13_built);
        // Calling user action here
        self.user_grammar.value(&value_13_built)?;
        self.push(ASTType::Value(value_13_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// Value: Object;
    ///
    fn value_14(
        &mut self,
        _object_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "value_14";
        trace!("{}", self.trace_item_stack(context));
        let object_0 = if let Some(ASTType::Object(object_0)) = self.pop(context) {
            object_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Object", context));
        };
        let value_14_built = Value14Builder::default()
            .object_0(Box::new(object_0))
            .build()
            .into_diagnostic()?;
        let value_14_built = Value::Value14(value_14_built);
        // Calling user action here
        self.user_grammar.value(&value_14_built)?;
        self.push(ASTType::Value(value_14_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// Value: Array;
    ///
    fn value_15(
        &mut self,
        _array_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "value_15";
        trace!("{}", self.trace_item_stack(context));
        let array_0 = if let Some(ASTType::Array(array_0)) = self.pop(context) {
            array_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Array", context));
        };
        let value_15_built = Value15Builder::default()
            .array_0(Box::new(array_0))
            .build()
            .into_diagnostic()?;
        let value_15_built = Value::Value15(value_15_built);
        // Calling user action here
        self.user_grammar.value(&value_15_built)?;
        self.push(ASTType::Value(value_15_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// Value: "true";
    ///
    fn value_16(
        &mut self,
        r#true_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "value_16";
        trace!("{}", self.trace_item_stack(context));
        let r#true_0 = *r#true_0.token(parse_tree)?;
        let value_16_built = Value16Builder::default()
            .r#true_0(r#true_0)
            .build()
            .into_diagnostic()?;
        let value_16_built = Value::Value16(value_16_built);
        // Calling user action here
        self.user_grammar.value(&value_16_built)?;
        self.push(ASTType::Value(value_16_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// Value: "false";
    ///
    fn value_17(
        &mut self,
        r#false_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "value_17";
        trace!("{}", self.trace_item_stack(context));
        let r#false_0 = *r#false_0.token(parse_tree)?;
        let value_17_built = Value17Builder::default()
            .r#false_0(r#false_0)
            .build()
            .into_diagnostic()?;
        let value_17_built = Value::Value17(value_17_built);
        // Calling user action here
        self.user_grammar.value(&value_17_built)?;
        self.push(ASTType::Value(value_17_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// Value: "null";
    ///
    fn value_18(
        &mut self,
        null_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "value_18";
        trace!("{}", self.trace_item_stack(context));
        let null_0 = *null_0.token(parse_tree)?;
        let value_18_built = Value18Builder::default()
            .null_0(null_0)
            .build()
            .into_diagnostic()?;
        let value_18_built = Value::Value18(value_18_built);
        // Calling user action here
        self.user_grammar.value(&value_18_built)?;
        self.push(ASTType::Value(value_18_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// String: "\u{0022}(?:\\[\u{0022}\\/bfnrt]|u[0-9a-fA-F]{4}|[^\u{0022}\\\u0000-\u001F])*\u{0022}";
    ///
    fn string_19(
        &mut self,
        string_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "string_19";
        trace!("{}", self.trace_item_stack(context));
        let string_0 = *string_0.token(parse_tree)?;
        let string_19_built = StringBuilder::default()
            .string_0(string_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.string(&string_19_built)?;
        self.push(ASTType::String(string_19_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// Number: "-?(?:0|[1-9][0-9]*)(?:\.[0-9]+)?(?:[eE][-+]?(?:0|[1-9][0-9]*)?)?";
    ///
    fn number_20(
        &mut self,
        number_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "number_20";
        trace!("{}", self.trace_item_stack(context));
        let number_0 = *number_0.token(parse_tree)?;
        let number_20_built = NumberBuilder::default()
            .number_0(number_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.number(&number_20_built)?;
        self.push(ASTType::Number(number_20_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for JsonGrammarAuto<'t, '_> {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// Is is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, file_name: &Path) {
        self.file_name = file_name.to_owned();
        self.user_grammar.init(file_name);
    }

    ///
    /// This function is implemented automatically for the user's item JsonGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.json_0(&children[0], parse_tree),
            1 => self.object_1(&children[0], &children[1], parse_tree),
            2 => self.object_suffix_2(&children[0], &children[1], &children[2], parse_tree),
            3 => self.object_suffix_3(&children[0], parse_tree),
            4 => self.object_list_4(&children[0], &children[1], &children[2], parse_tree),
            5 => self.object_list_5(parse_tree),
            6 => self.pair_6(&children[0], &children[1], &children[2], parse_tree),
            7 => self.array_7(&children[0], &children[1], parse_tree),
            8 => self.array_suffix_8(&children[0], &children[1], &children[2], parse_tree),
            9 => self.array_suffix_9(&children[0], parse_tree),
            10 => self.array_list_10(&children[0], &children[1], &children[2], parse_tree),
            11 => self.array_list_11(parse_tree),
            12 => self.value_12(&children[0], parse_tree),
            13 => self.value_13(&children[0], parse_tree),
            14 => self.value_14(&children[0], parse_tree),
            15 => self.value_15(&children[0], parse_tree),
            16 => self.value_16(&children[0], parse_tree),
            17 => self.value_17(&children[0], parse_tree),
            18 => self.value_18(&children[0], parse_tree),
            19 => self.string_19(&children[0], parse_tree),
            20 => self.number_20(&children[0], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
