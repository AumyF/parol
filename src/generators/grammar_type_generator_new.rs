use crate::generators::NamingHelper as NmHlp;
use log::trace;
use miette::{miette, Result};
use std::collections::{BTreeMap, HashSet};
use std::fmt::{Debug, Display, Error, Formatter};

use crate::{grammar::SymbolAttribute, Cfg, GrammarConfig};

use super::symbol_table::{Function, Symbol, SymbolId, SymbolTable, TypeEntrails};

///
/// An argument of a semantic action
///
#[derive(Builder, Clone, Debug, Default)]
pub(crate) struct Argument {
    /// Argument's name
    pub(crate) name: String,
    /// Argument's type
    pub(crate) arg_type: SymbolId,
    /// Argument index or position
    pub(crate) index: Option<usize>,
    /// Indicates if the argument is used
    pub(crate) used: bool,
    /// Semantic information
    pub(crate) sem: SymbolAttribute,
}

///
/// Type information for a given grammar
///
#[derive(Debug, Default)]
pub struct GrammarTypeInfo {
    /// All symbols are managed by the symbol table
    pub(crate) symbol_table: SymbolTable,

    /// Calculated types of non-terminals
    pub(crate) non_terminal_types: BTreeMap<String, SymbolId>,

    pub(crate) user_action_trait_id: Option<SymbolId>,
    pub(crate) adapter_grammar_struct_id: Option<SymbolId>,
    pub(crate) action_caller_trait_id: Option<SymbolId>,

    /// The type completely comprising the whole structural information that could be generated by
    /// the given expanded grammar.
    /// It is a type of enum kind.
    /// We use this as ASTType for the generated source.
    pub(crate) ast_enum_type: SymbolId,

    /// Indicates if the auto generation mode is active
    pub(crate) auto_generate: bool,

    // Contains non-terminals that should be represented as vectors in the AST Enum type
    vector_typed_non_terminals: HashSet<String>,
}

impl GrammarTypeInfo {
    /// Create a new item
    /// Initializes the inner data structures.
    pub fn try_new(grammar_type_name: &str) -> Result<Self> {
        let mut me = Self::default();
        me.symbol_table = SymbolTable::new();

        // Insert the fix UserActionsTrait into the global scope
        me.action_caller_trait_id = Some(
            me.symbol_table
                .insert_global_type("UserActionsTrait", TypeEntrails::Trait)?,
        );

        // Insert the Semantic Actions Trait into the global scope
        me.user_action_trait_id = Some(me.symbol_table.insert_global_type(
            &format!("{}Trait", NmHlp::to_upper_camel_case(grammar_type_name)),
            TypeEntrails::Trait,
        )?);

        // Insert the fix <GrammarName>Auto trait into the global scope
        me.adapter_grammar_struct_id = Some(me.symbol_table.insert_global_type(
            &format!("{}Auto", NmHlp::to_upper_camel_case(grammar_type_name)),
            TypeEntrails::Trait,
        )?);

        for n in ["new", "push", "pop", "trace_item_stack"] {
            me.symbol_table.insert_type(
                me.adapter_grammar_struct_id.unwrap(),
                n,
                TypeEntrails::Function(Function::default()),
            )?;
        }

        // Insert the fix Token type the global scope, simply to avoid name clashes
        me.symbol_table
            .insert_global_type("Token", TypeEntrails::Struct)?;
        Ok(me)
    }

    /// Add non-terminal type
    fn add_non_terminal_type(&mut self, non_terminal: &str, nt_type: SymbolId) -> Result<()> {
        self.non_terminal_types
            .insert(non_terminal.to_owned(), nt_type)
            .map_or_else(
                || {
                    trace!("Setting type for non-terminal {}", non_terminal);
                    Ok(())
                },
                |_| {
                    Err(miette!(
                        "Type for non-terminal {} already specified",
                        non_terminal
                    ))
                },
            )
    }

    ///
    /// Build the type information from the given grammar.
    ///
    pub fn build(&mut self, grammar_config: &GrammarConfig) -> Result<()> {
        self.create_initial_non_terminal_types(&grammar_config.cfg)?;
        self.deduce_actions(grammar_config)?;
        Ok(())
    }

    ///
    /// Returns a vector of action indices matching the given non-terminal n
    ///
    fn matching_productions(&self, cfg: &Cfg, n: &str) -> Vec<usize> {
        cfg.matching_productions(n)
            .into_iter()
            .map(|(i, _)| i)
            .collect()
    }

    fn create_initial_non_terminal_types(&mut self, cfg: &Cfg) -> Result<()> {
        for nt in cfg.get_non_terminal_set() {
            let alternatives = cfg.matching_productions(&nt).len();
            if let Some(nt_type) = self.create_initial_non_terminal_type(&nt, alternatives) {
                self.add_non_terminal_type(&nt, nt_type?)?;
            }
        }
        Ok(())
    }

    fn create_initial_non_terminal_type(
        &mut self,
        non_terminal: &str,
        alternatives: usize,
    ) -> Option<Result<SymbolId>> {
        match alternatives {
            // Productions can be optimized away, when they have duplicates!
            0 => None,
            // Only one production for this non-terminal: we create an empty Struct
            1 => Some(self.symbol_table.insert_type(
                self.adapter_grammar_struct_id.unwrap(),
                non_terminal,
                TypeEntrails::Struct,
            )),
            // Otherwise: we generate an empty Enum
            _ => Some(self.symbol_table.insert_type(
                self.adapter_grammar_struct_id.unwrap(),
                non_terminal,
                TypeEntrails::Enum,
            )),
        }
    }

    fn deduce_actions(&mut self, grammar_config: &GrammarConfig) -> Result<()> {
        let scanner_state_resolver = grammar_config.get_scanner_state_resolver();
        let member_scope = self.adapter_grammar_struct_id.ok_or(miette!(""))?;
        for (i, pr) in grammar_config.cfg.pr.iter().enumerate() {
            let rel_idx = grammar_config
                .cfg
                .get_alternation_index_of_production(i)
                .unwrap();
            //     self.symbol_table.add_symbol(
            //         ActionBuilder::default()
            //             .non_terminal(pr.get_n())
            //             .prod_num(i)
            //             .rel_idx(rel_idx)
            //             .fn_name(NmHlp::to_lower_snake_case(&format!(
            //                 "{}_{}",
            //                 pr.get_n_str(),
            //                 rel_idx
            //             )))
            //             .prod_string(pr.format(&scanner_state_resolver)?)
            //             .args(self.build_argument_list(pr)?)
            //             .out_type(self.deduce_type_of_production(pr, rel_idx)?)
            //             .sem(pr.2.clone())
            //             .alts(
            //                 grammar_config
            //                     .cfg
            //                     .matching_productions(pr.get_n_str())
            //                     .len(),
            //             )
            //             .build()
            //             .into_diagnostic()?,
            //     );
        }
        Ok(())
    }
}

impl Display for GrammarTypeInfo {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::result::Result<(), Error> {
        writeln!(f, "{}", self.symbol_table)?;
        Ok(())
    }
}
