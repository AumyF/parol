// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

#[allow(unused_imports)]
use crate::basic_grammar::BasicGrammar;
use id_tree::Tree;
use log::trace;
use miette::{miette, IntoDiagnostic, Result};
use parol_runtime::lexer::Token;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};
use std::path::{Path, PathBuf};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait BasicGrammarTrait<'t> {
    fn init(&mut self, _file_name: &Path) {}

    /// Semantic action for non-terminal 'Basic'
    fn basic(&mut self, _arg: &Basic<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Line'
    fn line(&mut self, _arg: &Line<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LineNumber'
    fn line_number(&mut self, _arg: &LineNumber<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Statement'
    fn statement(&mut self, _arg: &Statement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Remark'
    fn remark(&mut self, _arg: &Remark<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GotoStatement'
    fn goto_statement(&mut self, _arg: &GotoStatement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfStatement'
    fn if_statement(&mut self, _arg: &IfStatement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Assignment'
    fn assignment(&mut self, _arg: &Assignment<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfBody'
    fn if_body(&mut self, _arg: &IfBody<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PrintStatement'
    fn print_statement(&mut self, _arg: &PrintStatement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EndStatement'
    fn end_statement(&mut self, _arg: &EndStatement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EndOfLine'
    fn end_of_line(&mut self, _arg: &EndOfLine<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Literal'
    fn literal(&mut self, _arg: &Literal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Number'
    fn number(&mut self, _arg: &Number<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Float'
    fn float(&mut self, _arg: &Float<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Float1'
    fn float1(&mut self, _arg: &Float1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Float2'
    fn float2(&mut self, _arg: &Float2<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Integer'
    fn integer(&mut self, _arg: &Integer<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'If'
    fn r#if(&mut self, _arg: &If<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Then'
    fn then(&mut self, _arg: &Then<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Goto'
    fn goto(&mut self, _arg: &Goto<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Let'
    fn r#let(&mut self, _arg: &Let<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Print'
    fn print(&mut self, _arg: &Print<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'End'
    fn end(&mut self, _arg: &End<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignOp'
    fn assign_op(&mut self, _arg: &AssignOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalOrOp'
    fn logical_or_op(&mut self, _arg: &LogicalOrOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalAndOp'
    fn logical_and_op(&mut self, _arg: &LogicalAndOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalNotOp'
    fn logical_not_op(&mut self, _arg: &LogicalNotOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RelationalOp'
    fn relational_op(&mut self, _arg: &RelationalOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Plus'
    fn plus(&mut self, _arg: &Plus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Minus'
    fn minus(&mut self, _arg: &Minus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MulOp'
    fn mul_op(&mut self, _arg: &MulOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParen'
    fn l_paren(&mut self, _arg: &LParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParen'
    fn r_paren(&mut self, _arg: &RParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comment'
    fn comment(&mut self, _arg: &Comment<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Variable'
    fn variable(&mut self, _arg: &Variable<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression'
    fn expression(&mut self, _arg: &Expression<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalOr'
    fn logical_or(&mut self, _arg: &LogicalOr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalAnd'
    fn logical_and(&mut self, _arg: &LogicalAnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalNot'
    fn logical_not(&mut self, _arg: &LogicalNot<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Relational'
    fn relational(&mut self, _arg: &Relational<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Summation'
    fn summation(&mut self, _arg: &Summation<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Multiplication'
    fn multiplication(&mut self, _arg: &Multiplication<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Factor'
    fn factor(&mut self, _arg: &Factor<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 0
///
/// Basic: Line BasicList /* Vec */ BasicSuffix0;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Basic0<'t> {
    pub line: Box<Line<'t>>,
    pub basic_list: Vec<BasicList<'t>>,
    pub basic_suffix0: Box<BasicSuffix0<'t>>,
}

///
/// Type derived for production 1
///
/// Basic: EndOfLine Line BasicList /* Vec */ BasicSuffix;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Basic1<'t> {
    pub end_of_line: Box<EndOfLine<'t>>,
    pub line: Box<Line<'t>>,
    pub basic_list: Vec<BasicList<'t>>,
    pub basic_suffix: Box<BasicSuffix<'t>>,
}

///
/// Type derived for production 2
///
/// BasicSuffix0: EndOfLine;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix1<'t> {
    pub end_of_line: Box<EndOfLine<'t>>,
}

///
/// Type derived for production 3
///
/// BasicSuffix0: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix2 {}

///
/// Type derived for production 4
///
/// BasicSuffix: EndOfLine;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix3<'t> {
    pub end_of_line: Box<EndOfLine<'t>>,
}

///
/// Type derived for production 5
///
/// BasicSuffix: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix4 {}

///
/// Type derived for production 12
///
/// Statement: Remark;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement0<'t> {
    pub remark: Box<Remark<'t>>,
}

///
/// Type derived for production 13
///
/// Statement: GotoStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement1<'t> {
    pub goto_statement: Box<GotoStatement<'t>>,
}

///
/// Type derived for production 14
///
/// Statement: IfStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement2<'t> {
    pub if_statement: Box<IfStatement<'t>>,
}

///
/// Type derived for production 15
///
/// Statement: Assignment;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement3<'t> {
    pub assignment: Box<Assignment<'t>>,
}

///
/// Type derived for production 16
///
/// Statement: PrintStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement4<'t> {
    pub print_statement: Box<PrintStatement<'t>>,
}

///
/// Type derived for production 17
///
/// Statement: EndStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement5<'t> {
    pub end_statement: Box<EndStatement<'t>>,
}

///
/// Type derived for production 19
///
/// RemarkSuffix: Comment %pop();
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RemarkSuffix0<'t> {
    pub comment: Box<Comment<'t>>,
}

///
/// Type derived for production 20
///
/// RemarkSuffix: %pop();
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RemarkSuffix1 {}

///
/// Type derived for production 23
///
/// Assignment: Let Variable AssignOp %push(Expr) Expression %pop();
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Assignment0<'t> {
    pub r#let: Box<Let<'t>>,
    pub variable: Box<Variable<'t>>,
    pub assign_op: Box<AssignOp<'t>>,
    pub expression: Box<Expression<'t>>,
}

///
/// Type derived for production 24
///
/// Assignment: Variable AssignOp %push(Expr) Expression %pop();
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Assignment1<'t> {
    pub variable: Box<Variable<'t>>,
    pub assign_op: Box<AssignOp<'t>>,
    pub expression: Box<Expression<'t>>,
}

///
/// Type derived for production 25
///
/// IfBody: Then Statement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfBody0<'t> {
    pub then: Box<Then<'t>>,
    pub statement: Box<Statement<'t>>,
}

///
/// Type derived for production 26
///
/// IfBody: Goto LineNumber;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfBody1<'t> {
    pub goto: Box<Goto<'t>>,
    pub line_number: Box<LineNumber<'t>>,
}

///
/// Type derived for production 33
///
/// Number: Float;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number0<'t> {
    pub float: Box<Float<'t>>,
}

///
/// Type derived for production 34
///
/// Number: Integer;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number1<'t> {
    pub integer: Box<Integer<'t>>,
}

///
/// Type derived for production 35
///
/// Float: Float1;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Float0<'t> {
    pub float1: Box<Float1<'t>>,
}

///
/// Type derived for production 36
///
/// Float: Float2;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Float3<'t> {
    pub float2: Box<Float2<'t>>,
}

///
/// Type derived for production 65
///
/// LogicalNot: LogicalNotOp Relational;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalNot0<'t> {
    pub logical_not_op: Box<LogicalNotOp<'t>>,
    pub relational: Box<Relational<'t>>,
}

///
/// Type derived for production 66
///
/// LogicalNot: Relational;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalNot1<'t> {
    pub relational: Box<Relational<'t>>,
}

///
/// Type derived for production 72
///
/// SummationListGroup: Plus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SummationListGroup0<'t> {
    pub plus: Box<Plus<'t>>,
}

///
/// Type derived for production 73
///
/// SummationListGroup: Minus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SummationListGroup1<'t> {
    pub minus: Box<Minus<'t>>,
}

///
/// Type derived for production 78
///
/// Factor: Literal;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor0<'t> {
    pub literal: Box<Literal<'t>>,
}

///
/// Type derived for production 79
///
/// Factor: Variable;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor1<'t> {
    pub variable: Box<Variable<'t>>,
}

///
/// Type derived for production 80
///
/// Factor: Minus Factor;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor2<'t> {
    pub minus: Box<Minus<'t>>,
    pub factor: Box<Factor<'t>>,
}

///
/// Type derived for production 81
///
/// Factor: LParen Expression RParen;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor3<'t> {
    pub l_paren: Box<LParen<'t>>,
    pub expression: Box<Expression<'t>>,
    pub r_paren: Box<RParen<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal AssignOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AssignOp<'t> {
    pub assign_op: Token<'t>, /* = */
}

///
/// Type derived for non-terminal Assignment
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Assignment<'t> {
    Assignment0(Assignment0<'t>),
    Assignment1(Assignment1<'t>),
}

///
/// Type derived for non-terminal Basic
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Basic<'t> {
    Basic0(Basic0<'t>),
    Basic1(Basic1<'t>),
}

///
/// Type derived for non-terminal BasicList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicList<'t> {
    pub end_of_line: Box<EndOfLine<'t>>,
    pub line: Box<Line<'t>>,
}

///
/// Type derived for non-terminal BasicSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BasicSuffix<'t> {
    BasicSuffix0(BasicSuffix3<'t>),
    BasicSuffix1(BasicSuffix4),
}

///
/// Type derived for non-terminal BasicSuffix0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BasicSuffix0<'t> {
    BasicSuffix00(BasicSuffix1<'t>),
    BasicSuffix01(BasicSuffix2),
}

///
/// Type derived for non-terminal Comment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Comment<'t> {
    pub comment: Token<'t>, /* [^\r\n]+ */
}

///
/// Type derived for non-terminal End
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct End<'t> {
    pub end: Token<'t>, /* END */
}

///
/// Type derived for non-terminal EndOfLine
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct EndOfLine<'t> {
    pub end_of_line: Token<'t>, /* (?:\r?\n|\r)+ */
}

///
/// Type derived for non-terminal EndStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct EndStatement<'t> {
    pub end: Box<End<'t>>,
}

///
/// Type derived for non-terminal Expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression<'t> {
    pub logical_or: Box<LogicalOr<'t>>,
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor<'t> {
    Factor0(Factor0<'t>),
    Factor1(Factor1<'t>),
    Factor2(Factor2<'t>),
    Factor3(Factor3<'t>),
}

///
/// Type derived for non-terminal Float
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Float<'t> {
    Float0(Float0<'t>),
    Float1(Float3<'t>),
}

///
/// Type derived for non-terminal Float1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Float1<'t> {
    pub float1: Token<'t>, /* (?:(?:[0-9] *)+)?\. *(?:(?:[0-9] *)+)? *(?:E *[-+]? *(?:[0-9] *)+)? */
}

///
/// Type derived for non-terminal Float2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Float2<'t> {
    pub float2: Token<'t>, /* (?:[0-9] *)+E *[-+]? *(?:[0-9] *)+ */
}

///
/// Type derived for non-terminal Goto
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Goto<'t> {
    pub goto: Token<'t>, /* GOTO */
}

///
/// Type derived for non-terminal GotoStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct GotoStatement<'t> {
    pub goto: Box<Goto<'t>>,
    pub line_number: Box<LineNumber<'t>>,
}

///
/// Type derived for non-terminal If
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct If<'t> {
    pub r#if: Token<'t>, /* IF */
}

///
/// Type derived for non-terminal IfBody
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IfBody<'t> {
    IfBody0(IfBody0<'t>),
    IfBody1(IfBody1<'t>),
}

///
/// Type derived for non-terminal IfStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfStatement<'t> {
    pub r#if: Box<If<'t>>,
    pub expression: Box<Expression<'t>>,
    pub if_body: Box<IfBody<'t>>,
}

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Integer<'t> {
    pub integer: Token<'t>, /* (?:[0-9] *)+ */
}

///
/// Type derived for non-terminal LParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LParen<'t> {
    pub l_paren: Token<'t>, /* \( */
}

///
/// Type derived for non-terminal Let
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Let<'t> {
    pub r#let: Token<'t>, /* LET */
}

///
/// Type derived for non-terminal Line
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Line<'t> {
    pub line_number: Box<LineNumber<'t>>,
    pub statement: Box<Statement<'t>>,
    pub line_list: Vec<LineList<'t>>,
}

///
/// Type derived for non-terminal LineList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LineList<'t> {
    pub colon: Token<'t>, /* : */
    pub statement: Box<Statement<'t>>,
}

///
/// Type derived for non-terminal LineNumber
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LineNumber<'t> {
    pub line_number: Token<'t>, /* [0 ]*[1-9] *(?:[0-9] *){1,4}|[0 ]+ */
}

///
/// Type derived for non-terminal Literal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Literal<'t> {
    pub number: Box<Number<'t>>,
}

///
/// Type derived for non-terminal LogicalAnd
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalAnd<'t> {
    pub logical_not: Box<LogicalNot<'t>>,
    pub logical_and_list: Vec<LogicalAndList<'t>>,
}

///
/// Type derived for non-terminal LogicalAndList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalAndList<'t> {
    pub logical_and_op: Box<LogicalAndOp<'t>>,
    pub logical_not: Box<LogicalNot<'t>>,
}

///
/// Type derived for non-terminal LogicalAndOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalAndOp<'t> {
    pub logical_and_op: Token<'t>, /* AND */
}

///
/// Type derived for non-terminal LogicalNot
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum LogicalNot<'t> {
    LogicalNot0(LogicalNot0<'t>),
    LogicalNot1(LogicalNot1<'t>),
}

///
/// Type derived for non-terminal LogicalNotOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalNotOp<'t> {
    pub logical_not_op: Token<'t>, /* NOT */
}

///
/// Type derived for non-terminal LogicalOr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalOr<'t> {
    pub logical_and: Box<LogicalAnd<'t>>,
    pub logical_or_list: Vec<LogicalOrList<'t>>,
}

///
/// Type derived for non-terminal LogicalOrList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalOrList<'t> {
    pub logical_or_op: Box<LogicalOrOp<'t>>,
    pub logical_and: Box<LogicalAnd<'t>>,
}

///
/// Type derived for non-terminal LogicalOrOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalOrOp<'t> {
    pub logical_or_op: Token<'t>, /* N?OR */
}

///
/// Type derived for non-terminal Minus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Minus<'t> {
    pub minus: Token<'t>, /* - */
}

///
/// Type derived for non-terminal MulOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MulOp<'t> {
    pub mul_op: Token<'t>, /* \*|/ */
}

///
/// Type derived for non-terminal Multiplication
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Multiplication<'t> {
    pub factor: Box<Factor<'t>>,
    pub multiplication_list: Vec<MultiplicationList<'t>>,
}

///
/// Type derived for non-terminal MultiplicationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MultiplicationList<'t> {
    pub mul_op: Box<MulOp<'t>>,
    pub factor: Box<Factor<'t>>,
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Number<'t> {
    Number0(Number0<'t>),
    Number1(Number1<'t>),
}

///
/// Type derived for non-terminal Plus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Plus<'t> {
    pub plus: Token<'t>, /* \+ */
}

///
/// Type derived for non-terminal Print
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Print<'t> {
    pub print: Token<'t>, /* PRINT|\? */
}

///
/// Type derived for non-terminal PrintStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct PrintStatement<'t> {
    pub print: Box<Print<'t>>,
    pub expression: Box<Expression<'t>>,
    pub print_statement_list: Vec<PrintStatementList<'t>>,
}

///
/// Type derived for non-terminal PrintStatementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct PrintStatementList<'t> {
    pub comma: Token<'t>, /* , */
    pub expression: Box<Expression<'t>>,
}

///
/// Type derived for non-terminal RParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RParen<'t> {
    pub r_paren: Token<'t>, /* \) */
}

///
/// Type derived for non-terminal Relational
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relational<'t> {
    pub summation: Box<Summation<'t>>,
    pub relational_list: Vec<RelationalList<'t>>,
}

///
/// Type derived for non-terminal RelationalList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RelationalList<'t> {
    pub relational_op: Box<RelationalOp<'t>>,
    pub summation: Box<Summation<'t>>,
}

///
/// Type derived for non-terminal RelationalOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RelationalOp<'t> {
    pub relational_op: Token<'t>, /* <\s*>|<\s*=|<|>\s*=|>|= */
}

///
/// Type derived for non-terminal Remark
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Remark<'t> {
    pub r_e_m: Token<'t>, /* REM */
    pub remark_suffix: Box<RemarkSuffix<'t>>,
}

///
/// Type derived for non-terminal RemarkSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum RemarkSuffix<'t> {
    RemarkSuffix0(RemarkSuffix0<'t>),
    RemarkSuffix1(RemarkSuffix1),
}

///
/// Type derived for non-terminal Statement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Statement<'t> {
    Statement0(Statement0<'t>),
    Statement1(Statement1<'t>),
    Statement2(Statement2<'t>),
    Statement3(Statement3<'t>),
    Statement4(Statement4<'t>),
    Statement5(Statement5<'t>),
}

///
/// Type derived for non-terminal Summation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Summation<'t> {
    pub multiplication: Box<Multiplication<'t>>,
    pub summation_list: Vec<SummationList<'t>>,
}

///
/// Type derived for non-terminal SummationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SummationList<'t> {
    pub summation_list_group: Box<SummationListGroup<'t>>,
    pub multiplication: Box<Multiplication<'t>>,
}

///
/// Type derived for non-terminal SummationListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SummationListGroup<'t> {
    SummationListGroup0(SummationListGroup0<'t>),
    SummationListGroup1(SummationListGroup1<'t>),
}

///
/// Type derived for non-terminal Then
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Then<'t> {
    pub then: Token<'t>, /* THEN */
}

///
/// Type derived for non-terminal Variable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Variable<'t> {
    pub variable: Token<'t>, /* [A-Z][0-9A-Z]* */
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    AssignOp(AssignOp<'t>),
    Assignment(Assignment<'t>),
    Basic(Basic<'t>),
    BasicList(Vec<BasicList<'t>>),
    BasicSuffix(BasicSuffix<'t>),
    BasicSuffix0(BasicSuffix0<'t>),
    Comment(Comment<'t>),
    End(End<'t>),
    EndOfLine(EndOfLine<'t>),
    EndStatement(EndStatement<'t>),
    Expression(Expression<'t>),
    Factor(Factor<'t>),
    Float(Float<'t>),
    Float1(Float1<'t>),
    Float2(Float2<'t>),
    Goto(Goto<'t>),
    GotoStatement(GotoStatement<'t>),
    If(If<'t>),
    IfBody(IfBody<'t>),
    IfStatement(IfStatement<'t>),
    Integer(Integer<'t>),
    LParen(LParen<'t>),
    Let(Let<'t>),
    Line(Line<'t>),
    LineList(Vec<LineList<'t>>),
    LineNumber(LineNumber<'t>),
    Literal(Literal<'t>),
    LogicalAnd(LogicalAnd<'t>),
    LogicalAndList(Vec<LogicalAndList<'t>>),
    LogicalAndOp(LogicalAndOp<'t>),
    LogicalNot(LogicalNot<'t>),
    LogicalNotOp(LogicalNotOp<'t>),
    LogicalOr(LogicalOr<'t>),
    LogicalOrList(Vec<LogicalOrList<'t>>),
    LogicalOrOp(LogicalOrOp<'t>),
    Minus(Minus<'t>),
    MulOp(MulOp<'t>),
    Multiplication(Multiplication<'t>),
    MultiplicationList(Vec<MultiplicationList<'t>>),
    Number(Number<'t>),
    Plus(Plus<'t>),
    Print(Print<'t>),
    PrintStatement(PrintStatement<'t>),
    PrintStatementList(Vec<PrintStatementList<'t>>),
    RParen(RParen<'t>),
    Relational(Relational<'t>),
    RelationalList(Vec<RelationalList<'t>>),
    RelationalOp(RelationalOp<'t>),
    Remark(Remark<'t>),
    RemarkSuffix(RemarkSuffix<'t>),
    Statement(Statement<'t>),
    Summation(Summation<'t>),
    SummationList(Vec<SummationList<'t>>),
    SummationListGroup(SummationListGroup<'t>),
    Then(Then<'t>),
    Variable(Variable<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct BasicGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn BasicGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
    // Path of the input file. Used for diagnostics.
    file_name: PathBuf,
}

///
/// The `BasicGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> BasicGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn BasicGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            file_name: PathBuf::default(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// Basic: Line BasicList /* Vec */ BasicSuffix0;
    ///
    #[named]
    fn basic_0(
        &mut self,
        _line: &ParseTreeStackEntry<'t>,
        _basic_list: &ParseTreeStackEntry<'t>,
        _basic_suffix0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix0 = if let Some(ASTType::BasicSuffix0(basic_suffix0)) = self.pop(context) {
            basic_suffix0
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicSuffix0", context));
        };
        let basic_list = if let Some(ASTType::BasicList(mut basic_list)) = self.pop(context) {
            basic_list.reverse();
            basic_list
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicList", context));
        };
        let line = if let Some(ASTType::Line(line)) = self.pop(context) {
            line
        } else {
            return Err(miette!("{}: Expecting ASTType::Line", context));
        };
        let basic_0_built = Basic0Builder::default()
            .line(Box::new(line))
            .basic_list(basic_list)
            .basic_suffix0(Box::new(basic_suffix0))
            .build()
            .into_diagnostic()?;
        let basic_0_built = Basic::Basic0(basic_0_built);
        // Calling user action here
        self.user_grammar.basic(&basic_0_built)?;
        self.push(ASTType::Basic(basic_0_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Basic: EndOfLine Line BasicList /* Vec */ BasicSuffix;
    ///
    #[named]
    fn basic_1(
        &mut self,
        _end_of_line: &ParseTreeStackEntry<'t>,
        _line: &ParseTreeStackEntry<'t>,
        _basic_list: &ParseTreeStackEntry<'t>,
        _basic_suffix: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix = if let Some(ASTType::BasicSuffix(basic_suffix)) = self.pop(context) {
            basic_suffix
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicSuffix", context));
        };
        let basic_list = if let Some(ASTType::BasicList(mut basic_list)) = self.pop(context) {
            basic_list.reverse();
            basic_list
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicList", context));
        };
        let line = if let Some(ASTType::Line(line)) = self.pop(context) {
            line
        } else {
            return Err(miette!("{}: Expecting ASTType::Line", context));
        };
        let end_of_line = if let Some(ASTType::EndOfLine(end_of_line)) = self.pop(context) {
            end_of_line
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_1_built = Basic1Builder::default()
            .end_of_line(Box::new(end_of_line))
            .line(Box::new(line))
            .basic_list(basic_list)
            .basic_suffix(Box::new(basic_suffix))
            .build()
            .into_diagnostic()?;
        let basic_1_built = Basic::Basic1(basic_1_built);
        // Calling user action here
        self.user_grammar.basic(&basic_1_built)?;
        self.push(ASTType::Basic(basic_1_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// BasicSuffix0: EndOfLine;
    ///
    #[named]
    fn basic_suffix0_0(
        &mut self,
        _end_of_line: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end_of_line = if let Some(ASTType::EndOfLine(end_of_line)) = self.pop(context) {
            end_of_line
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_suffix0_0_built = BasicSuffix1Builder::default()
            .end_of_line(Box::new(end_of_line))
            .build()
            .into_diagnostic()?;
        let basic_suffix0_0_built = BasicSuffix0::BasicSuffix00(basic_suffix0_0_built);
        self.push(ASTType::BasicSuffix0(basic_suffix0_0_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// BasicSuffix0: ;
    ///
    #[named]
    fn basic_suffix0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix0_1_built = BasicSuffix2Builder::default().build().into_diagnostic()?;
        let basic_suffix0_1_built = BasicSuffix0::BasicSuffix01(basic_suffix0_1_built);
        self.push(ASTType::BasicSuffix0(basic_suffix0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// BasicSuffix: EndOfLine;
    ///
    #[named]
    fn basic_suffix_0(
        &mut self,
        _end_of_line: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end_of_line = if let Some(ASTType::EndOfLine(end_of_line)) = self.pop(context) {
            end_of_line
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_suffix_0_built = BasicSuffix3Builder::default()
            .end_of_line(Box::new(end_of_line))
            .build()
            .into_diagnostic()?;
        let basic_suffix_0_built = BasicSuffix::BasicSuffix0(basic_suffix_0_built);
        self.push(ASTType::BasicSuffix(basic_suffix_0_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// BasicSuffix: ;
    ///
    #[named]
    fn basic_suffix_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix_1_built = BasicSuffix4Builder::default().build().into_diagnostic()?;
        let basic_suffix_1_built = BasicSuffix::BasicSuffix1(basic_suffix_1_built);
        self.push(ASTType::BasicSuffix(basic_suffix_1_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// BasicList: EndOfLine Line BasicList; // Vec<T>::Push
    ///
    #[named]
    fn basic_list_0(
        &mut self,
        _end_of_line: &ParseTreeStackEntry<'t>,
        _line: &ParseTreeStackEntry<'t>,
        _basic_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut basic_list = if let Some(ASTType::BasicList(basic_list)) = self.pop(context) {
            basic_list
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicList", context));
        };
        let line = if let Some(ASTType::Line(line)) = self.pop(context) {
            line
        } else {
            return Err(miette!("{}: Expecting ASTType::Line", context));
        };
        let end_of_line = if let Some(ASTType::EndOfLine(end_of_line)) = self.pop(context) {
            end_of_line
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_list_0_built = BasicListBuilder::default()
            .line(Box::new(line))
            .end_of_line(Box::new(end_of_line))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        basic_list.push(basic_list_0_built);
        self.push(ASTType::BasicList(basic_list), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// BasicList: ; // Vec<T>::New
    ///
    #[named]
    fn basic_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let basic_list_1_built = Vec::new();
        self.push(ASTType::BasicList(basic_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// Line: LineNumber Statement LineList /* Vec */;
    ///
    #[named]
    fn line(
        &mut self,
        _line_number: &ParseTreeStackEntry<'t>,
        _statement: &ParseTreeStackEntry<'t>,
        _line_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_list = if let Some(ASTType::LineList(mut line_list)) = self.pop(context) {
            line_list.reverse();
            line_list
        } else {
            return Err(miette!("{}: Expecting ASTType::LineList", context));
        };
        let statement = if let Some(ASTType::Statement(statement)) = self.pop(context) {
            statement
        } else {
            return Err(miette!("{}: Expecting ASTType::Statement", context));
        };
        let line_number = if let Some(ASTType::LineNumber(line_number)) = self.pop(context) {
            line_number
        } else {
            return Err(miette!("{}: Expecting ASTType::LineNumber", context));
        };
        let line_built = LineBuilder::default()
            .line_number(Box::new(line_number))
            .statement(Box::new(statement))
            .line_list(line_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.line(&line_built)?;
        self.push(ASTType::Line(line_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// LineList: <Expr, INITIAL>":" Statement LineList; // Vec<T>::Push
    ///
    #[named]
    fn line_list_0(
        &mut self,
        colon: &ParseTreeStackEntry<'t>,
        _statement: &ParseTreeStackEntry<'t>,
        _line_list: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = *colon.token(parse_tree)?;
        let mut line_list = if let Some(ASTType::LineList(line_list)) = self.pop(context) {
            line_list
        } else {
            return Err(miette!("{}: Expecting ASTType::LineList", context));
        };
        let statement = if let Some(ASTType::Statement(statement)) = self.pop(context) {
            statement
        } else {
            return Err(miette!("{}: Expecting ASTType::Statement", context));
        };
        let line_list_0_built = LineListBuilder::default()
            .statement(Box::new(statement))
            .colon(colon)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        line_list.push(line_list_0_built);
        self.push(ASTType::LineList(line_list), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// LineList: ; // Vec<T>::New
    ///
    #[named]
    fn line_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_list_1_built = Vec::new();
        self.push(ASTType::LineList(line_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// LineNumber: "[0 ]*[1-9] *(?:[0-9] *){1,4}|[0 ]+";
    ///
    #[named]
    fn line_number(
        &mut self,
        line_number: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_number = *line_number.token(parse_tree)?;
        let line_number_built = LineNumberBuilder::default()
            .line_number(line_number)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.line_number(&line_number_built)?;
        self.push(ASTType::LineNumber(line_number_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// Statement: Remark;
    ///
    #[named]
    fn statement_0(
        &mut self,
        _remark: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let remark = if let Some(ASTType::Remark(remark)) = self.pop(context) {
            remark
        } else {
            return Err(miette!("{}: Expecting ASTType::Remark", context));
        };
        let statement_0_built = Statement0Builder::default()
            .remark(Box::new(remark))
            .build()
            .into_diagnostic()?;
        let statement_0_built = Statement::Statement0(statement_0_built);
        // Calling user action here
        self.user_grammar.statement(&statement_0_built)?;
        self.push(ASTType::Statement(statement_0_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// Statement: GotoStatement;
    ///
    #[named]
    fn statement_1(
        &mut self,
        _goto_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let goto_statement = if let Some(ASTType::GotoStatement(goto_statement)) = self.pop(context)
        {
            goto_statement
        } else {
            return Err(miette!("{}: Expecting ASTType::GotoStatement", context));
        };
        let statement_1_built = Statement1Builder::default()
            .goto_statement(Box::new(goto_statement))
            .build()
            .into_diagnostic()?;
        let statement_1_built = Statement::Statement1(statement_1_built);
        // Calling user action here
        self.user_grammar.statement(&statement_1_built)?;
        self.push(ASTType::Statement(statement_1_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// Statement: IfStatement;
    ///
    #[named]
    fn statement_2(
        &mut self,
        _if_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement = if let Some(ASTType::IfStatement(if_statement)) = self.pop(context) {
            if_statement
        } else {
            return Err(miette!("{}: Expecting ASTType::IfStatement", context));
        };
        let statement_2_built = Statement2Builder::default()
            .if_statement(Box::new(if_statement))
            .build()
            .into_diagnostic()?;
        let statement_2_built = Statement::Statement2(statement_2_built);
        // Calling user action here
        self.user_grammar.statement(&statement_2_built)?;
        self.push(ASTType::Statement(statement_2_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// Statement: Assignment;
    ///
    #[named]
    fn statement_3(
        &mut self,
        _assignment: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment = if let Some(ASTType::Assignment(assignment)) = self.pop(context) {
            assignment
        } else {
            return Err(miette!("{}: Expecting ASTType::Assignment", context));
        };
        let statement_3_built = Statement3Builder::default()
            .assignment(Box::new(assignment))
            .build()
            .into_diagnostic()?;
        let statement_3_built = Statement::Statement3(statement_3_built);
        // Calling user action here
        self.user_grammar.statement(&statement_3_built)?;
        self.push(ASTType::Statement(statement_3_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// Statement: PrintStatement;
    ///
    #[named]
    fn statement_4(
        &mut self,
        _print_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let print_statement =
            if let Some(ASTType::PrintStatement(print_statement)) = self.pop(context) {
                print_statement
            } else {
                return Err(miette!("{}: Expecting ASTType::PrintStatement", context));
            };
        let statement_4_built = Statement4Builder::default()
            .print_statement(Box::new(print_statement))
            .build()
            .into_diagnostic()?;
        let statement_4_built = Statement::Statement4(statement_4_built);
        // Calling user action here
        self.user_grammar.statement(&statement_4_built)?;
        self.push(ASTType::Statement(statement_4_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// Statement: EndStatement;
    ///
    #[named]
    fn statement_5(
        &mut self,
        _end_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end_statement = if let Some(ASTType::EndStatement(end_statement)) = self.pop(context) {
            end_statement
        } else {
            return Err(miette!("{}: Expecting ASTType::EndStatement", context));
        };
        let statement_5_built = Statement5Builder::default()
            .end_statement(Box::new(end_statement))
            .build()
            .into_diagnostic()?;
        let statement_5_built = Statement::Statement5(statement_5_built);
        // Calling user action here
        self.user_grammar.statement(&statement_5_built)?;
        self.push(ASTType::Statement(statement_5_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// Remark: "REM" %push(Cmnt) RemarkSuffix;
    ///
    #[named]
    fn remark(
        &mut self,
        r_e_m: &ParseTreeStackEntry<'t>,
        _remark_suffix: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_e_m = *r_e_m.token(parse_tree)?;
        let remark_suffix = if let Some(ASTType::RemarkSuffix(remark_suffix)) = self.pop(context) {
            remark_suffix
        } else {
            return Err(miette!("{}: Expecting ASTType::RemarkSuffix", context));
        };
        let remark_built = RemarkBuilder::default()
            .r_e_m(r_e_m)
            .remark_suffix(Box::new(remark_suffix))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.remark(&remark_built)?;
        self.push(ASTType::Remark(remark_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// RemarkSuffix: Comment %pop();
    ///
    #[named]
    fn remark_suffix_0(
        &mut self,
        _comment: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comment = if let Some(ASTType::Comment(comment)) = self.pop(context) {
            comment
        } else {
            return Err(miette!("{}: Expecting ASTType::Comment", context));
        };
        let remark_suffix_0_built = RemarkSuffix0Builder::default()
            .comment(Box::new(comment))
            .build()
            .into_diagnostic()?;
        let remark_suffix_0_built = RemarkSuffix::RemarkSuffix0(remark_suffix_0_built);
        self.push(ASTType::RemarkSuffix(remark_suffix_0_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// RemarkSuffix: %pop();
    ///
    #[named]
    fn remark_suffix_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let remark_suffix_1_built = RemarkSuffix1Builder::default().build().into_diagnostic()?;
        let remark_suffix_1_built = RemarkSuffix::RemarkSuffix1(remark_suffix_1_built);
        self.push(ASTType::RemarkSuffix(remark_suffix_1_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// GotoStatement: Goto LineNumber;
    ///
    #[named]
    fn goto_statement(
        &mut self,
        _goto: &ParseTreeStackEntry<'t>,
        _line_number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_number = if let Some(ASTType::LineNumber(line_number)) = self.pop(context) {
            line_number
        } else {
            return Err(miette!("{}: Expecting ASTType::LineNumber", context));
        };
        let goto = if let Some(ASTType::Goto(goto)) = self.pop(context) {
            goto
        } else {
            return Err(miette!("{}: Expecting ASTType::Goto", context));
        };
        let goto_statement_built = GotoStatementBuilder::default()
            .goto(Box::new(goto))
            .line_number(Box::new(line_number))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.goto_statement(&goto_statement_built)?;
        self.push(ASTType::GotoStatement(goto_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// IfStatement: If %push(Expr) Expression %pop() IfBody;
    ///
    #[named]
    fn if_statement(
        &mut self,
        _if: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _if_body: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_body = if let Some(ASTType::IfBody(if_body)) = self.pop(context) {
            if_body
        } else {
            return Err(miette!("{}: Expecting ASTType::IfBody", context));
        };
        let expression = if let Some(ASTType::Expression(expression)) = self.pop(context) {
            expression
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let r#if = if let Some(ASTType::If(r#if)) = self.pop(context) {
            r#if
        } else {
            return Err(miette!("{}: Expecting ASTType::If", context));
        };
        let if_statement_built = IfStatementBuilder::default()
            .r#if(Box::new(r#if))
            .expression(Box::new(expression))
            .if_body(Box::new(if_body))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.if_statement(&if_statement_built)?;
        self.push(ASTType::IfStatement(if_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// Assignment: Let Variable AssignOp %push(Expr) Expression %pop();
    ///
    #[named]
    fn assignment_0(
        &mut self,
        _let: &ParseTreeStackEntry<'t>,
        _variable: &ParseTreeStackEntry<'t>,
        _assign_op: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = if let Some(ASTType::Expression(expression)) = self.pop(context) {
            expression
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let assign_op = if let Some(ASTType::AssignOp(assign_op)) = self.pop(context) {
            assign_op
        } else {
            return Err(miette!("{}: Expecting ASTType::AssignOp", context));
        };
        let variable = if let Some(ASTType::Variable(variable)) = self.pop(context) {
            variable
        } else {
            return Err(miette!("{}: Expecting ASTType::Variable", context));
        };
        let r#let = if let Some(ASTType::Let(r#let)) = self.pop(context) {
            r#let
        } else {
            return Err(miette!("{}: Expecting ASTType::Let", context));
        };
        let assignment_0_built = Assignment0Builder::default()
            .r#let(Box::new(r#let))
            .variable(Box::new(variable))
            .assign_op(Box::new(assign_op))
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        let assignment_0_built = Assignment::Assignment0(assignment_0_built);
        // Calling user action here
        self.user_grammar.assignment(&assignment_0_built)?;
        self.push(ASTType::Assignment(assignment_0_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// Assignment: Variable AssignOp %push(Expr) Expression %pop();
    ///
    #[named]
    fn assignment_1(
        &mut self,
        _variable: &ParseTreeStackEntry<'t>,
        _assign_op: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = if let Some(ASTType::Expression(expression)) = self.pop(context) {
            expression
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let assign_op = if let Some(ASTType::AssignOp(assign_op)) = self.pop(context) {
            assign_op
        } else {
            return Err(miette!("{}: Expecting ASTType::AssignOp", context));
        };
        let variable = if let Some(ASTType::Variable(variable)) = self.pop(context) {
            variable
        } else {
            return Err(miette!("{}: Expecting ASTType::Variable", context));
        };
        let assignment_1_built = Assignment1Builder::default()
            .variable(Box::new(variable))
            .assign_op(Box::new(assign_op))
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        let assignment_1_built = Assignment::Assignment1(assignment_1_built);
        // Calling user action here
        self.user_grammar.assignment(&assignment_1_built)?;
        self.push(ASTType::Assignment(assignment_1_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// IfBody: Then Statement;
    ///
    #[named]
    fn if_body_0(
        &mut self,
        _then: &ParseTreeStackEntry<'t>,
        _statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement = if let Some(ASTType::Statement(statement)) = self.pop(context) {
            statement
        } else {
            return Err(miette!("{}: Expecting ASTType::Statement", context));
        };
        let then = if let Some(ASTType::Then(then)) = self.pop(context) {
            then
        } else {
            return Err(miette!("{}: Expecting ASTType::Then", context));
        };
        let if_body_0_built = IfBody0Builder::default()
            .then(Box::new(then))
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        let if_body_0_built = IfBody::IfBody0(if_body_0_built);
        // Calling user action here
        self.user_grammar.if_body(&if_body_0_built)?;
        self.push(ASTType::IfBody(if_body_0_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// IfBody: Goto LineNumber;
    ///
    #[named]
    fn if_body_1(
        &mut self,
        _goto: &ParseTreeStackEntry<'t>,
        _line_number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_number = if let Some(ASTType::LineNumber(line_number)) = self.pop(context) {
            line_number
        } else {
            return Err(miette!("{}: Expecting ASTType::LineNumber", context));
        };
        let goto = if let Some(ASTType::Goto(goto)) = self.pop(context) {
            goto
        } else {
            return Err(miette!("{}: Expecting ASTType::Goto", context));
        };
        let if_body_1_built = IfBody1Builder::default()
            .goto(Box::new(goto))
            .line_number(Box::new(line_number))
            .build()
            .into_diagnostic()?;
        let if_body_1_built = IfBody::IfBody1(if_body_1_built);
        // Calling user action here
        self.user_grammar.if_body(&if_body_1_built)?;
        self.push(ASTType::IfBody(if_body_1_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// PrintStatement: Print %push(Expr) Expression PrintStatementList /* Vec */ %pop();
    ///
    #[named]
    fn print_statement(
        &mut self,
        _print: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _print_statement_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let print_statement_list = if let Some(ASTType::PrintStatementList(
            mut print_statement_list,
        )) = self.pop(context)
        {
            print_statement_list.reverse();
            print_statement_list
        } else {
            return Err(miette!(
                "{}: Expecting ASTType::PrintStatementList",
                context
            ));
        };
        let expression = if let Some(ASTType::Expression(expression)) = self.pop(context) {
            expression
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let print = if let Some(ASTType::Print(print)) = self.pop(context) {
            print
        } else {
            return Err(miette!("{}: Expecting ASTType::Print", context));
        };
        let print_statement_built = PrintStatementBuilder::default()
            .print(Box::new(print))
            .expression(Box::new(expression))
            .print_statement_list(print_statement_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.print_statement(&print_statement_built)?;
        self.push(ASTType::PrintStatement(print_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// PrintStatementList: <Expr, INITIAL>"," Expression PrintStatementList; // Vec<T>::Push
    ///
    #[named]
    fn print_statement_list_0(
        &mut self,
        comma: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _print_statement_list: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = *comma.token(parse_tree)?;
        let mut print_statement_list =
            if let Some(ASTType::PrintStatementList(print_statement_list)) = self.pop(context) {
                print_statement_list
            } else {
                return Err(miette!(
                    "{}: Expecting ASTType::PrintStatementList",
                    context
                ));
            };
        let expression = if let Some(ASTType::Expression(expression)) = self.pop(context) {
            expression
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let print_statement_list_0_built = PrintStatementListBuilder::default()
            .expression(Box::new(expression))
            .comma(comma)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        print_statement_list.push(print_statement_list_0_built);
        self.push(ASTType::PrintStatementList(print_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// PrintStatementList: ; // Vec<T>::New
    ///
    #[named]
    fn print_statement_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let print_statement_list_1_built = Vec::new();
        self.push(
            ASTType::PrintStatementList(print_statement_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// EndStatement: End;
    ///
    #[named]
    fn end_statement(
        &mut self,
        _end: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = if let Some(ASTType::End(end)) = self.pop(context) {
            end
        } else {
            return Err(miette!("{}: Expecting ASTType::End", context));
        };
        let end_statement_built = EndStatementBuilder::default()
            .end(Box::new(end))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.end_statement(&end_statement_built)?;
        self.push(ASTType::EndStatement(end_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// EndOfLine: <Expr, INITIAL>"(?:\r?\n|\r)+";
    ///
    #[named]
    fn end_of_line(
        &mut self,
        end_of_line: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end_of_line = *end_of_line.token(parse_tree)?;
        let end_of_line_built = EndOfLineBuilder::default()
            .end_of_line(end_of_line)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.end_of_line(&end_of_line_built)?;
        self.push(ASTType::EndOfLine(end_of_line_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// Literal: Number;
    ///
    #[named]
    fn literal(
        &mut self,
        _number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = if let Some(ASTType::Number(number)) = self.pop(context) {
            number
        } else {
            return Err(miette!("{}: Expecting ASTType::Number", context));
        };
        let literal_built = LiteralBuilder::default()
            .number(Box::new(number))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.literal(&literal_built)?;
        self.push(ASTType::Literal(literal_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// Number: Float;
    ///
    #[named]
    fn number_0(
        &mut self,
        _float: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float = if let Some(ASTType::Float(float)) = self.pop(context) {
            float
        } else {
            return Err(miette!("{}: Expecting ASTType::Float", context));
        };
        let number_0_built = Number0Builder::default()
            .float(Box::new(float))
            .build()
            .into_diagnostic()?;
        let number_0_built = Number::Number0(number_0_built);
        // Calling user action here
        self.user_grammar.number(&number_0_built)?;
        self.push(ASTType::Number(number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// Number: Integer;
    ///
    #[named]
    fn number_1(
        &mut self,
        _integer: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = if let Some(ASTType::Integer(integer)) = self.pop(context) {
            integer
        } else {
            return Err(miette!("{}: Expecting ASTType::Integer", context));
        };
        let number_1_built = Number1Builder::default()
            .integer(Box::new(integer))
            .build()
            .into_diagnostic()?;
        let number_1_built = Number::Number1(number_1_built);
        // Calling user action here
        self.user_grammar.number(&number_1_built)?;
        self.push(ASTType::Number(number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// Float: Float1;
    ///
    #[named]
    fn float_0(
        &mut self,
        _float1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float1 = if let Some(ASTType::Float1(float1)) = self.pop(context) {
            float1
        } else {
            return Err(miette!("{}: Expecting ASTType::Float1", context));
        };
        let float_0_built = Float0Builder::default()
            .float1(Box::new(float1))
            .build()
            .into_diagnostic()?;
        let float_0_built = Float::Float0(float_0_built);
        // Calling user action here
        self.user_grammar.float(&float_0_built)?;
        self.push(ASTType::Float(float_0_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// Float: Float2;
    ///
    #[named]
    fn float_1(
        &mut self,
        _float2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float2 = if let Some(ASTType::Float2(float2)) = self.pop(context) {
            float2
        } else {
            return Err(miette!("{}: Expecting ASTType::Float2", context));
        };
        let float_1_built = Float3Builder::default()
            .float2(Box::new(float2))
            .build()
            .into_diagnostic()?;
        let float_1_built = Float::Float1(float_1_built);
        // Calling user action here
        self.user_grammar.float(&float_1_built)?;
        self.push(ASTType::Float(float_1_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// Float1: <Expr>"(?:(?:[0-9] *)+)?\. *(?:(?:[0-9] *)+)? *(?:E *[-+]? *(?:[0-9] *)+)?";
    ///
    #[named]
    fn float1(
        &mut self,
        float1: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float1 = *float1.token(parse_tree)?;
        let float1_built = Float1Builder::default()
            .float1(float1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.float1(&float1_built)?;
        self.push(ASTType::Float1(float1_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// Float2: <Expr>"(?:[0-9] *)+E *[-+]? *(?:[0-9] *)+";
    ///
    #[named]
    fn float2(
        &mut self,
        float2: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float2 = *float2.token(parse_tree)?;
        let float2_built = Float2Builder::default()
            .float2(float2)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.float2(&float2_built)?;
        self.push(ASTType::Float2(float2_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// Integer: <Expr>"(?:[0-9] *)+";
    ///
    #[named]
    fn integer(
        &mut self,
        integer: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = *integer.token(parse_tree)?;
        let integer_built = IntegerBuilder::default()
            .integer(integer)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.integer(&integer_built)?;
        self.push(ASTType::Integer(integer_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// If: "IF";
    ///
    #[named]
    fn r#if(
        &mut self,
        r#if: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#if = *r#if.token(parse_tree)?;
        let r#if_built = IfBuilder::default().r#if(r#if).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#if(&r#if_built)?;
        self.push(ASTType::If(r#if_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// Then: <Expr, INITIAL>"THEN";
    ///
    #[named]
    fn then(
        &mut self,
        then: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let then = *then.token(parse_tree)?;
        let then_built = ThenBuilder::default()
            .then(then)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.then(&then_built)?;
        self.push(ASTType::Then(then_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// Goto: <Expr, INITIAL>"GOTO";
    ///
    #[named]
    fn goto(
        &mut self,
        goto: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let goto = *goto.token(parse_tree)?;
        let goto_built = GotoBuilder::default()
            .goto(goto)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.goto(&goto_built)?;
        self.push(ASTType::Goto(goto_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// Let: "LET";
    ///
    #[named]
    fn r#let(
        &mut self,
        r#let: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#let = *r#let.token(parse_tree)?;
        let r#let_built = LetBuilder::default()
            .r#let(r#let)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#let(&r#let_built)?;
        self.push(ASTType::Let(r#let_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// Print: "PRINT|\?";
    ///
    #[named]
    fn print(
        &mut self,
        print: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let print = *print.token(parse_tree)?;
        let print_built = PrintBuilder::default()
            .print(print)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.print(&print_built)?;
        self.push(ASTType::Print(print_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// End: "END";
    ///
    #[named]
    fn end(
        &mut self,
        end: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = *end.token(parse_tree)?;
        let end_built = EndBuilder::default().end(end).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.end(&end_built)?;
        self.push(ASTType::End(end_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// AssignOp: "=";
    ///
    #[named]
    fn assign_op(
        &mut self,
        assign_op: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_op = *assign_op.token(parse_tree)?;
        let assign_op_built = AssignOpBuilder::default()
            .assign_op(assign_op)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.assign_op(&assign_op_built)?;
        self.push(ASTType::AssignOp(assign_op_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// LogicalOrOp: <Expr>"N?OR";
    ///
    #[named]
    fn logical_or_op(
        &mut self,
        logical_or_op: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or_op = *logical_or_op.token(parse_tree)?;
        let logical_or_op_built = LogicalOrOpBuilder::default()
            .logical_or_op(logical_or_op)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_or_op(&logical_or_op_built)?;
        self.push(ASTType::LogicalOrOp(logical_or_op_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// LogicalAndOp: <Expr>"AND";
    ///
    #[named]
    fn logical_and_op(
        &mut self,
        logical_and_op: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_and_op = *logical_and_op.token(parse_tree)?;
        let logical_and_op_built = LogicalAndOpBuilder::default()
            .logical_and_op(logical_and_op)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_and_op(&logical_and_op_built)?;
        self.push(ASTType::LogicalAndOp(logical_and_op_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// LogicalNotOp: <Expr>"NOT";
    ///
    #[named]
    fn logical_not_op(
        &mut self,
        logical_not_op: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_not_op = *logical_not_op.token(parse_tree)?;
        let logical_not_op_built = LogicalNotOpBuilder::default()
            .logical_not_op(logical_not_op)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_not_op(&logical_not_op_built)?;
        self.push(ASTType::LogicalNotOp(logical_not_op_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// RelationalOp: <Expr>"<\s*>|<\s*=|<|>\s*=|>|=";
    ///
    #[named]
    fn relational_op(
        &mut self,
        relational_op: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational_op = *relational_op.token(parse_tree)?;
        let relational_op_built = RelationalOpBuilder::default()
            .relational_op(relational_op)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.relational_op(&relational_op_built)?;
        self.push(ASTType::RelationalOp(relational_op_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// Plus: <Expr>"\+";
    ///
    #[named]
    fn plus(
        &mut self,
        plus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = *plus.token(parse_tree)?;
        let plus_built = PlusBuilder::default()
            .plus(plus)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.plus(&plus_built)?;
        self.push(ASTType::Plus(plus_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// Minus: <Expr>"-";
    ///
    #[named]
    fn minus(
        &mut self,
        minus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = *minus.token(parse_tree)?;
        let minus_built = MinusBuilder::default()
            .minus(minus)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.minus(&minus_built)?;
        self.push(ASTType::Minus(minus_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// MulOp: <Expr>"\*|/";
    ///
    #[named]
    fn mul_op(
        &mut self,
        mul_op: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mul_op = *mul_op.token(parse_tree)?;
        let mul_op_built = MulOpBuilder::default()
            .mul_op(mul_op)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_built)?;
        self.push(ASTType::MulOp(mul_op_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// LParen: <Expr>"\(";
    ///
    #[named]
    fn l_paren(
        &mut self,
        l_paren: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = *l_paren.token(parse_tree)?;
        let l_paren_built = LParenBuilder::default()
            .l_paren(l_paren)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_paren(&l_paren_built)?;
        self.push(ASTType::LParen(l_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// RParen: <Expr>"\)";
    ///
    #[named]
    fn r_paren(
        &mut self,
        r_paren: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = *r_paren.token(parse_tree)?;
        let r_paren_built = RParenBuilder::default()
            .r_paren(r_paren)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_paren(&r_paren_built)?;
        self.push(ASTType::RParen(r_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// Comment: <Cmnt>"[^\r\n]+";
    ///
    #[named]
    fn comment(
        &mut self,
        comment: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comment = *comment.token(parse_tree)?;
        let comment_built = CommentBuilder::default()
            .comment(comment)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comment(&comment_built)?;
        self.push(ASTType::Comment(comment_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// Variable: <Expr, INITIAL>"[A-Z][0-9A-Z]*";
    ///
    #[named]
    fn variable(
        &mut self,
        variable: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let variable = *variable.token(parse_tree)?;
        let variable_built = VariableBuilder::default()
            .variable(variable)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.variable(&variable_built)?;
        self.push(ASTType::Variable(variable_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// Expression: LogicalOr;
    ///
    #[named]
    fn expression(
        &mut self,
        _logical_or: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or = if let Some(ASTType::LogicalOr(logical_or)) = self.pop(context) {
            logical_or
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalOr", context));
        };
        let expression_built = ExpressionBuilder::default()
            .logical_or(Box::new(logical_or))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression(&expression_built)?;
        self.push(ASTType::Expression(expression_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// LogicalOr: LogicalAnd LogicalOrList /* Vec */;
    ///
    #[named]
    fn logical_or(
        &mut self,
        _logical_and: &ParseTreeStackEntry<'t>,
        _logical_or_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or_list =
            if let Some(ASTType::LogicalOrList(mut logical_or_list)) = self.pop(context) {
                logical_or_list.reverse();
                logical_or_list
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalOrList", context));
            };
        let logical_and = if let Some(ASTType::LogicalAnd(logical_and)) = self.pop(context) {
            logical_and
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalAnd", context));
        };
        let logical_or_built = LogicalOrBuilder::default()
            .logical_and(Box::new(logical_and))
            .logical_or_list(logical_or_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_or(&logical_or_built)?;
        self.push(ASTType::LogicalOr(logical_or_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// LogicalOrList: LogicalOrOp LogicalAnd LogicalOrList; // Vec<T>::Push
    ///
    #[named]
    fn logical_or_list_0(
        &mut self,
        _logical_or_op: &ParseTreeStackEntry<'t>,
        _logical_and: &ParseTreeStackEntry<'t>,
        _logical_or_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut logical_or_list =
            if let Some(ASTType::LogicalOrList(logical_or_list)) = self.pop(context) {
                logical_or_list
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalOrList", context));
            };
        let logical_and = if let Some(ASTType::LogicalAnd(logical_and)) = self.pop(context) {
            logical_and
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalAnd", context));
        };
        let logical_or_op = if let Some(ASTType::LogicalOrOp(logical_or_op)) = self.pop(context) {
            logical_or_op
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalOrOp", context));
        };
        let logical_or_list_0_built = LogicalOrListBuilder::default()
            .logical_and(Box::new(logical_and))
            .logical_or_op(Box::new(logical_or_op))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        logical_or_list.push(logical_or_list_0_built);
        self.push(ASTType::LogicalOrList(logical_or_list), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// LogicalOrList: ; // Vec<T>::New
    ///
    #[named]
    fn logical_or_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or_list_1_built = Vec::new();
        self.push(ASTType::LogicalOrList(logical_or_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// LogicalAnd: LogicalNot LogicalAndList /* Vec */;
    ///
    #[named]
    fn logical_and(
        &mut self,
        _logical_not: &ParseTreeStackEntry<'t>,
        _logical_and_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_and_list =
            if let Some(ASTType::LogicalAndList(mut logical_and_list)) = self.pop(context) {
                logical_and_list.reverse();
                logical_and_list
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalAndList", context));
            };
        let logical_not = if let Some(ASTType::LogicalNot(logical_not)) = self.pop(context) {
            logical_not
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalNot", context));
        };
        let logical_and_built = LogicalAndBuilder::default()
            .logical_not(Box::new(logical_not))
            .logical_and_list(logical_and_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_and(&logical_and_built)?;
        self.push(ASTType::LogicalAnd(logical_and_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// LogicalAndList: LogicalAndOp LogicalNot LogicalAndList; // Vec<T>::Push
    ///
    #[named]
    fn logical_and_list_0(
        &mut self,
        _logical_and_op: &ParseTreeStackEntry<'t>,
        _logical_not: &ParseTreeStackEntry<'t>,
        _logical_and_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut logical_and_list =
            if let Some(ASTType::LogicalAndList(logical_and_list)) = self.pop(context) {
                logical_and_list
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalAndList", context));
            };
        let logical_not = if let Some(ASTType::LogicalNot(logical_not)) = self.pop(context) {
            logical_not
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalNot", context));
        };
        let logical_and_op = if let Some(ASTType::LogicalAndOp(logical_and_op)) = self.pop(context)
        {
            logical_and_op
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalAndOp", context));
        };
        let logical_and_list_0_built = LogicalAndListBuilder::default()
            .logical_not(Box::new(logical_not))
            .logical_and_op(Box::new(logical_and_op))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        logical_and_list.push(logical_and_list_0_built);
        self.push(ASTType::LogicalAndList(logical_and_list), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// LogicalAndList: ; // Vec<T>::New
    ///
    #[named]
    fn logical_and_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_and_list_1_built = Vec::new();
        self.push(ASTType::LogicalAndList(logical_and_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// LogicalNot: LogicalNotOp Relational;
    ///
    #[named]
    fn logical_not_0(
        &mut self,
        _logical_not_op: &ParseTreeStackEntry<'t>,
        _relational: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational = if let Some(ASTType::Relational(relational)) = self.pop(context) {
            relational
        } else {
            return Err(miette!("{}: Expecting ASTType::Relational", context));
        };
        let logical_not_op = if let Some(ASTType::LogicalNotOp(logical_not_op)) = self.pop(context)
        {
            logical_not_op
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalNotOp", context));
        };
        let logical_not_0_built = LogicalNot0Builder::default()
            .logical_not_op(Box::new(logical_not_op))
            .relational(Box::new(relational))
            .build()
            .into_diagnostic()?;
        let logical_not_0_built = LogicalNot::LogicalNot0(logical_not_0_built);
        // Calling user action here
        self.user_grammar.logical_not(&logical_not_0_built)?;
        self.push(ASTType::LogicalNot(logical_not_0_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// LogicalNot: Relational;
    ///
    #[named]
    fn logical_not_1(
        &mut self,
        _relational: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational = if let Some(ASTType::Relational(relational)) = self.pop(context) {
            relational
        } else {
            return Err(miette!("{}: Expecting ASTType::Relational", context));
        };
        let logical_not_1_built = LogicalNot1Builder::default()
            .relational(Box::new(relational))
            .build()
            .into_diagnostic()?;
        let logical_not_1_built = LogicalNot::LogicalNot1(logical_not_1_built);
        // Calling user action here
        self.user_grammar.logical_not(&logical_not_1_built)?;
        self.push(ASTType::LogicalNot(logical_not_1_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// Relational: Summation RelationalList /* Vec */;
    ///
    #[named]
    fn relational(
        &mut self,
        _summation: &ParseTreeStackEntry<'t>,
        _relational_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational_list =
            if let Some(ASTType::RelationalList(mut relational_list)) = self.pop(context) {
                relational_list.reverse();
                relational_list
            } else {
                return Err(miette!("{}: Expecting ASTType::RelationalList", context));
            };
        let summation = if let Some(ASTType::Summation(summation)) = self.pop(context) {
            summation
        } else {
            return Err(miette!("{}: Expecting ASTType::Summation", context));
        };
        let relational_built = RelationalBuilder::default()
            .summation(Box::new(summation))
            .relational_list(relational_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.relational(&relational_built)?;
        self.push(ASTType::Relational(relational_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// RelationalList: RelationalOp Summation RelationalList; // Vec<T>::Push
    ///
    #[named]
    fn relational_list_0(
        &mut self,
        _relational_op: &ParseTreeStackEntry<'t>,
        _summation: &ParseTreeStackEntry<'t>,
        _relational_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut relational_list =
            if let Some(ASTType::RelationalList(relational_list)) = self.pop(context) {
                relational_list
            } else {
                return Err(miette!("{}: Expecting ASTType::RelationalList", context));
            };
        let summation = if let Some(ASTType::Summation(summation)) = self.pop(context) {
            summation
        } else {
            return Err(miette!("{}: Expecting ASTType::Summation", context));
        };
        let relational_op = if let Some(ASTType::RelationalOp(relational_op)) = self.pop(context) {
            relational_op
        } else {
            return Err(miette!("{}: Expecting ASTType::RelationalOp", context));
        };
        let relational_list_0_built = RelationalListBuilder::default()
            .summation(Box::new(summation))
            .relational_op(Box::new(relational_op))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        relational_list.push(relational_list_0_built);
        self.push(ASTType::RelationalList(relational_list), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// RelationalList: ; // Vec<T>::New
    ///
    #[named]
    fn relational_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational_list_1_built = Vec::new();
        self.push(ASTType::RelationalList(relational_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// Summation: Multiplication SummationList /* Vec */;
    ///
    #[named]
    fn summation(
        &mut self,
        _multiplication: &ParseTreeStackEntry<'t>,
        _summation_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let summation_list =
            if let Some(ASTType::SummationList(mut summation_list)) = self.pop(context) {
                summation_list.reverse();
                summation_list
            } else {
                return Err(miette!("{}: Expecting ASTType::SummationList", context));
            };
        let multiplication =
            if let Some(ASTType::Multiplication(multiplication)) = self.pop(context) {
                multiplication
            } else {
                return Err(miette!("{}: Expecting ASTType::Multiplication", context));
            };
        let summation_built = SummationBuilder::default()
            .multiplication(Box::new(multiplication))
            .summation_list(summation_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.summation(&summation_built)?;
        self.push(ASTType::Summation(summation_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// SummationList: SummationListGroup Multiplication SummationList; // Vec<T>::Push
    ///
    #[named]
    fn summation_list_0(
        &mut self,
        _summation_list_group: &ParseTreeStackEntry<'t>,
        _multiplication: &ParseTreeStackEntry<'t>,
        _summation_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut summation_list =
            if let Some(ASTType::SummationList(summation_list)) = self.pop(context) {
                summation_list
            } else {
                return Err(miette!("{}: Expecting ASTType::SummationList", context));
            };
        let multiplication =
            if let Some(ASTType::Multiplication(multiplication)) = self.pop(context) {
                multiplication
            } else {
                return Err(miette!("{}: Expecting ASTType::Multiplication", context));
            };
        let summation_list_group =
            if let Some(ASTType::SummationListGroup(summation_list_group)) = self.pop(context) {
                summation_list_group
            } else {
                return Err(miette!(
                    "{}: Expecting ASTType::SummationListGroup",
                    context
                ));
            };
        let summation_list_0_built = SummationListBuilder::default()
            .multiplication(Box::new(multiplication))
            .summation_list_group(Box::new(summation_list_group))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        summation_list.push(summation_list_0_built);
        self.push(ASTType::SummationList(summation_list), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// SummationListGroup: Plus;
    ///
    #[named]
    fn summation_list_group_0(
        &mut self,
        _plus: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = if let Some(ASTType::Plus(plus)) = self.pop(context) {
            plus
        } else {
            return Err(miette!("{}: Expecting ASTType::Plus", context));
        };
        let summation_list_group_0_built = SummationListGroup0Builder::default()
            .plus(Box::new(plus))
            .build()
            .into_diagnostic()?;
        let summation_list_group_0_built =
            SummationListGroup::SummationListGroup0(summation_list_group_0_built);
        self.push(
            ASTType::SummationListGroup(summation_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// SummationListGroup: Minus;
    ///
    #[named]
    fn summation_list_group_1(
        &mut self,
        _minus: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = if let Some(ASTType::Minus(minus)) = self.pop(context) {
            minus
        } else {
            return Err(miette!("{}: Expecting ASTType::Minus", context));
        };
        let summation_list_group_1_built = SummationListGroup1Builder::default()
            .minus(Box::new(minus))
            .build()
            .into_diagnostic()?;
        let summation_list_group_1_built =
            SummationListGroup::SummationListGroup1(summation_list_group_1_built);
        self.push(
            ASTType::SummationListGroup(summation_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// SummationList: ; // Vec<T>::New
    ///
    #[named]
    fn summation_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let summation_list_1_built = Vec::new();
        self.push(ASTType::SummationList(summation_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// Multiplication: Factor MultiplicationList /* Vec */;
    ///
    #[named]
    fn multiplication(
        &mut self,
        _factor: &ParseTreeStackEntry<'t>,
        _multiplication_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let multiplication_list =
            if let Some(ASTType::MultiplicationList(mut multiplication_list)) = self.pop(context) {
                multiplication_list.reverse();
                multiplication_list
            } else {
                return Err(miette!(
                    "{}: Expecting ASTType::MultiplicationList",
                    context
                ));
            };
        let factor = if let Some(ASTType::Factor(factor)) = self.pop(context) {
            factor
        } else {
            return Err(miette!("{}: Expecting ASTType::Factor", context));
        };
        let multiplication_built = MultiplicationBuilder::default()
            .factor(Box::new(factor))
            .multiplication_list(multiplication_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.multiplication(&multiplication_built)?;
        self.push(ASTType::Multiplication(multiplication_built), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// MultiplicationList: MulOp Factor MultiplicationList; // Vec<T>::Push
    ///
    #[named]
    fn multiplication_list_0(
        &mut self,
        _mul_op: &ParseTreeStackEntry<'t>,
        _factor: &ParseTreeStackEntry<'t>,
        _multiplication_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut multiplication_list =
            if let Some(ASTType::MultiplicationList(multiplication_list)) = self.pop(context) {
                multiplication_list
            } else {
                return Err(miette!(
                    "{}: Expecting ASTType::MultiplicationList",
                    context
                ));
            };
        let factor = if let Some(ASTType::Factor(factor)) = self.pop(context) {
            factor
        } else {
            return Err(miette!("{}: Expecting ASTType::Factor", context));
        };
        let mul_op = if let Some(ASTType::MulOp(mul_op)) = self.pop(context) {
            mul_op
        } else {
            return Err(miette!("{}: Expecting ASTType::MulOp", context));
        };
        let multiplication_list_0_built = MultiplicationListBuilder::default()
            .factor(Box::new(factor))
            .mul_op(Box::new(mul_op))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        multiplication_list.push(multiplication_list_0_built);
        self.push(ASTType::MultiplicationList(multiplication_list), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// MultiplicationList: ; // Vec<T>::New
    ///
    #[named]
    fn multiplication_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let multiplication_list_1_built = Vec::new();
        self.push(
            ASTType::MultiplicationList(multiplication_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// Factor: Literal;
    ///
    #[named]
    fn factor_0(
        &mut self,
        _literal: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let literal = if let Some(ASTType::Literal(literal)) = self.pop(context) {
            literal
        } else {
            return Err(miette!("{}: Expecting ASTType::Literal", context));
        };
        let factor_0_built = Factor0Builder::default()
            .literal(Box::new(literal))
            .build()
            .into_diagnostic()?;
        let factor_0_built = Factor::Factor0(factor_0_built);
        // Calling user action here
        self.user_grammar.factor(&factor_0_built)?;
        self.push(ASTType::Factor(factor_0_built), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// Factor: Variable;
    ///
    #[named]
    fn factor_1(
        &mut self,
        _variable: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let variable = if let Some(ASTType::Variable(variable)) = self.pop(context) {
            variable
        } else {
            return Err(miette!("{}: Expecting ASTType::Variable", context));
        };
        let factor_1_built = Factor1Builder::default()
            .variable(Box::new(variable))
            .build()
            .into_diagnostic()?;
        let factor_1_built = Factor::Factor1(factor_1_built);
        // Calling user action here
        self.user_grammar.factor(&factor_1_built)?;
        self.push(ASTType::Factor(factor_1_built), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// Factor: Minus Factor;
    ///
    #[named]
    fn factor_2(
        &mut self,
        _minus: &ParseTreeStackEntry<'t>,
        _factor: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor = if let Some(ASTType::Factor(factor)) = self.pop(context) {
            factor
        } else {
            return Err(miette!("{}: Expecting ASTType::Factor", context));
        };
        let minus = if let Some(ASTType::Minus(minus)) = self.pop(context) {
            minus
        } else {
            return Err(miette!("{}: Expecting ASTType::Minus", context));
        };
        let factor_2_built = Factor2Builder::default()
            .minus(Box::new(minus))
            .factor(Box::new(factor))
            .build()
            .into_diagnostic()?;
        let factor_2_built = Factor::Factor2(factor_2_built);
        // Calling user action here
        self.user_grammar.factor(&factor_2_built)?;
        self.push(ASTType::Factor(factor_2_built), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// Factor: LParen Expression RParen;
    ///
    #[named]
    fn factor_3(
        &mut self,
        _l_paren: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = if let Some(ASTType::RParen(r_paren)) = self.pop(context) {
            r_paren
        } else {
            return Err(miette!("{}: Expecting ASTType::RParen", context));
        };
        let expression = if let Some(ASTType::Expression(expression)) = self.pop(context) {
            expression
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let l_paren = if let Some(ASTType::LParen(l_paren)) = self.pop(context) {
            l_paren
        } else {
            return Err(miette!("{}: Expecting ASTType::LParen", context));
        };
        let factor_3_built = Factor3Builder::default()
            .l_paren(Box::new(l_paren))
            .expression(Box::new(expression))
            .r_paren(Box::new(r_paren))
            .build()
            .into_diagnostic()?;
        let factor_3_built = Factor::Factor3(factor_3_built);
        // Calling user action here
        self.user_grammar.factor(&factor_3_built)?;
        self.push(ASTType::Factor(factor_3_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for BasicGrammarAuto<'t, '_> {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// It is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, file_name: &Path) {
        self.file_name = file_name.to_owned();
        self.user_grammar.init(file_name);
    }

    ///
    /// This function is implemented automatically for the user's item BasicGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.basic_0(&children[0], &children[1], &children[2], parse_tree),
            1 => self.basic_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            2 => self.basic_suffix0_0(&children[0], parse_tree),
            3 => self.basic_suffix0_1(parse_tree),
            4 => self.basic_suffix_0(&children[0], parse_tree),
            5 => self.basic_suffix_1(parse_tree),
            6 => self.basic_list_0(&children[0], &children[1], &children[2], parse_tree),
            7 => self.basic_list_1(parse_tree),
            8 => self.line(&children[0], &children[1], &children[2], parse_tree),
            9 => self.line_list_0(&children[0], &children[1], &children[2], parse_tree),
            10 => self.line_list_1(parse_tree),
            11 => self.line_number(&children[0], parse_tree),
            12 => self.statement_0(&children[0], parse_tree),
            13 => self.statement_1(&children[0], parse_tree),
            14 => self.statement_2(&children[0], parse_tree),
            15 => self.statement_3(&children[0], parse_tree),
            16 => self.statement_4(&children[0], parse_tree),
            17 => self.statement_5(&children[0], parse_tree),
            18 => self.remark(&children[0], &children[1], parse_tree),
            19 => self.remark_suffix_0(&children[0], parse_tree),
            20 => self.remark_suffix_1(parse_tree),
            21 => self.goto_statement(&children[0], &children[1], parse_tree),
            22 => self.if_statement(&children[0], &children[1], &children[2], parse_tree),
            23 => self.assignment_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            24 => self.assignment_1(&children[0], &children[1], &children[2], parse_tree),
            25 => self.if_body_0(&children[0], &children[1], parse_tree),
            26 => self.if_body_1(&children[0], &children[1], parse_tree),
            27 => self.print_statement(&children[0], &children[1], &children[2], parse_tree),
            28 => self.print_statement_list_0(&children[0], &children[1], &children[2], parse_tree),
            29 => self.print_statement_list_1(parse_tree),
            30 => self.end_statement(&children[0], parse_tree),
            31 => self.end_of_line(&children[0], parse_tree),
            32 => self.literal(&children[0], parse_tree),
            33 => self.number_0(&children[0], parse_tree),
            34 => self.number_1(&children[0], parse_tree),
            35 => self.float_0(&children[0], parse_tree),
            36 => self.float_1(&children[0], parse_tree),
            37 => self.float1(&children[0], parse_tree),
            38 => self.float2(&children[0], parse_tree),
            39 => self.integer(&children[0], parse_tree),
            40 => self.r#if(&children[0], parse_tree),
            41 => self.then(&children[0], parse_tree),
            42 => self.goto(&children[0], parse_tree),
            43 => self.r#let(&children[0], parse_tree),
            44 => self.print(&children[0], parse_tree),
            45 => self.end(&children[0], parse_tree),
            46 => self.assign_op(&children[0], parse_tree),
            47 => self.logical_or_op(&children[0], parse_tree),
            48 => self.logical_and_op(&children[0], parse_tree),
            49 => self.logical_not_op(&children[0], parse_tree),
            50 => self.relational_op(&children[0], parse_tree),
            51 => self.plus(&children[0], parse_tree),
            52 => self.minus(&children[0], parse_tree),
            53 => self.mul_op(&children[0], parse_tree),
            54 => self.l_paren(&children[0], parse_tree),
            55 => self.r_paren(&children[0], parse_tree),
            56 => self.comment(&children[0], parse_tree),
            57 => self.variable(&children[0], parse_tree),
            58 => self.expression(&children[0], parse_tree),
            59 => self.logical_or(&children[0], &children[1], parse_tree),
            60 => self.logical_or_list_0(&children[0], &children[1], &children[2], parse_tree),
            61 => self.logical_or_list_1(parse_tree),
            62 => self.logical_and(&children[0], &children[1], parse_tree),
            63 => self.logical_and_list_0(&children[0], &children[1], &children[2], parse_tree),
            64 => self.logical_and_list_1(parse_tree),
            65 => self.logical_not_0(&children[0], &children[1], parse_tree),
            66 => self.logical_not_1(&children[0], parse_tree),
            67 => self.relational(&children[0], &children[1], parse_tree),
            68 => self.relational_list_0(&children[0], &children[1], &children[2], parse_tree),
            69 => self.relational_list_1(parse_tree),
            70 => self.summation(&children[0], &children[1], parse_tree),
            71 => self.summation_list_0(&children[0], &children[1], &children[2], parse_tree),
            72 => self.summation_list_group_0(&children[0], parse_tree),
            73 => self.summation_list_group_1(&children[0], parse_tree),
            74 => self.summation_list_1(parse_tree),
            75 => self.multiplication(&children[0], &children[1], parse_tree),
            76 => self.multiplication_list_0(&children[0], &children[1], &children[2], parse_tree),
            77 => self.multiplication_list_1(parse_tree),
            78 => self.factor_0(&children[0], parse_tree),
            79 => self.factor_1(&children[0], parse_tree),
            80 => self.factor_2(&children[0], &children[1], parse_tree),
            81 => self.factor_3(&children[0], &children[1], &children[2], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
