// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

#[allow(unused_imports)]
use crate::basic_grammar::BasicGrammar;
use id_tree::Tree;
use log::trace;
use miette::{miette, IntoDiagnostic, Result};
use parol_runtime::lexer::Token;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};
use std::path::{Path, PathBuf};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait BasicGrammarTrait<'t> {
    fn init(&mut self, _file_name: &Path) {}

    /// Semantic action for user production 0:
    ///
    /// Basic: [EndOfLine] Line {EndOfLine Line} [EndOfLine];
    ///
    fn basic(&mut self, _arg: &Basic<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 1:
    ///
    /// Line: LineNumber %push(1) Statement {<0>":" Statement} %pop();
    ///
    fn line(&mut self, _arg: &Line<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 2:
    ///
    /// Statement: <1, 0>"REM" [Comment] | <1, 0>"GOTO" LineNumber | Literal | Variable;
    ///
    fn statement(&mut self, _arg: &Statement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 3:
    ///
    /// LineNumber: <0>"0|[1-9][0-9]{0,4}";
    ///
    fn line_number(&mut self, _arg: &LineNumber<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 4:
    ///
    /// EndOfLine: <1, 0>"(\r?\n|\r)+";
    ///
    fn end_of_line(&mut self, _arg: &EndOfLine<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 5:
    ///
    /// Literal: Number;
    ///
    fn literal(&mut self, _arg: &Literal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 6:
    ///
    /// Number: Float | Integer;
    ///
    fn number(&mut self, _arg: &Number<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 7:
    ///
    /// Float: <1>"([0-9] *)*(\. *([0-9] *)*)?(E *[-+]? *([0-9] *)+)?";
    ///
    fn float(&mut self, _arg: &Float<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 8:
    ///
    /// Integer: <1>"([0-9] *)+";
    ///
    fn integer(&mut self, _arg: &Integer<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 9:
    ///
    /// Comment: <1>"[^\r\n]+";
    ///
    fn comment(&mut self, _arg: &Comment<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 10:
    ///
    /// Variable: <1, 0>"[A-Z][0-9A-Z]*";
    ///
    fn variable(&mut self, _arg: &Variable<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 0
///
/// Basic: Line BasicList /* Vec */ BasicSuffix1;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Basic0<'t> {
    pub line_0: Box<Line<'t>>,
    pub basic_list_1: Vec<BasicList<'t>>,
    pub basic_suffix1_2: Box<BasicSuffix1<'t>>,
}

///
/// Type derived for production 1
///
/// Basic: EndOfLine Line BasicList /* Vec */ BasicSuffix;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Basic1<'t> {
    pub end_of_line_0: Box<EndOfLine<'t>>,
    pub line_1: Box<Line<'t>>,
    pub basic_list_2: Vec<BasicList<'t>>,
    pub basic_suffix_3: Box<BasicSuffix<'t>>,
}

///
/// Type derived for production 2
///
/// BasicSuffix1: EndOfLine;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix1_2<'t> {
    pub end_of_line_0: Box<EndOfLine<'t>>,
}

///
/// Type derived for production 3
///
/// BasicSuffix1: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix1_3 {}

///
/// Type derived for production 4
///
/// BasicSuffix: EndOfLine;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix4<'t> {
    pub end_of_line_0: Box<EndOfLine<'t>>,
}

///
/// Type derived for production 5
///
/// BasicSuffix: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix5 {}

///
/// Type derived for production 11
///
/// Statement: <AfterLn, INITIAL>"REM" StatementSuffix;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement11<'t> {
    pub r_e_m_0: Token<'t>, /* REM */
    pub statement_suffix_1: Box<StatementSuffix<'t>>,
}

///
/// Type derived for production 12
///
/// StatementSuffix: Comment;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementSuffix12<'t> {
    pub comment_0: Box<Comment<'t>>,
}

///
/// Type derived for production 13
///
/// StatementSuffix: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementSuffix13 {}

///
/// Type derived for production 14
///
/// Statement: <AfterLn, INITIAL>"GOTO" LineNumber;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement14<'t> {
    pub g_o_t_o_0: Token<'t>, /* GOTO */
    pub line_number_1: Box<LineNumber<'t>>,
}

///
/// Type derived for production 15
///
/// Statement: Literal;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement15<'t> {
    pub literal_0: Box<Literal<'t>>,
}

///
/// Type derived for production 16
///
/// Statement: Variable;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement16<'t> {
    pub variable_0: Box<Variable<'t>>,
}

///
/// Type derived for production 20
///
/// Number: Float;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number20<'t> {
    pub float_0: Box<Float<'t>>,
}

///
/// Type derived for production 21
///
/// Number: Integer;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number21<'t> {
    pub integer_0: Box<Integer<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal Basic
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Basic<'t> {
    Basic0(Basic0<'t>),
    Basic1(Basic1<'t>),
}

///
/// Type derived for non-terminal BasicList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicList<'t> {
    pub end_of_line_0: Box<EndOfLine<'t>>,
    pub line_1: Box<Line<'t>>,
}

///
/// Type derived for non-terminal BasicSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BasicSuffix<'t> {
    BasicSuffix4(BasicSuffix4<'t>),
    BasicSuffix5(BasicSuffix5),
}

///
/// Type derived for non-terminal BasicSuffix1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BasicSuffix1<'t> {
    BasicSuffix1_2(BasicSuffix1_2<'t>),
    BasicSuffix1_3(BasicSuffix1_3),
}

///
/// Type derived for non-terminal Comment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Comment<'t> {
    pub comment_0: Token<'t>, /* [^\r\n]+ */
}

///
/// Type derived for non-terminal EndOfLine
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct EndOfLine<'t> {
    pub end_of_line_0: Token<'t>, /* (\r?\n|\r)+ */
}

///
/// Type derived for non-terminal Float
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Float<'t> {
    pub float_0: Token<'t>, /* ([0-9] *)*(\. *([0-9] *)*)?(E *[-+]? *([0-9] *)+)? */
}

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Integer<'t> {
    pub integer_0: Token<'t>, /* ([0-9] *)+ */
}

///
/// Type derived for non-terminal Line
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Line<'t> {
    pub line_number_0: Box<LineNumber<'t>>,
    pub statement_2: Box<Statement<'t>>,
    pub line_list_3: Vec<LineList<'t>>,
}

///
/// Type derived for non-terminal LineList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LineList<'t> {
    pub colon_0: Token<'t>, /* : */
    pub statement_1: Box<Statement<'t>>,
}

///
/// Type derived for non-terminal LineNumber
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LineNumber<'t> {
    pub line_number_0: Token<'t>, /* 0|[1-9][0-9]{0,4} */
}

///
/// Type derived for non-terminal Literal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Literal<'t> {
    pub number_0: Box<Number<'t>>,
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Number<'t> {
    Number20(Number20<'t>),
    Number21(Number21<'t>),
}

///
/// Type derived for non-terminal Statement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Statement<'t> {
    Statement11(Statement11<'t>),
    Statement14(Statement14<'t>),
    Statement15(Statement15<'t>),
    Statement16(Statement16<'t>),
}

///
/// Type derived for non-terminal StatementSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StatementSuffix<'t> {
    StatementSuffix12(StatementSuffix12<'t>),
    StatementSuffix13(StatementSuffix13),
}

///
/// Type derived for non-terminal Variable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Variable<'t> {
    pub variable_0: Token<'t>, /* [A-Z][0-9A-Z]* */
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    Basic(Basic<'t>),
    BasicList(Vec<BasicList<'t>>),
    BasicSuffix(BasicSuffix<'t>),
    BasicSuffix1(BasicSuffix1<'t>),
    Comment(Comment<'t>),
    EndOfLine(EndOfLine<'t>),
    Float(Float<'t>),
    Integer(Integer<'t>),
    Line(Line<'t>),
    LineList(Vec<LineList<'t>>),
    LineNumber(LineNumber<'t>),
    Literal(Literal<'t>),
    Number(Number<'t>),
    Statement(Statement<'t>),
    StatementSuffix(StatementSuffix<'t>),
    Variable(Variable<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct BasicGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn BasicGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
    // Path of the input file. Used for diagnostics.
    file_name: PathBuf,
}

///
/// The `BasicGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> BasicGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn BasicGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            file_name: PathBuf::default(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// Basic: Line BasicList /* Vec */ BasicSuffix1;
    ///
    fn basic_0(
        &mut self,
        _line_0: &ParseTreeStackEntry<'t>,
        _basic_list_1: &ParseTreeStackEntry<'t>,
        _basic_suffix1_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_0";
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix1_2 =
            if let Some(ASTType::BasicSuffix1(basic_suffix1_2)) = self.pop(context) {
                basic_suffix1_2
            } else {
                return Err(miette!("{}: Expecting ASTType::BasicSuffix1", context));
            };
        let basic_list_1 = if let Some(ASTType::BasicList(mut basic_list_1)) = self.pop(context) {
            basic_list_1.reverse();
            basic_list_1
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicList", context));
        };
        let line_0 = if let Some(ASTType::Line(line_0)) = self.pop(context) {
            line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Line", context));
        };
        let basic_0_built = Basic0Builder::default()
            .line_0(Box::new(line_0))
            .basic_list_1(basic_list_1)
            .basic_suffix1_2(Box::new(basic_suffix1_2))
            .build()
            .into_diagnostic()?;
        let basic_0_built = Basic::Basic0(basic_0_built);
        // Calling user action here
        self.user_grammar.basic(&basic_0_built)?;
        self.push(ASTType::Basic(basic_0_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Basic: EndOfLine Line BasicList /* Vec */ BasicSuffix;
    ///
    fn basic_1(
        &mut self,
        _end_of_line_0: &ParseTreeStackEntry<'t>,
        _line_1: &ParseTreeStackEntry<'t>,
        _basic_list_2: &ParseTreeStackEntry<'t>,
        _basic_suffix_3: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_1";
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix_3 = if let Some(ASTType::BasicSuffix(basic_suffix_3)) = self.pop(context) {
            basic_suffix_3
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicSuffix", context));
        };
        let basic_list_2 = if let Some(ASTType::BasicList(mut basic_list_2)) = self.pop(context) {
            basic_list_2.reverse();
            basic_list_2
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicList", context));
        };
        let line_1 = if let Some(ASTType::Line(line_1)) = self.pop(context) {
            line_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Line", context));
        };
        let end_of_line_0 = if let Some(ASTType::EndOfLine(end_of_line_0)) = self.pop(context) {
            end_of_line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_1_built = Basic1Builder::default()
            .end_of_line_0(Box::new(end_of_line_0))
            .line_1(Box::new(line_1))
            .basic_list_2(basic_list_2)
            .basic_suffix_3(Box::new(basic_suffix_3))
            .build()
            .into_diagnostic()?;
        let basic_1_built = Basic::Basic1(basic_1_built);
        // Calling user action here
        self.user_grammar.basic(&basic_1_built)?;
        self.push(ASTType::Basic(basic_1_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// BasicSuffix1: EndOfLine;
    ///
    fn basic_suffix1_2(
        &mut self,
        _end_of_line_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_suffix1_2";
        trace!("{}", self.trace_item_stack(context));
        let end_of_line_0 = if let Some(ASTType::EndOfLine(end_of_line_0)) = self.pop(context) {
            end_of_line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_suffix1_2_built = BasicSuffix1_2Builder::default()
            .end_of_line_0(Box::new(end_of_line_0))
            .build()
            .into_diagnostic()?;
        let basic_suffix1_2_built = BasicSuffix1::BasicSuffix1_2(basic_suffix1_2_built);
        self.push(ASTType::BasicSuffix1(basic_suffix1_2_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// BasicSuffix1: ;
    ///
    fn basic_suffix1_3(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "basic_suffix1_3";
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix1_3_built = BasicSuffix1_3Builder::default().build().into_diagnostic()?;
        let basic_suffix1_3_built = BasicSuffix1::BasicSuffix1_3(basic_suffix1_3_built);
        self.push(ASTType::BasicSuffix1(basic_suffix1_3_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// BasicSuffix: EndOfLine;
    ///
    fn basic_suffix_4(
        &mut self,
        _end_of_line_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_suffix_4";
        trace!("{}", self.trace_item_stack(context));
        let end_of_line_0 = if let Some(ASTType::EndOfLine(end_of_line_0)) = self.pop(context) {
            end_of_line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_suffix_4_built = BasicSuffix4Builder::default()
            .end_of_line_0(Box::new(end_of_line_0))
            .build()
            .into_diagnostic()?;
        let basic_suffix_4_built = BasicSuffix::BasicSuffix4(basic_suffix_4_built);
        self.push(ASTType::BasicSuffix(basic_suffix_4_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// BasicSuffix: ;
    ///
    fn basic_suffix_5(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "basic_suffix_5";
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix_5_built = BasicSuffix5Builder::default().build().into_diagnostic()?;
        let basic_suffix_5_built = BasicSuffix::BasicSuffix5(basic_suffix_5_built);
        self.push(ASTType::BasicSuffix(basic_suffix_5_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// BasicList: EndOfLine Line BasicList; // Vec<T>::Push
    ///
    fn basic_list_6(
        &mut self,
        _end_of_line_0: &ParseTreeStackEntry<'t>,
        _line_1: &ParseTreeStackEntry<'t>,
        _basic_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_list_6";
        trace!("{}", self.trace_item_stack(context));
        let mut basic_list_2 = if let Some(ASTType::BasicList(basic_list_2)) = self.pop(context) {
            basic_list_2
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicList", context));
        };
        let line_1 = if let Some(ASTType::Line(line_1)) = self.pop(context) {
            line_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Line", context));
        };
        let end_of_line_0 = if let Some(ASTType::EndOfLine(end_of_line_0)) = self.pop(context) {
            end_of_line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_list_6_built = BasicListBuilder::default()
            .line_1(Box::new(line_1))
            .end_of_line_0(Box::new(end_of_line_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        basic_list_2.push(basic_list_6_built);
        self.push(ASTType::BasicList(basic_list_2), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// BasicList: ; // Vec<T>::New
    ///
    fn basic_list_7(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "basic_list_7";
        trace!("{}", self.trace_item_stack(context));
        let basic_list_7_built = Vec::new();
        self.push(ASTType::BasicList(basic_list_7_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// Line: LineNumber %push(AfterLn) Statement LineList /* Vec */ %pop();
    ///
    fn line_8(
        &mut self,
        _line_number_0: &ParseTreeStackEntry<'t>,
        _statement_2: &ParseTreeStackEntry<'t>,
        _line_list_3: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "line_8";
        trace!("{}", self.trace_item_stack(context));
        let line_list_3 = if let Some(ASTType::LineList(mut line_list_3)) = self.pop(context) {
            line_list_3.reverse();
            line_list_3
        } else {
            return Err(miette!("{}: Expecting ASTType::LineList", context));
        };
        let statement_2 = if let Some(ASTType::Statement(statement_2)) = self.pop(context) {
            statement_2
        } else {
            return Err(miette!("{}: Expecting ASTType::Statement", context));
        };
        let line_number_0 = if let Some(ASTType::LineNumber(line_number_0)) = self.pop(context) {
            line_number_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LineNumber", context));
        };
        let line_8_built = LineBuilder::default()
            .line_number_0(Box::new(line_number_0))
            .statement_2(Box::new(statement_2))
            .line_list_3(line_list_3)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.line(&line_8_built)?;
        self.push(ASTType::Line(line_8_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// LineList: ":" Statement LineList; // Vec<T>::Push
    ///
    fn line_list_9(
        &mut self,
        colon_0: &ParseTreeStackEntry<'t>,
        _statement_1: &ParseTreeStackEntry<'t>,
        _line_list_2: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "line_list_9";
        trace!("{}", self.trace_item_stack(context));
        let colon_0 = *colon_0.token(parse_tree)?;
        let mut line_list_2 = if let Some(ASTType::LineList(line_list_2)) = self.pop(context) {
            line_list_2
        } else {
            return Err(miette!("{}: Expecting ASTType::LineList", context));
        };
        let statement_1 = if let Some(ASTType::Statement(statement_1)) = self.pop(context) {
            statement_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Statement", context));
        };
        let line_list_9_built = LineListBuilder::default()
            .statement_1(Box::new(statement_1))
            .colon_0(colon_0)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        line_list_2.push(line_list_9_built);
        self.push(ASTType::LineList(line_list_2), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// LineList: ; // Vec<T>::New
    ///
    fn line_list_10(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "line_list_10";
        trace!("{}", self.trace_item_stack(context));
        let line_list_10_built = Vec::new();
        self.push(ASTType::LineList(line_list_10_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// Statement: <AfterLn, INITIAL>"REM" StatementSuffix;
    ///
    fn statement_11(
        &mut self,
        r_e_m_0: &ParseTreeStackEntry<'t>,
        _statement_suffix_1: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_11";
        trace!("{}", self.trace_item_stack(context));
        let r_e_m_0 = *r_e_m_0.token(parse_tree)?;
        let statement_suffix_1 =
            if let Some(ASTType::StatementSuffix(statement_suffix_1)) = self.pop(context) {
                statement_suffix_1
            } else {
                return Err(miette!("{}: Expecting ASTType::StatementSuffix", context));
            };
        let statement_11_built = Statement11Builder::default()
            .r_e_m_0(r_e_m_0)
            .statement_suffix_1(Box::new(statement_suffix_1))
            .build()
            .into_diagnostic()?;
        let statement_11_built = Statement::Statement11(statement_11_built);
        // Calling user action here
        self.user_grammar.statement(&statement_11_built)?;
        self.push(ASTType::Statement(statement_11_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// StatementSuffix: Comment;
    ///
    fn statement_suffix_12(
        &mut self,
        _comment_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_suffix_12";
        trace!("{}", self.trace_item_stack(context));
        let comment_0 = if let Some(ASTType::Comment(comment_0)) = self.pop(context) {
            comment_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Comment", context));
        };
        let statement_suffix_12_built = StatementSuffix12Builder::default()
            .comment_0(Box::new(comment_0))
            .build()
            .into_diagnostic()?;
        let statement_suffix_12_built =
            StatementSuffix::StatementSuffix12(statement_suffix_12_built);
        self.push(ASTType::StatementSuffix(statement_suffix_12_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// StatementSuffix: ;
    ///
    fn statement_suffix_13(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "statement_suffix_13";
        trace!("{}", self.trace_item_stack(context));
        let statement_suffix_13_built = StatementSuffix13Builder::default()
            .build()
            .into_diagnostic()?;
        let statement_suffix_13_built =
            StatementSuffix::StatementSuffix13(statement_suffix_13_built);
        self.push(ASTType::StatementSuffix(statement_suffix_13_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// Statement: <AfterLn, INITIAL>"GOTO" LineNumber;
    ///
    fn statement_14(
        &mut self,
        g_o_t_o_0: &ParseTreeStackEntry<'t>,
        _line_number_1: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_14";
        trace!("{}", self.trace_item_stack(context));
        let g_o_t_o_0 = *g_o_t_o_0.token(parse_tree)?;
        let line_number_1 = if let Some(ASTType::LineNumber(line_number_1)) = self.pop(context) {
            line_number_1
        } else {
            return Err(miette!("{}: Expecting ASTType::LineNumber", context));
        };
        let statement_14_built = Statement14Builder::default()
            .g_o_t_o_0(g_o_t_o_0)
            .line_number_1(Box::new(line_number_1))
            .build()
            .into_diagnostic()?;
        let statement_14_built = Statement::Statement14(statement_14_built);
        // Calling user action here
        self.user_grammar.statement(&statement_14_built)?;
        self.push(ASTType::Statement(statement_14_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// Statement: Literal;
    ///
    fn statement_15(
        &mut self,
        _literal_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_15";
        trace!("{}", self.trace_item_stack(context));
        let literal_0 = if let Some(ASTType::Literal(literal_0)) = self.pop(context) {
            literal_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Literal", context));
        };
        let statement_15_built = Statement15Builder::default()
            .literal_0(Box::new(literal_0))
            .build()
            .into_diagnostic()?;
        let statement_15_built = Statement::Statement15(statement_15_built);
        // Calling user action here
        self.user_grammar.statement(&statement_15_built)?;
        self.push(ASTType::Statement(statement_15_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// Statement: Variable;
    ///
    fn statement_16(
        &mut self,
        _variable_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_16";
        trace!("{}", self.trace_item_stack(context));
        let variable_0 = if let Some(ASTType::Variable(variable_0)) = self.pop(context) {
            variable_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Variable", context));
        };
        let statement_16_built = Statement16Builder::default()
            .variable_0(Box::new(variable_0))
            .build()
            .into_diagnostic()?;
        let statement_16_built = Statement::Statement16(statement_16_built);
        // Calling user action here
        self.user_grammar.statement(&statement_16_built)?;
        self.push(ASTType::Statement(statement_16_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// LineNumber: "0|[1-9][0-9]{0,4}";
    ///
    fn line_number_17(
        &mut self,
        line_number_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "line_number_17";
        trace!("{}", self.trace_item_stack(context));
        let line_number_0 = *line_number_0.token(parse_tree)?;
        let line_number_17_built = LineNumberBuilder::default()
            .line_number_0(line_number_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.line_number(&line_number_17_built)?;
        self.push(ASTType::LineNumber(line_number_17_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// EndOfLine: <AfterLn, INITIAL>"(\r?\n|\r)+";
    ///
    fn end_of_line_18(
        &mut self,
        end_of_line_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "end_of_line_18";
        trace!("{}", self.trace_item_stack(context));
        let end_of_line_0 = *end_of_line_0.token(parse_tree)?;
        let end_of_line_18_built = EndOfLineBuilder::default()
            .end_of_line_0(end_of_line_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.end_of_line(&end_of_line_18_built)?;
        self.push(ASTType::EndOfLine(end_of_line_18_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// Literal: Number;
    ///
    fn literal_19(
        &mut self,
        _number_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "literal_19";
        trace!("{}", self.trace_item_stack(context));
        let number_0 = if let Some(ASTType::Number(number_0)) = self.pop(context) {
            number_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Number", context));
        };
        let literal_19_built = LiteralBuilder::default()
            .number_0(Box::new(number_0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.literal(&literal_19_built)?;
        self.push(ASTType::Literal(literal_19_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// Number: Float;
    ///
    fn number_20(
        &mut self,
        _float_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "number_20";
        trace!("{}", self.trace_item_stack(context));
        let float_0 = if let Some(ASTType::Float(float_0)) = self.pop(context) {
            float_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Float", context));
        };
        let number_20_built = Number20Builder::default()
            .float_0(Box::new(float_0))
            .build()
            .into_diagnostic()?;
        let number_20_built = Number::Number20(number_20_built);
        // Calling user action here
        self.user_grammar.number(&number_20_built)?;
        self.push(ASTType::Number(number_20_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// Number: Integer;
    ///
    fn number_21(
        &mut self,
        _integer_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "number_21";
        trace!("{}", self.trace_item_stack(context));
        let integer_0 = if let Some(ASTType::Integer(integer_0)) = self.pop(context) {
            integer_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Integer", context));
        };
        let number_21_built = Number21Builder::default()
            .integer_0(Box::new(integer_0))
            .build()
            .into_diagnostic()?;
        let number_21_built = Number::Number21(number_21_built);
        // Calling user action here
        self.user_grammar.number(&number_21_built)?;
        self.push(ASTType::Number(number_21_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// Float: <AfterLn>"([0-9] *)*(\. *([0-9] *)*)?(E *[-+]? *([0-9] *)+)?";
    ///
    fn float_22(
        &mut self,
        float_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float_22";
        trace!("{}", self.trace_item_stack(context));
        let float_0 = *float_0.token(parse_tree)?;
        let float_22_built = FloatBuilder::default()
            .float_0(float_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.float(&float_22_built)?;
        self.push(ASTType::Float(float_22_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// Integer: <AfterLn>"([0-9] *)+";
    ///
    fn integer_23(
        &mut self,
        integer_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "integer_23";
        trace!("{}", self.trace_item_stack(context));
        let integer_0 = *integer_0.token(parse_tree)?;
        let integer_23_built = IntegerBuilder::default()
            .integer_0(integer_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.integer(&integer_23_built)?;
        self.push(ASTType::Integer(integer_23_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// Comment: <AfterLn>"[^\r\n]+";
    ///
    fn comment_24(
        &mut self,
        comment_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "comment_24";
        trace!("{}", self.trace_item_stack(context));
        let comment_0 = *comment_0.token(parse_tree)?;
        let comment_24_built = CommentBuilder::default()
            .comment_0(comment_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comment(&comment_24_built)?;
        self.push(ASTType::Comment(comment_24_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// Variable: <AfterLn, INITIAL>"[A-Z][0-9A-Z]*";
    ///
    fn variable_25(
        &mut self,
        variable_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "variable_25";
        trace!("{}", self.trace_item_stack(context));
        let variable_0 = *variable_0.token(parse_tree)?;
        let variable_25_built = VariableBuilder::default()
            .variable_0(variable_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.variable(&variable_25_built)?;
        self.push(ASTType::Variable(variable_25_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for BasicGrammarAuto<'t, '_> {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// Is is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, file_name: &Path) {
        self.file_name = file_name.to_owned();
        self.user_grammar.init(file_name);
    }

    ///
    /// This function is implemented automatically for the user's item BasicGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.basic_0(&children[0], &children[1], &children[2], parse_tree),
            1 => self.basic_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            2 => self.basic_suffix1_2(&children[0], parse_tree),
            3 => self.basic_suffix1_3(parse_tree),
            4 => self.basic_suffix_4(&children[0], parse_tree),
            5 => self.basic_suffix_5(parse_tree),
            6 => self.basic_list_6(&children[0], &children[1], &children[2], parse_tree),
            7 => self.basic_list_7(parse_tree),
            8 => self.line_8(&children[0], &children[1], &children[2], parse_tree),
            9 => self.line_list_9(&children[0], &children[1], &children[2], parse_tree),
            10 => self.line_list_10(parse_tree),
            11 => self.statement_11(&children[0], &children[1], parse_tree),
            12 => self.statement_suffix_12(&children[0], parse_tree),
            13 => self.statement_suffix_13(parse_tree),
            14 => self.statement_14(&children[0], &children[1], parse_tree),
            15 => self.statement_15(&children[0], parse_tree),
            16 => self.statement_16(&children[0], parse_tree),
            17 => self.line_number_17(&children[0], parse_tree),
            18 => self.end_of_line_18(&children[0], parse_tree),
            19 => self.literal_19(&children[0], parse_tree),
            20 => self.number_20(&children[0], parse_tree),
            21 => self.number_21(&children[0], parse_tree),
            22 => self.float_22(&children[0], parse_tree),
            23 => self.integer_23(&children[0], parse_tree),
            24 => self.comment_24(&children[0], parse_tree),
            25 => self.variable_25(&children[0], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
