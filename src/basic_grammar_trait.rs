// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

#[allow(unused_imports)]
use crate::basic_grammar::BasicGrammar;
use id_tree::Tree;
use log::trace;
use miette::{miette, IntoDiagnostic, Result};
use parol_runtime::lexer::Token;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};
use std::path::{Path, PathBuf};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait BasicGrammarTrait<'t> {
    fn init(&mut self, _file_name: &Path) {}

    /// Semantic action for user production 0:
    ///
    /// Basic: [EndOfLine] Line {EndOfLine Line} [EndOfLine];
    ///
    fn basic(&mut self, _arg: &Basic<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 1:
    ///
    /// Line: LineNumber Statement {<0>":" Statement};
    ///
    fn line(&mut self, _arg: &Line<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 2:
    ///
    /// Statement: <0>"REM" %push(1) [Comment] %pop() | <0>"GOTO" LineNumber | <0>"IF" %push(2) Expression %pop() IfBody | Assignment | Print | Stop;
    ///
    fn statement(&mut self, _arg: &Statement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 3:
    ///
    /// Assignment: [<0>"LET"] Variable AssignOp %push(2) Expression %pop();
    ///
    fn assignment(&mut self, _arg: &Assignment<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 4:
    ///
    /// IfBody: <0>"THEN" Statement | <0>"GOTO" LineNumber;
    ///
    fn if_body(&mut self, _arg: &IfBody<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 5:
    ///
    /// Print: (<0>"PRINT" | <0>"\?") %push(2) Expression %pop();
    ///
    fn print(&mut self, _arg: &Print<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 6:
    ///
    /// Stop: <0>"STOP";
    ///
    fn stop(&mut self, _arg: &Stop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 7:
    ///
    /// EndOfLine: <2, 0>"(\r?\n|\r)+";
    ///
    fn end_of_line(&mut self, _arg: &EndOfLine<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 8:
    ///
    /// Literal: Number;
    ///
    fn literal(&mut self, _arg: &Literal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 9:
    ///
    /// LineNumber: <0>"([0-9] *){1,5}";
    ///
    fn line_number(&mut self, _arg: &LineNumber<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 10:
    ///
    /// Number: Float | Integer;
    ///
    fn number(&mut self, _arg: &Number<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 11:
    ///
    /// Float: Float1 | Float2;
    ///
    fn float(&mut self, _arg: &Float<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 12:
    ///
    /// Float1: <2>"(([0-9] *)+)?\. *(([0-9] *)+)? *(E *[-+]? *([0-9] *)+)?";
    ///
    fn float1(&mut self, _arg: &Float1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 13:
    ///
    /// Float2: <2>"([0-9] *)+E *[-+]? *([0-9] *)+";
    ///
    fn float2(&mut self, _arg: &Float2<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 14:
    ///
    /// Integer: <2>"([0-9] *)+";
    ///
    fn integer(&mut self, _arg: &Integer<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 15:
    ///
    /// AssignOp: <0>"=";
    ///
    fn assign_op(&mut self, _arg: &AssignOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 16:
    ///
    /// LogicalOrOp: <2>"N?OR";
    ///
    fn logical_or_op(&mut self, _arg: &LogicalOrOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 17:
    ///
    /// LogicalAndOp: <2>"AND";
    ///
    fn logical_and_op(&mut self, _arg: &LogicalAndOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 18:
    ///
    /// LogicalNotOp: <2>"NOT";
    ///
    fn logical_not_op(&mut self, _arg: &LogicalNotOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 19:
    ///
    /// RelationalOp: <2>"<\s*>|<\s*=|<|>\s*=|>|=";
    ///
    fn relational_op(&mut self, _arg: &RelationalOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 20:
    ///
    /// Plus: <2>"\+";
    ///
    fn plus(&mut self, _arg: &Plus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 21:
    ///
    /// Minus: <2>"-";
    ///
    fn minus(&mut self, _arg: &Minus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 22:
    ///
    /// MulOp: <2>"\*|/";
    ///
    fn mul_op(&mut self, _arg: &MulOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 23:
    ///
    /// LParen: <2>"\(";
    ///
    fn l_paren(&mut self, _arg: &LParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 24:
    ///
    /// RParen: <2>"\)";
    ///
    fn r_paren(&mut self, _arg: &RParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 25:
    ///
    /// Comment: <1>"[^\r\n]+";
    ///
    fn comment(&mut self, _arg: &Comment<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 26:
    ///
    /// Variable: <2, 0>"[A-Z][0-9A-Z]*";
    ///
    fn variable(&mut self, _arg: &Variable<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 27:
    ///
    /// Expression: LogicalOr;
    ///
    fn expression(&mut self, _arg: &Expression<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 28:
    ///
    /// LogicalOr: LogicalAnd {LogicalOrOp LogicalAnd};
    ///
    fn logical_or(&mut self, _arg: &LogicalOr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 29:
    ///
    /// LogicalAnd: LogicalNot {LogicalAndOp LogicalNot};
    ///
    fn logical_and(&mut self, _arg: &LogicalAnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 30:
    ///
    /// LogicalNot: [LogicalNotOp] Relational;
    ///
    fn logical_not(&mut self, _arg: &LogicalNot<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 31:
    ///
    /// Relational: Summation {RelationalOp Summation};
    ///
    fn relational(&mut self, _arg: &Relational<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 32:
    ///
    /// Summation: Multiplication {(Plus | Minus) Multiplication};
    ///
    fn summation(&mut self, _arg: &Summation<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 33:
    ///
    /// Multiplication: Factor {MulOp Factor};
    ///
    fn multiplication(&mut self, _arg: &Multiplication<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 34:
    ///
    /// Factor: Literal | Variable | Minus Factor | LParen Expression RParen;
    ///
    fn factor(&mut self, _arg: &Factor<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 0
///
/// Basic: Line BasicList /* Vec */ BasicSuffix1;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Basic0<'t> {
    pub line_0: Box<Line<'t>>,
    pub basic_list_1: Vec<BasicList<'t>>,
    pub basic_suffix1_2: Box<BasicSuffix1<'t>>,
}

///
/// Type derived for production 1
///
/// Basic: EndOfLine Line BasicList /* Vec */ BasicSuffix;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Basic1<'t> {
    pub end_of_line_0: Box<EndOfLine<'t>>,
    pub line_1: Box<Line<'t>>,
    pub basic_list_2: Vec<BasicList<'t>>,
    pub basic_suffix_3: Box<BasicSuffix<'t>>,
}

///
/// Type derived for production 2
///
/// BasicSuffix1: EndOfLine;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix1_2<'t> {
    pub end_of_line_0: Box<EndOfLine<'t>>,
}

///
/// Type derived for production 3
///
/// BasicSuffix1: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix1_3 {}

///
/// Type derived for production 4
///
/// BasicSuffix: EndOfLine;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix4<'t> {
    pub end_of_line_0: Box<EndOfLine<'t>>,
}

///
/// Type derived for production 5
///
/// BasicSuffix: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix5 {}

///
/// Type derived for production 11
///
/// Statement: "REM" %push(Cmnt) StatementSuffix;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement11<'t> {
    pub r_e_m_0: Token<'t>, /* REM */
    pub statement_suffix_2: Box<StatementSuffix<'t>>,
}

///
/// Type derived for production 12
///
/// StatementSuffix: Comment %pop();
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementSuffix12<'t> {
    pub comment_0: Box<Comment<'t>>,
}

///
/// Type derived for production 13
///
/// StatementSuffix: %pop();
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementSuffix13 {}

///
/// Type derived for production 14
///
/// Statement: "GOTO" LineNumber;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement14<'t> {
    pub g_o_t_o_0: Token<'t>, /* GOTO */
    pub line_number_1: Box<LineNumber<'t>>,
}

///
/// Type derived for production 15
///
/// Statement: "IF" %push(Expr) Expression %pop() IfBody;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement15<'t> {
    pub i_f_0: Token<'t>, /* IF */
    pub expression_2: Box<Expression<'t>>,
    pub if_body_4: Box<IfBody<'t>>,
}

///
/// Type derived for production 16
///
/// Statement: Assignment;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement16<'t> {
    pub assignment_0: Box<Assignment<'t>>,
}

///
/// Type derived for production 17
///
/// Statement: Print;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement17<'t> {
    pub print_0: Box<Print<'t>>,
}

///
/// Type derived for production 18
///
/// Statement: Stop;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement18<'t> {
    pub stop_0: Box<Stop<'t>>,
}

///
/// Type derived for production 19
///
/// Assignment: "LET" Variable AssignOp %push(Expr) Expression %pop();
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Assignment19<'t> {
    pub l_e_t_0: Token<'t>, /* LET */
    pub variable_1: Box<Variable<'t>>,
    pub assign_op_2: Box<AssignOp<'t>>,
    pub expression_4: Box<Expression<'t>>,
}

///
/// Type derived for production 20
///
/// Assignment: Variable AssignOp %push(Expr) Expression %pop();
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Assignment20<'t> {
    pub variable_0: Box<Variable<'t>>,
    pub assign_op_1: Box<AssignOp<'t>>,
    pub expression_3: Box<Expression<'t>>,
}

///
/// Type derived for production 21
///
/// IfBody: "THEN" Statement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfBody21<'t> {
    pub t_h_e_n_0: Token<'t>, /* THEN */
    pub statement_1: Box<Statement<'t>>,
}

///
/// Type derived for production 22
///
/// IfBody: "GOTO" LineNumber;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfBody22<'t> {
    pub g_o_t_o_0: Token<'t>, /* GOTO */
    pub line_number_1: Box<LineNumber<'t>>,
}

///
/// Type derived for production 24
///
/// PrintGroup: "PRINT";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct PrintGroup24<'t> {
    pub p_r_i_n_t_0: Token<'t>, /* PRINT */
}

///
/// Type derived for production 25
///
/// PrintGroup: "\?";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct PrintGroup25<'t> {
    pub quest_0: Token<'t>, /* \? */
}

///
/// Type derived for production 30
///
/// Number: Float;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number30<'t> {
    pub float_0: Box<Float<'t>>,
}

///
/// Type derived for production 31
///
/// Number: Integer;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number31<'t> {
    pub integer_0: Box<Integer<'t>>,
}

///
/// Type derived for production 32
///
/// Float: Float1;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Float32<'t> {
    pub float1_0: Box<Float1<'t>>,
}

///
/// Type derived for production 33
///
/// Float: Float2;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Float33<'t> {
    pub float2_0: Box<Float2<'t>>,
}

///
/// Type derived for production 56
///
/// LogicalNot: LogicalNotOp Relational;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalNot56<'t> {
    pub logical_not_op_0: Box<LogicalNotOp<'t>>,
    pub relational_1: Box<Relational<'t>>,
}

///
/// Type derived for production 57
///
/// LogicalNot: Relational;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalNot57<'t> {
    pub relational_0: Box<Relational<'t>>,
}

///
/// Type derived for production 63
///
/// SummationListGroup: Plus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SummationListGroup63<'t> {
    pub plus_0: Box<Plus<'t>>,
}

///
/// Type derived for production 64
///
/// SummationListGroup: Minus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SummationListGroup64<'t> {
    pub minus_0: Box<Minus<'t>>,
}

///
/// Type derived for production 69
///
/// Factor: Literal;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor69<'t> {
    pub literal_0: Box<Literal<'t>>,
}

///
/// Type derived for production 70
///
/// Factor: Variable;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor70<'t> {
    pub variable_0: Box<Variable<'t>>,
}

///
/// Type derived for production 71
///
/// Factor: Minus Factor;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor71<'t> {
    pub minus_0: Box<Minus<'t>>,
    pub factor_1: Box<Factor<'t>>,
}

///
/// Type derived for production 72
///
/// Factor: LParen Expression RParen;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor72<'t> {
    pub l_paren_0: Box<LParen<'t>>,
    pub expression_1: Box<Expression<'t>>,
    pub r_paren_2: Box<RParen<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal AssignOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AssignOp<'t> {
    pub assign_op_0: Token<'t>, /* = */
}

///
/// Type derived for non-terminal Assignment
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Assignment<'t> {
    Assignment19(Assignment19<'t>),
    Assignment20(Assignment20<'t>),
}

///
/// Type derived for non-terminal Basic
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Basic<'t> {
    Basic0(Basic0<'t>),
    Basic1(Basic1<'t>),
}

///
/// Type derived for non-terminal BasicList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicList<'t> {
    pub end_of_line_0: Box<EndOfLine<'t>>,
    pub line_1: Box<Line<'t>>,
}

///
/// Type derived for non-terminal BasicSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BasicSuffix<'t> {
    BasicSuffix4(BasicSuffix4<'t>),
    BasicSuffix5(BasicSuffix5),
}

///
/// Type derived for non-terminal BasicSuffix1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BasicSuffix1<'t> {
    BasicSuffix1_2(BasicSuffix1_2<'t>),
    BasicSuffix1_3(BasicSuffix1_3),
}

///
/// Type derived for non-terminal Comment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Comment<'t> {
    pub comment_0: Token<'t>, /* [^\r\n]+ */
}

///
/// Type derived for non-terminal EndOfLine
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct EndOfLine<'t> {
    pub end_of_line_0: Token<'t>, /* (\r?\n|\r)+ */
}

///
/// Type derived for non-terminal Expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression<'t> {
    pub logical_or_0: Box<LogicalOr<'t>>,
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor<'t> {
    Factor69(Factor69<'t>),
    Factor70(Factor70<'t>),
    Factor71(Factor71<'t>),
    Factor72(Factor72<'t>),
}

///
/// Type derived for non-terminal Float
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Float<'t> {
    Float32(Float32<'t>),
    Float33(Float33<'t>),
}

///
/// Type derived for non-terminal Float1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Float1<'t> {
    pub float1_0: Token<'t>, /* (([0-9] *)+)?\. *(([0-9] *)+)? *(E *[-+]? *([0-9] *)+)? */
}

///
/// Type derived for non-terminal Float2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Float2<'t> {
    pub float2_0: Token<'t>, /* ([0-9] *)+E *[-+]? *([0-9] *)+ */
}

///
/// Type derived for non-terminal IfBody
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IfBody<'t> {
    IfBody21(IfBody21<'t>),
    IfBody22(IfBody22<'t>),
}

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Integer<'t> {
    pub integer_0: Token<'t>, /* ([0-9] *)+ */
}

///
/// Type derived for non-terminal LParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LParen<'t> {
    pub l_paren_0: Token<'t>, /* \( */
}

///
/// Type derived for non-terminal Line
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Line<'t> {
    pub line_number_0: Box<LineNumber<'t>>,
    pub statement_1: Box<Statement<'t>>,
    pub line_list_2: Vec<LineList<'t>>,
}

///
/// Type derived for non-terminal LineList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LineList<'t> {
    pub colon_0: Token<'t>, /* : */
    pub statement_1: Box<Statement<'t>>,
}

///
/// Type derived for non-terminal LineNumber
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LineNumber<'t> {
    pub line_number_0: Token<'t>, /* ([0-9] *){1,5} */
}

///
/// Type derived for non-terminal Literal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Literal<'t> {
    pub number_0: Box<Number<'t>>,
}

///
/// Type derived for non-terminal LogicalAnd
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalAnd<'t> {
    pub logical_not_0: Box<LogicalNot<'t>>,
    pub logical_and_list_1: Vec<LogicalAndList<'t>>,
}

///
/// Type derived for non-terminal LogicalAndList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalAndList<'t> {
    pub logical_and_op_0: Box<LogicalAndOp<'t>>,
    pub logical_not_1: Box<LogicalNot<'t>>,
}

///
/// Type derived for non-terminal LogicalAndOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalAndOp<'t> {
    pub logical_and_op_0: Token<'t>, /* AND */
}

///
/// Type derived for non-terminal LogicalNot
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum LogicalNot<'t> {
    LogicalNot56(LogicalNot56<'t>),
    LogicalNot57(LogicalNot57<'t>),
}

///
/// Type derived for non-terminal LogicalNotOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalNotOp<'t> {
    pub logical_not_op_0: Token<'t>, /* NOT */
}

///
/// Type derived for non-terminal LogicalOr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalOr<'t> {
    pub logical_and_0: Box<LogicalAnd<'t>>,
    pub logical_or_list_1: Vec<LogicalOrList<'t>>,
}

///
/// Type derived for non-terminal LogicalOrList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalOrList<'t> {
    pub logical_or_op_0: Box<LogicalOrOp<'t>>,
    pub logical_and_1: Box<LogicalAnd<'t>>,
}

///
/// Type derived for non-terminal LogicalOrOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalOrOp<'t> {
    pub logical_or_op_0: Token<'t>, /* N?OR */
}

///
/// Type derived for non-terminal Minus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Minus<'t> {
    pub minus_0: Token<'t>, /* - */
}

///
/// Type derived for non-terminal MulOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MulOp<'t> {
    pub mul_op_0: Token<'t>, /* \*|/ */
}

///
/// Type derived for non-terminal Multiplication
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Multiplication<'t> {
    pub factor_0: Box<Factor<'t>>,
    pub multiplication_list_1: Vec<MultiplicationList<'t>>,
}

///
/// Type derived for non-terminal MultiplicationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MultiplicationList<'t> {
    pub mul_op_0: Box<MulOp<'t>>,
    pub factor_1: Box<Factor<'t>>,
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Number<'t> {
    Number30(Number30<'t>),
    Number31(Number31<'t>),
}

///
/// Type derived for non-terminal Plus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Plus<'t> {
    pub plus_0: Token<'t>, /* \+ */
}

///
/// Type derived for non-terminal Print
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Print<'t> {
    pub print_group_0: Box<PrintGroup<'t>>,
    pub expression_2: Box<Expression<'t>>,
}

///
/// Type derived for non-terminal PrintGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum PrintGroup<'t> {
    PrintGroup24(PrintGroup24<'t>),
    PrintGroup25(PrintGroup25<'t>),
}

///
/// Type derived for non-terminal RParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RParen<'t> {
    pub r_paren_0: Token<'t>, /* \) */
}

///
/// Type derived for non-terminal Relational
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relational<'t> {
    pub summation_0: Box<Summation<'t>>,
    pub relational_list_1: Vec<RelationalList<'t>>,
}

///
/// Type derived for non-terminal RelationalList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RelationalList<'t> {
    pub relational_op_0: Box<RelationalOp<'t>>,
    pub summation_1: Box<Summation<'t>>,
}

///
/// Type derived for non-terminal RelationalOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RelationalOp<'t> {
    pub relational_op_0: Token<'t>, /* <\s*>|<\s*=|<|>\s*=|>|= */
}

///
/// Type derived for non-terminal Statement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Statement<'t> {
    Statement11(Statement11<'t>),
    Statement14(Statement14<'t>),
    Statement15(Statement15<'t>),
    Statement16(Statement16<'t>),
    Statement17(Statement17<'t>),
    Statement18(Statement18<'t>),
}

///
/// Type derived for non-terminal StatementSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StatementSuffix<'t> {
    StatementSuffix12(StatementSuffix12<'t>),
    StatementSuffix13(StatementSuffix13),
}

///
/// Type derived for non-terminal Stop
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Stop<'t> {
    pub stop_0: Token<'t>, /* STOP */
}

///
/// Type derived for non-terminal Summation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Summation<'t> {
    pub multiplication_0: Box<Multiplication<'t>>,
    pub summation_list_1: Vec<SummationList<'t>>,
}

///
/// Type derived for non-terminal SummationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SummationList<'t> {
    pub summation_list_group_0: Box<SummationListGroup<'t>>,
    pub multiplication_1: Box<Multiplication<'t>>,
}

///
/// Type derived for non-terminal SummationListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SummationListGroup<'t> {
    SummationListGroup63(SummationListGroup63<'t>),
    SummationListGroup64(SummationListGroup64<'t>),
}

///
/// Type derived for non-terminal Variable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Variable<'t> {
    pub variable_0: Token<'t>, /* [A-Z][0-9A-Z]* */
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    AssignOp(AssignOp<'t>),
    Assignment(Assignment<'t>),
    Basic(Basic<'t>),
    BasicList(Vec<BasicList<'t>>),
    BasicSuffix(BasicSuffix<'t>),
    BasicSuffix1(BasicSuffix1<'t>),
    Comment(Comment<'t>),
    EndOfLine(EndOfLine<'t>),
    Expression(Expression<'t>),
    Factor(Factor<'t>),
    Float(Float<'t>),
    Float1(Float1<'t>),
    Float2(Float2<'t>),
    IfBody(IfBody<'t>),
    Integer(Integer<'t>),
    LParen(LParen<'t>),
    Line(Line<'t>),
    LineList(Vec<LineList<'t>>),
    LineNumber(LineNumber<'t>),
    Literal(Literal<'t>),
    LogicalAnd(LogicalAnd<'t>),
    LogicalAndList(Vec<LogicalAndList<'t>>),
    LogicalAndOp(LogicalAndOp<'t>),
    LogicalNot(LogicalNot<'t>),
    LogicalNotOp(LogicalNotOp<'t>),
    LogicalOr(LogicalOr<'t>),
    LogicalOrList(Vec<LogicalOrList<'t>>),
    LogicalOrOp(LogicalOrOp<'t>),
    Minus(Minus<'t>),
    MulOp(MulOp<'t>),
    Multiplication(Multiplication<'t>),
    MultiplicationList(Vec<MultiplicationList<'t>>),
    Number(Number<'t>),
    Plus(Plus<'t>),
    Print(Print<'t>),
    PrintGroup(PrintGroup<'t>),
    RParen(RParen<'t>),
    Relational(Relational<'t>),
    RelationalList(Vec<RelationalList<'t>>),
    RelationalOp(RelationalOp<'t>),
    Statement(Statement<'t>),
    StatementSuffix(StatementSuffix<'t>),
    Stop(Stop<'t>),
    Summation(Summation<'t>),
    SummationList(Vec<SummationList<'t>>),
    SummationListGroup(SummationListGroup<'t>),
    Variable(Variable<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct BasicGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn BasicGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
    // Path of the input file. Used for diagnostics.
    file_name: PathBuf,
}

///
/// The `BasicGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> BasicGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn BasicGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            file_name: PathBuf::default(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// Basic: Line BasicList /* Vec */ BasicSuffix1;
    ///
    fn basic_0(
        &mut self,
        _line_0: &ParseTreeStackEntry<'t>,
        _basic_list_1: &ParseTreeStackEntry<'t>,
        _basic_suffix1_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_0";
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix1_2 =
            if let Some(ASTType::BasicSuffix1(basic_suffix1_2)) = self.pop(context) {
                basic_suffix1_2
            } else {
                return Err(miette!("{}: Expecting ASTType::BasicSuffix1", context));
            };
        let basic_list_1 = if let Some(ASTType::BasicList(mut basic_list_1)) = self.pop(context) {
            basic_list_1.reverse();
            basic_list_1
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicList", context));
        };
        let line_0 = if let Some(ASTType::Line(line_0)) = self.pop(context) {
            line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Line", context));
        };
        let basic_0_built = Basic0Builder::default()
            .line_0(Box::new(line_0))
            .basic_list_1(basic_list_1)
            .basic_suffix1_2(Box::new(basic_suffix1_2))
            .build()
            .into_diagnostic()?;
        let basic_0_built = Basic::Basic0(basic_0_built);
        // Calling user action here
        self.user_grammar.basic(&basic_0_built)?;
        self.push(ASTType::Basic(basic_0_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Basic: EndOfLine Line BasicList /* Vec */ BasicSuffix;
    ///
    fn basic_1(
        &mut self,
        _end_of_line_0: &ParseTreeStackEntry<'t>,
        _line_1: &ParseTreeStackEntry<'t>,
        _basic_list_2: &ParseTreeStackEntry<'t>,
        _basic_suffix_3: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_1";
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix_3 = if let Some(ASTType::BasicSuffix(basic_suffix_3)) = self.pop(context) {
            basic_suffix_3
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicSuffix", context));
        };
        let basic_list_2 = if let Some(ASTType::BasicList(mut basic_list_2)) = self.pop(context) {
            basic_list_2.reverse();
            basic_list_2
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicList", context));
        };
        let line_1 = if let Some(ASTType::Line(line_1)) = self.pop(context) {
            line_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Line", context));
        };
        let end_of_line_0 = if let Some(ASTType::EndOfLine(end_of_line_0)) = self.pop(context) {
            end_of_line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_1_built = Basic1Builder::default()
            .end_of_line_0(Box::new(end_of_line_0))
            .line_1(Box::new(line_1))
            .basic_list_2(basic_list_2)
            .basic_suffix_3(Box::new(basic_suffix_3))
            .build()
            .into_diagnostic()?;
        let basic_1_built = Basic::Basic1(basic_1_built);
        // Calling user action here
        self.user_grammar.basic(&basic_1_built)?;
        self.push(ASTType::Basic(basic_1_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// BasicSuffix1: EndOfLine;
    ///
    fn basic_suffix1_2(
        &mut self,
        _end_of_line_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_suffix1_2";
        trace!("{}", self.trace_item_stack(context));
        let end_of_line_0 = if let Some(ASTType::EndOfLine(end_of_line_0)) = self.pop(context) {
            end_of_line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_suffix1_2_built = BasicSuffix1_2Builder::default()
            .end_of_line_0(Box::new(end_of_line_0))
            .build()
            .into_diagnostic()?;
        let basic_suffix1_2_built = BasicSuffix1::BasicSuffix1_2(basic_suffix1_2_built);
        self.push(ASTType::BasicSuffix1(basic_suffix1_2_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// BasicSuffix1: ;
    ///
    fn basic_suffix1_3(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "basic_suffix1_3";
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix1_3_built = BasicSuffix1_3Builder::default().build().into_diagnostic()?;
        let basic_suffix1_3_built = BasicSuffix1::BasicSuffix1_3(basic_suffix1_3_built);
        self.push(ASTType::BasicSuffix1(basic_suffix1_3_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// BasicSuffix: EndOfLine;
    ///
    fn basic_suffix_4(
        &mut self,
        _end_of_line_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_suffix_4";
        trace!("{}", self.trace_item_stack(context));
        let end_of_line_0 = if let Some(ASTType::EndOfLine(end_of_line_0)) = self.pop(context) {
            end_of_line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_suffix_4_built = BasicSuffix4Builder::default()
            .end_of_line_0(Box::new(end_of_line_0))
            .build()
            .into_diagnostic()?;
        let basic_suffix_4_built = BasicSuffix::BasicSuffix4(basic_suffix_4_built);
        self.push(ASTType::BasicSuffix(basic_suffix_4_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// BasicSuffix: ;
    ///
    fn basic_suffix_5(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "basic_suffix_5";
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix_5_built = BasicSuffix5Builder::default().build().into_diagnostic()?;
        let basic_suffix_5_built = BasicSuffix::BasicSuffix5(basic_suffix_5_built);
        self.push(ASTType::BasicSuffix(basic_suffix_5_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// BasicList: EndOfLine Line BasicList; // Vec<T>::Push
    ///
    fn basic_list_6(
        &mut self,
        _end_of_line_0: &ParseTreeStackEntry<'t>,
        _line_1: &ParseTreeStackEntry<'t>,
        _basic_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_list_6";
        trace!("{}", self.trace_item_stack(context));
        let mut basic_list_2 = if let Some(ASTType::BasicList(basic_list_2)) = self.pop(context) {
            basic_list_2
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicList", context));
        };
        let line_1 = if let Some(ASTType::Line(line_1)) = self.pop(context) {
            line_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Line", context));
        };
        let end_of_line_0 = if let Some(ASTType::EndOfLine(end_of_line_0)) = self.pop(context) {
            end_of_line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_list_6_built = BasicListBuilder::default()
            .line_1(Box::new(line_1))
            .end_of_line_0(Box::new(end_of_line_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        basic_list_2.push(basic_list_6_built);
        self.push(ASTType::BasicList(basic_list_2), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// BasicList: ; // Vec<T>::New
    ///
    fn basic_list_7(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "basic_list_7";
        trace!("{}", self.trace_item_stack(context));
        let basic_list_7_built = Vec::new();
        self.push(ASTType::BasicList(basic_list_7_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// Line: LineNumber Statement LineList /* Vec */;
    ///
    fn line_8(
        &mut self,
        _line_number_0: &ParseTreeStackEntry<'t>,
        _statement_1: &ParseTreeStackEntry<'t>,
        _line_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "line_8";
        trace!("{}", self.trace_item_stack(context));
        let line_list_2 = if let Some(ASTType::LineList(mut line_list_2)) = self.pop(context) {
            line_list_2.reverse();
            line_list_2
        } else {
            return Err(miette!("{}: Expecting ASTType::LineList", context));
        };
        let statement_1 = if let Some(ASTType::Statement(statement_1)) = self.pop(context) {
            statement_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Statement", context));
        };
        let line_number_0 = if let Some(ASTType::LineNumber(line_number_0)) = self.pop(context) {
            line_number_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LineNumber", context));
        };
        let line_8_built = LineBuilder::default()
            .line_number_0(Box::new(line_number_0))
            .statement_1(Box::new(statement_1))
            .line_list_2(line_list_2)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.line(&line_8_built)?;
        self.push(ASTType::Line(line_8_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// LineList: ":" Statement LineList; // Vec<T>::Push
    ///
    fn line_list_9(
        &mut self,
        colon_0: &ParseTreeStackEntry<'t>,
        _statement_1: &ParseTreeStackEntry<'t>,
        _line_list_2: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "line_list_9";
        trace!("{}", self.trace_item_stack(context));
        let colon_0 = *colon_0.token(parse_tree)?;
        let mut line_list_2 = if let Some(ASTType::LineList(line_list_2)) = self.pop(context) {
            line_list_2
        } else {
            return Err(miette!("{}: Expecting ASTType::LineList", context));
        };
        let statement_1 = if let Some(ASTType::Statement(statement_1)) = self.pop(context) {
            statement_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Statement", context));
        };
        let line_list_9_built = LineListBuilder::default()
            .statement_1(Box::new(statement_1))
            .colon_0(colon_0)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        line_list_2.push(line_list_9_built);
        self.push(ASTType::LineList(line_list_2), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// LineList: ; // Vec<T>::New
    ///
    fn line_list_10(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "line_list_10";
        trace!("{}", self.trace_item_stack(context));
        let line_list_10_built = Vec::new();
        self.push(ASTType::LineList(line_list_10_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// Statement: "REM" %push(Cmnt) StatementSuffix;
    ///
    fn statement_11(
        &mut self,
        r_e_m_0: &ParseTreeStackEntry<'t>,
        _statement_suffix_2: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_11";
        trace!("{}", self.trace_item_stack(context));
        let r_e_m_0 = *r_e_m_0.token(parse_tree)?;
        let statement_suffix_2 =
            if let Some(ASTType::StatementSuffix(statement_suffix_2)) = self.pop(context) {
                statement_suffix_2
            } else {
                return Err(miette!("{}: Expecting ASTType::StatementSuffix", context));
            };
        let statement_11_built = Statement11Builder::default()
            .r_e_m_0(r_e_m_0)
            .statement_suffix_2(Box::new(statement_suffix_2))
            .build()
            .into_diagnostic()?;
        let statement_11_built = Statement::Statement11(statement_11_built);
        // Calling user action here
        self.user_grammar.statement(&statement_11_built)?;
        self.push(ASTType::Statement(statement_11_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// StatementSuffix: Comment %pop();
    ///
    fn statement_suffix_12(
        &mut self,
        _comment_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_suffix_12";
        trace!("{}", self.trace_item_stack(context));
        let comment_0 = if let Some(ASTType::Comment(comment_0)) = self.pop(context) {
            comment_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Comment", context));
        };
        let statement_suffix_12_built = StatementSuffix12Builder::default()
            .comment_0(Box::new(comment_0))
            .build()
            .into_diagnostic()?;
        let statement_suffix_12_built =
            StatementSuffix::StatementSuffix12(statement_suffix_12_built);
        self.push(ASTType::StatementSuffix(statement_suffix_12_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// StatementSuffix: %pop();
    ///
    fn statement_suffix_13(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "statement_suffix_13";
        trace!("{}", self.trace_item_stack(context));
        let statement_suffix_13_built = StatementSuffix13Builder::default()
            .build()
            .into_diagnostic()?;
        let statement_suffix_13_built =
            StatementSuffix::StatementSuffix13(statement_suffix_13_built);
        self.push(ASTType::StatementSuffix(statement_suffix_13_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// Statement: "GOTO" LineNumber;
    ///
    fn statement_14(
        &mut self,
        g_o_t_o_0: &ParseTreeStackEntry<'t>,
        _line_number_1: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_14";
        trace!("{}", self.trace_item_stack(context));
        let g_o_t_o_0 = *g_o_t_o_0.token(parse_tree)?;
        let line_number_1 = if let Some(ASTType::LineNumber(line_number_1)) = self.pop(context) {
            line_number_1
        } else {
            return Err(miette!("{}: Expecting ASTType::LineNumber", context));
        };
        let statement_14_built = Statement14Builder::default()
            .g_o_t_o_0(g_o_t_o_0)
            .line_number_1(Box::new(line_number_1))
            .build()
            .into_diagnostic()?;
        let statement_14_built = Statement::Statement14(statement_14_built);
        // Calling user action here
        self.user_grammar.statement(&statement_14_built)?;
        self.push(ASTType::Statement(statement_14_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// Statement: "IF" %push(Expr) Expression %pop() IfBody;
    ///
    fn statement_15(
        &mut self,
        i_f_0: &ParseTreeStackEntry<'t>,
        _expression_2: &ParseTreeStackEntry<'t>,
        _if_body_4: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_15";
        trace!("{}", self.trace_item_stack(context));
        let i_f_0 = *i_f_0.token(parse_tree)?;
        let if_body_4 = if let Some(ASTType::IfBody(if_body_4)) = self.pop(context) {
            if_body_4
        } else {
            return Err(miette!("{}: Expecting ASTType::IfBody", context));
        };
        let expression_2 = if let Some(ASTType::Expression(expression_2)) = self.pop(context) {
            expression_2
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let statement_15_built = Statement15Builder::default()
            .i_f_0(i_f_0)
            .expression_2(Box::new(expression_2))
            .if_body_4(Box::new(if_body_4))
            .build()
            .into_diagnostic()?;
        let statement_15_built = Statement::Statement15(statement_15_built);
        // Calling user action here
        self.user_grammar.statement(&statement_15_built)?;
        self.push(ASTType::Statement(statement_15_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// Statement: Assignment;
    ///
    fn statement_16(
        &mut self,
        _assignment_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_16";
        trace!("{}", self.trace_item_stack(context));
        let assignment_0 = if let Some(ASTType::Assignment(assignment_0)) = self.pop(context) {
            assignment_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Assignment", context));
        };
        let statement_16_built = Statement16Builder::default()
            .assignment_0(Box::new(assignment_0))
            .build()
            .into_diagnostic()?;
        let statement_16_built = Statement::Statement16(statement_16_built);
        // Calling user action here
        self.user_grammar.statement(&statement_16_built)?;
        self.push(ASTType::Statement(statement_16_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// Statement: Print;
    ///
    fn statement_17(
        &mut self,
        _print_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_17";
        trace!("{}", self.trace_item_stack(context));
        let print_0 = if let Some(ASTType::Print(print_0)) = self.pop(context) {
            print_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Print", context));
        };
        let statement_17_built = Statement17Builder::default()
            .print_0(Box::new(print_0))
            .build()
            .into_diagnostic()?;
        let statement_17_built = Statement::Statement17(statement_17_built);
        // Calling user action here
        self.user_grammar.statement(&statement_17_built)?;
        self.push(ASTType::Statement(statement_17_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// Statement: Stop;
    ///
    fn statement_18(
        &mut self,
        _stop_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_18";
        trace!("{}", self.trace_item_stack(context));
        let stop_0 = if let Some(ASTType::Stop(stop_0)) = self.pop(context) {
            stop_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Stop", context));
        };
        let statement_18_built = Statement18Builder::default()
            .stop_0(Box::new(stop_0))
            .build()
            .into_diagnostic()?;
        let statement_18_built = Statement::Statement18(statement_18_built);
        // Calling user action here
        self.user_grammar.statement(&statement_18_built)?;
        self.push(ASTType::Statement(statement_18_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// Assignment: "LET" Variable AssignOp %push(Expr) Expression %pop();
    ///
    fn assignment_19(
        &mut self,
        l_e_t_0: &ParseTreeStackEntry<'t>,
        _variable_1: &ParseTreeStackEntry<'t>,
        _assign_op_2: &ParseTreeStackEntry<'t>,
        _expression_4: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "assignment_19";
        trace!("{}", self.trace_item_stack(context));
        let l_e_t_0 = *l_e_t_0.token(parse_tree)?;
        let expression_4 = if let Some(ASTType::Expression(expression_4)) = self.pop(context) {
            expression_4
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let assign_op_2 = if let Some(ASTType::AssignOp(assign_op_2)) = self.pop(context) {
            assign_op_2
        } else {
            return Err(miette!("{}: Expecting ASTType::AssignOp", context));
        };
        let variable_1 = if let Some(ASTType::Variable(variable_1)) = self.pop(context) {
            variable_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Variable", context));
        };
        let assignment_19_built = Assignment19Builder::default()
            .l_e_t_0(l_e_t_0)
            .variable_1(Box::new(variable_1))
            .assign_op_2(Box::new(assign_op_2))
            .expression_4(Box::new(expression_4))
            .build()
            .into_diagnostic()?;
        let assignment_19_built = Assignment::Assignment19(assignment_19_built);
        // Calling user action here
        self.user_grammar.assignment(&assignment_19_built)?;
        self.push(ASTType::Assignment(assignment_19_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// Assignment: Variable AssignOp %push(Expr) Expression %pop();
    ///
    fn assignment_20(
        &mut self,
        _variable_0: &ParseTreeStackEntry<'t>,
        _assign_op_1: &ParseTreeStackEntry<'t>,
        _expression_3: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "assignment_20";
        trace!("{}", self.trace_item_stack(context));
        let expression_3 = if let Some(ASTType::Expression(expression_3)) = self.pop(context) {
            expression_3
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let assign_op_1 = if let Some(ASTType::AssignOp(assign_op_1)) = self.pop(context) {
            assign_op_1
        } else {
            return Err(miette!("{}: Expecting ASTType::AssignOp", context));
        };
        let variable_0 = if let Some(ASTType::Variable(variable_0)) = self.pop(context) {
            variable_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Variable", context));
        };
        let assignment_20_built = Assignment20Builder::default()
            .variable_0(Box::new(variable_0))
            .assign_op_1(Box::new(assign_op_1))
            .expression_3(Box::new(expression_3))
            .build()
            .into_diagnostic()?;
        let assignment_20_built = Assignment::Assignment20(assignment_20_built);
        // Calling user action here
        self.user_grammar.assignment(&assignment_20_built)?;
        self.push(ASTType::Assignment(assignment_20_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// IfBody: "THEN" Statement;
    ///
    fn if_body_21(
        &mut self,
        t_h_e_n_0: &ParseTreeStackEntry<'t>,
        _statement_1: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "if_body_21";
        trace!("{}", self.trace_item_stack(context));
        let t_h_e_n_0 = *t_h_e_n_0.token(parse_tree)?;
        let statement_1 = if let Some(ASTType::Statement(statement_1)) = self.pop(context) {
            statement_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Statement", context));
        };
        let if_body_21_built = IfBody21Builder::default()
            .t_h_e_n_0(t_h_e_n_0)
            .statement_1(Box::new(statement_1))
            .build()
            .into_diagnostic()?;
        let if_body_21_built = IfBody::IfBody21(if_body_21_built);
        // Calling user action here
        self.user_grammar.if_body(&if_body_21_built)?;
        self.push(ASTType::IfBody(if_body_21_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// IfBody: "GOTO" LineNumber;
    ///
    fn if_body_22(
        &mut self,
        g_o_t_o_0: &ParseTreeStackEntry<'t>,
        _line_number_1: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "if_body_22";
        trace!("{}", self.trace_item_stack(context));
        let g_o_t_o_0 = *g_o_t_o_0.token(parse_tree)?;
        let line_number_1 = if let Some(ASTType::LineNumber(line_number_1)) = self.pop(context) {
            line_number_1
        } else {
            return Err(miette!("{}: Expecting ASTType::LineNumber", context));
        };
        let if_body_22_built = IfBody22Builder::default()
            .g_o_t_o_0(g_o_t_o_0)
            .line_number_1(Box::new(line_number_1))
            .build()
            .into_diagnostic()?;
        let if_body_22_built = IfBody::IfBody22(if_body_22_built);
        // Calling user action here
        self.user_grammar.if_body(&if_body_22_built)?;
        self.push(ASTType::IfBody(if_body_22_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// Print: PrintGroup %push(Expr) Expression %pop();
    ///
    fn print_23(
        &mut self,
        _print_group_0: &ParseTreeStackEntry<'t>,
        _expression_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "print_23";
        trace!("{}", self.trace_item_stack(context));
        let expression_2 = if let Some(ASTType::Expression(expression_2)) = self.pop(context) {
            expression_2
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let print_group_0 = if let Some(ASTType::PrintGroup(print_group_0)) = self.pop(context) {
            print_group_0
        } else {
            return Err(miette!("{}: Expecting ASTType::PrintGroup", context));
        };
        let print_23_built = PrintBuilder::default()
            .print_group_0(Box::new(print_group_0))
            .expression_2(Box::new(expression_2))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.print(&print_23_built)?;
        self.push(ASTType::Print(print_23_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// PrintGroup: "PRINT";
    ///
    fn print_group_24(
        &mut self,
        p_r_i_n_t_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "print_group_24";
        trace!("{}", self.trace_item_stack(context));
        let p_r_i_n_t_0 = *p_r_i_n_t_0.token(parse_tree)?;
        let print_group_24_built = PrintGroup24Builder::default()
            .p_r_i_n_t_0(p_r_i_n_t_0)
            .build()
            .into_diagnostic()?;
        let print_group_24_built = PrintGroup::PrintGroup24(print_group_24_built);
        self.push(ASTType::PrintGroup(print_group_24_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// PrintGroup: "\?";
    ///
    fn print_group_25(
        &mut self,
        quest_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "print_group_25";
        trace!("{}", self.trace_item_stack(context));
        let quest_0 = *quest_0.token(parse_tree)?;
        let print_group_25_built = PrintGroup25Builder::default()
            .quest_0(quest_0)
            .build()
            .into_diagnostic()?;
        let print_group_25_built = PrintGroup::PrintGroup25(print_group_25_built);
        self.push(ASTType::PrintGroup(print_group_25_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// Stop: "STOP";
    ///
    fn stop_26(
        &mut self,
        stop_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "stop_26";
        trace!("{}", self.trace_item_stack(context));
        let stop_0 = *stop_0.token(parse_tree)?;
        let stop_26_built = StopBuilder::default()
            .stop_0(stop_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.stop(&stop_26_built)?;
        self.push(ASTType::Stop(stop_26_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// EndOfLine: <Expr, INITIAL>"(\r?\n|\r)+";
    ///
    fn end_of_line_27(
        &mut self,
        end_of_line_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "end_of_line_27";
        trace!("{}", self.trace_item_stack(context));
        let end_of_line_0 = *end_of_line_0.token(parse_tree)?;
        let end_of_line_27_built = EndOfLineBuilder::default()
            .end_of_line_0(end_of_line_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.end_of_line(&end_of_line_27_built)?;
        self.push(ASTType::EndOfLine(end_of_line_27_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// Literal: Number;
    ///
    fn literal_28(
        &mut self,
        _number_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "literal_28";
        trace!("{}", self.trace_item_stack(context));
        let number_0 = if let Some(ASTType::Number(number_0)) = self.pop(context) {
            number_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Number", context));
        };
        let literal_28_built = LiteralBuilder::default()
            .number_0(Box::new(number_0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.literal(&literal_28_built)?;
        self.push(ASTType::Literal(literal_28_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// LineNumber: "([0-9] *){1,5}";
    ///
    fn line_number_29(
        &mut self,
        line_number_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "line_number_29";
        trace!("{}", self.trace_item_stack(context));
        let line_number_0 = *line_number_0.token(parse_tree)?;
        let line_number_29_built = LineNumberBuilder::default()
            .line_number_0(line_number_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.line_number(&line_number_29_built)?;
        self.push(ASTType::LineNumber(line_number_29_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// Number: Float;
    ///
    fn number_30(
        &mut self,
        _float_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "number_30";
        trace!("{}", self.trace_item_stack(context));
        let float_0 = if let Some(ASTType::Float(float_0)) = self.pop(context) {
            float_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Float", context));
        };
        let number_30_built = Number30Builder::default()
            .float_0(Box::new(float_0))
            .build()
            .into_diagnostic()?;
        let number_30_built = Number::Number30(number_30_built);
        // Calling user action here
        self.user_grammar.number(&number_30_built)?;
        self.push(ASTType::Number(number_30_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// Number: Integer;
    ///
    fn number_31(
        &mut self,
        _integer_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "number_31";
        trace!("{}", self.trace_item_stack(context));
        let integer_0 = if let Some(ASTType::Integer(integer_0)) = self.pop(context) {
            integer_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Integer", context));
        };
        let number_31_built = Number31Builder::default()
            .integer_0(Box::new(integer_0))
            .build()
            .into_diagnostic()?;
        let number_31_built = Number::Number31(number_31_built);
        // Calling user action here
        self.user_grammar.number(&number_31_built)?;
        self.push(ASTType::Number(number_31_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// Float: Float1;
    ///
    fn float_32(
        &mut self,
        _float1_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float_32";
        trace!("{}", self.trace_item_stack(context));
        let float1_0 = if let Some(ASTType::Float1(float1_0)) = self.pop(context) {
            float1_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Float1", context));
        };
        let float_32_built = Float32Builder::default()
            .float1_0(Box::new(float1_0))
            .build()
            .into_diagnostic()?;
        let float_32_built = Float::Float32(float_32_built);
        // Calling user action here
        self.user_grammar.float(&float_32_built)?;
        self.push(ASTType::Float(float_32_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// Float: Float2;
    ///
    fn float_33(
        &mut self,
        _float2_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float_33";
        trace!("{}", self.trace_item_stack(context));
        let float2_0 = if let Some(ASTType::Float2(float2_0)) = self.pop(context) {
            float2_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Float2", context));
        };
        let float_33_built = Float33Builder::default()
            .float2_0(Box::new(float2_0))
            .build()
            .into_diagnostic()?;
        let float_33_built = Float::Float33(float_33_built);
        // Calling user action here
        self.user_grammar.float(&float_33_built)?;
        self.push(ASTType::Float(float_33_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// Float1: <Expr>"(([0-9] *)+)?\. *(([0-9] *)+)? *(E *[-+]? *([0-9] *)+)?";
    ///
    fn float1_34(
        &mut self,
        float1_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float1_34";
        trace!("{}", self.trace_item_stack(context));
        let float1_0 = *float1_0.token(parse_tree)?;
        let float1_34_built = Float1Builder::default()
            .float1_0(float1_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.float1(&float1_34_built)?;
        self.push(ASTType::Float1(float1_34_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// Float2: <Expr>"([0-9] *)+E *[-+]? *([0-9] *)+";
    ///
    fn float2_35(
        &mut self,
        float2_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float2_35";
        trace!("{}", self.trace_item_stack(context));
        let float2_0 = *float2_0.token(parse_tree)?;
        let float2_35_built = Float2Builder::default()
            .float2_0(float2_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.float2(&float2_35_built)?;
        self.push(ASTType::Float2(float2_35_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// Integer: <Expr>"([0-9] *)+";
    ///
    fn integer_36(
        &mut self,
        integer_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "integer_36";
        trace!("{}", self.trace_item_stack(context));
        let integer_0 = *integer_0.token(parse_tree)?;
        let integer_36_built = IntegerBuilder::default()
            .integer_0(integer_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.integer(&integer_36_built)?;
        self.push(ASTType::Integer(integer_36_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// AssignOp: "=";
    ///
    fn assign_op_37(
        &mut self,
        assign_op_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "assign_op_37";
        trace!("{}", self.trace_item_stack(context));
        let assign_op_0 = *assign_op_0.token(parse_tree)?;
        let assign_op_37_built = AssignOpBuilder::default()
            .assign_op_0(assign_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.assign_op(&assign_op_37_built)?;
        self.push(ASTType::AssignOp(assign_op_37_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// LogicalOrOp: <Expr>"N?OR";
    ///
    fn logical_or_op_38(
        &mut self,
        logical_or_op_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_or_op_38";
        trace!("{}", self.trace_item_stack(context));
        let logical_or_op_0 = *logical_or_op_0.token(parse_tree)?;
        let logical_or_op_38_built = LogicalOrOpBuilder::default()
            .logical_or_op_0(logical_or_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_or_op(&logical_or_op_38_built)?;
        self.push(ASTType::LogicalOrOp(logical_or_op_38_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// LogicalAndOp: <Expr>"AND";
    ///
    fn logical_and_op_39(
        &mut self,
        logical_and_op_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_and_op_39";
        trace!("{}", self.trace_item_stack(context));
        let logical_and_op_0 = *logical_and_op_0.token(parse_tree)?;
        let logical_and_op_39_built = LogicalAndOpBuilder::default()
            .logical_and_op_0(logical_and_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_and_op(&logical_and_op_39_built)?;
        self.push(ASTType::LogicalAndOp(logical_and_op_39_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// LogicalNotOp: <Expr>"NOT";
    ///
    fn logical_not_op_40(
        &mut self,
        logical_not_op_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_not_op_40";
        trace!("{}", self.trace_item_stack(context));
        let logical_not_op_0 = *logical_not_op_0.token(parse_tree)?;
        let logical_not_op_40_built = LogicalNotOpBuilder::default()
            .logical_not_op_0(logical_not_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_not_op(&logical_not_op_40_built)?;
        self.push(ASTType::LogicalNotOp(logical_not_op_40_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// RelationalOp: <Expr>"<\s*>|<\s*=|<|>\s*=|>|=";
    ///
    fn relational_op_41(
        &mut self,
        relational_op_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "relational_op_41";
        trace!("{}", self.trace_item_stack(context));
        let relational_op_0 = *relational_op_0.token(parse_tree)?;
        let relational_op_41_built = RelationalOpBuilder::default()
            .relational_op_0(relational_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.relational_op(&relational_op_41_built)?;
        self.push(ASTType::RelationalOp(relational_op_41_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// Plus: <Expr>"\+";
    ///
    fn plus_42(
        &mut self,
        plus_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "plus_42";
        trace!("{}", self.trace_item_stack(context));
        let plus_0 = *plus_0.token(parse_tree)?;
        let plus_42_built = PlusBuilder::default()
            .plus_0(plus_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.plus(&plus_42_built)?;
        self.push(ASTType::Plus(plus_42_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// Minus: <Expr>"-";
    ///
    fn minus_43(
        &mut self,
        minus_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "minus_43";
        trace!("{}", self.trace_item_stack(context));
        let minus_0 = *minus_0.token(parse_tree)?;
        let minus_43_built = MinusBuilder::default()
            .minus_0(minus_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.minus(&minus_43_built)?;
        self.push(ASTType::Minus(minus_43_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// MulOp: <Expr>"\*|/";
    ///
    fn mul_op_44(
        &mut self,
        mul_op_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "mul_op_44";
        trace!("{}", self.trace_item_stack(context));
        let mul_op_0 = *mul_op_0.token(parse_tree)?;
        let mul_op_44_built = MulOpBuilder::default()
            .mul_op_0(mul_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_44_built)?;
        self.push(ASTType::MulOp(mul_op_44_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// LParen: <Expr>"\(";
    ///
    fn l_paren_45(
        &mut self,
        l_paren_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "l_paren_45";
        trace!("{}", self.trace_item_stack(context));
        let l_paren_0 = *l_paren_0.token(parse_tree)?;
        let l_paren_45_built = LParenBuilder::default()
            .l_paren_0(l_paren_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_paren(&l_paren_45_built)?;
        self.push(ASTType::LParen(l_paren_45_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// RParen: <Expr>"\)";
    ///
    fn r_paren_46(
        &mut self,
        r_paren_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "r_paren_46";
        trace!("{}", self.trace_item_stack(context));
        let r_paren_0 = *r_paren_0.token(parse_tree)?;
        let r_paren_46_built = RParenBuilder::default()
            .r_paren_0(r_paren_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_paren(&r_paren_46_built)?;
        self.push(ASTType::RParen(r_paren_46_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// Comment: <Cmnt>"[^\r\n]+";
    ///
    fn comment_47(
        &mut self,
        comment_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "comment_47";
        trace!("{}", self.trace_item_stack(context));
        let comment_0 = *comment_0.token(parse_tree)?;
        let comment_47_built = CommentBuilder::default()
            .comment_0(comment_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comment(&comment_47_built)?;
        self.push(ASTType::Comment(comment_47_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// Variable: <Expr, INITIAL>"[A-Z][0-9A-Z]*";
    ///
    fn variable_48(
        &mut self,
        variable_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "variable_48";
        trace!("{}", self.trace_item_stack(context));
        let variable_0 = *variable_0.token(parse_tree)?;
        let variable_48_built = VariableBuilder::default()
            .variable_0(variable_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.variable(&variable_48_built)?;
        self.push(ASTType::Variable(variable_48_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// Expression: LogicalOr;
    ///
    fn expression_49(
        &mut self,
        _logical_or_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "expression_49";
        trace!("{}", self.trace_item_stack(context));
        let logical_or_0 = if let Some(ASTType::LogicalOr(logical_or_0)) = self.pop(context) {
            logical_or_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalOr", context));
        };
        let expression_49_built = ExpressionBuilder::default()
            .logical_or_0(Box::new(logical_or_0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression(&expression_49_built)?;
        self.push(ASTType::Expression(expression_49_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// LogicalOr: LogicalAnd LogicalOrList /* Vec */;
    ///
    fn logical_or_50(
        &mut self,
        _logical_and_0: &ParseTreeStackEntry<'t>,
        _logical_or_list_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_or_50";
        trace!("{}", self.trace_item_stack(context));
        let logical_or_list_1 =
            if let Some(ASTType::LogicalOrList(mut logical_or_list_1)) = self.pop(context) {
                logical_or_list_1.reverse();
                logical_or_list_1
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalOrList", context));
            };
        let logical_and_0 = if let Some(ASTType::LogicalAnd(logical_and_0)) = self.pop(context) {
            logical_and_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalAnd", context));
        };
        let logical_or_50_built = LogicalOrBuilder::default()
            .logical_and_0(Box::new(logical_and_0))
            .logical_or_list_1(logical_or_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_or(&logical_or_50_built)?;
        self.push(ASTType::LogicalOr(logical_or_50_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// LogicalOrList: LogicalOrOp LogicalAnd LogicalOrList; // Vec<T>::Push
    ///
    fn logical_or_list_51(
        &mut self,
        _logical_or_op_0: &ParseTreeStackEntry<'t>,
        _logical_and_1: &ParseTreeStackEntry<'t>,
        _logical_or_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_or_list_51";
        trace!("{}", self.trace_item_stack(context));
        let mut logical_or_list_2 =
            if let Some(ASTType::LogicalOrList(logical_or_list_2)) = self.pop(context) {
                logical_or_list_2
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalOrList", context));
            };
        let logical_and_1 = if let Some(ASTType::LogicalAnd(logical_and_1)) = self.pop(context) {
            logical_and_1
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalAnd", context));
        };
        let logical_or_op_0 = if let Some(ASTType::LogicalOrOp(logical_or_op_0)) = self.pop(context)
        {
            logical_or_op_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalOrOp", context));
        };
        let logical_or_list_51_built = LogicalOrListBuilder::default()
            .logical_and_1(Box::new(logical_and_1))
            .logical_or_op_0(Box::new(logical_or_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        logical_or_list_2.push(logical_or_list_51_built);
        self.push(ASTType::LogicalOrList(logical_or_list_2), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// LogicalOrList: ; // Vec<T>::New
    ///
    fn logical_or_list_52(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "logical_or_list_52";
        trace!("{}", self.trace_item_stack(context));
        let logical_or_list_52_built = Vec::new();
        self.push(ASTType::LogicalOrList(logical_or_list_52_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// LogicalAnd: LogicalNot LogicalAndList /* Vec */;
    ///
    fn logical_and_53(
        &mut self,
        _logical_not_0: &ParseTreeStackEntry<'t>,
        _logical_and_list_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_and_53";
        trace!("{}", self.trace_item_stack(context));
        let logical_and_list_1 =
            if let Some(ASTType::LogicalAndList(mut logical_and_list_1)) = self.pop(context) {
                logical_and_list_1.reverse();
                logical_and_list_1
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalAndList", context));
            };
        let logical_not_0 = if let Some(ASTType::LogicalNot(logical_not_0)) = self.pop(context) {
            logical_not_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalNot", context));
        };
        let logical_and_53_built = LogicalAndBuilder::default()
            .logical_not_0(Box::new(logical_not_0))
            .logical_and_list_1(logical_and_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_and(&logical_and_53_built)?;
        self.push(ASTType::LogicalAnd(logical_and_53_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// LogicalAndList: LogicalAndOp LogicalNot LogicalAndList; // Vec<T>::Push
    ///
    fn logical_and_list_54(
        &mut self,
        _logical_and_op_0: &ParseTreeStackEntry<'t>,
        _logical_not_1: &ParseTreeStackEntry<'t>,
        _logical_and_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_and_list_54";
        trace!("{}", self.trace_item_stack(context));
        let mut logical_and_list_2 =
            if let Some(ASTType::LogicalAndList(logical_and_list_2)) = self.pop(context) {
                logical_and_list_2
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalAndList", context));
            };
        let logical_not_1 = if let Some(ASTType::LogicalNot(logical_not_1)) = self.pop(context) {
            logical_not_1
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalNot", context));
        };
        let logical_and_op_0 =
            if let Some(ASTType::LogicalAndOp(logical_and_op_0)) = self.pop(context) {
                logical_and_op_0
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalAndOp", context));
            };
        let logical_and_list_54_built = LogicalAndListBuilder::default()
            .logical_not_1(Box::new(logical_not_1))
            .logical_and_op_0(Box::new(logical_and_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        logical_and_list_2.push(logical_and_list_54_built);
        self.push(ASTType::LogicalAndList(logical_and_list_2), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// LogicalAndList: ; // Vec<T>::New
    ///
    fn logical_and_list_55(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "logical_and_list_55";
        trace!("{}", self.trace_item_stack(context));
        let logical_and_list_55_built = Vec::new();
        self.push(ASTType::LogicalAndList(logical_and_list_55_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// LogicalNot: LogicalNotOp Relational;
    ///
    fn logical_not_56(
        &mut self,
        _logical_not_op_0: &ParseTreeStackEntry<'t>,
        _relational_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_not_56";
        trace!("{}", self.trace_item_stack(context));
        let relational_1 = if let Some(ASTType::Relational(relational_1)) = self.pop(context) {
            relational_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Relational", context));
        };
        let logical_not_op_0 =
            if let Some(ASTType::LogicalNotOp(logical_not_op_0)) = self.pop(context) {
                logical_not_op_0
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalNotOp", context));
            };
        let logical_not_56_built = LogicalNot56Builder::default()
            .logical_not_op_0(Box::new(logical_not_op_0))
            .relational_1(Box::new(relational_1))
            .build()
            .into_diagnostic()?;
        let logical_not_56_built = LogicalNot::LogicalNot56(logical_not_56_built);
        // Calling user action here
        self.user_grammar.logical_not(&logical_not_56_built)?;
        self.push(ASTType::LogicalNot(logical_not_56_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// LogicalNot: Relational;
    ///
    fn logical_not_57(
        &mut self,
        _relational_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_not_57";
        trace!("{}", self.trace_item_stack(context));
        let relational_0 = if let Some(ASTType::Relational(relational_0)) = self.pop(context) {
            relational_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Relational", context));
        };
        let logical_not_57_built = LogicalNot57Builder::default()
            .relational_0(Box::new(relational_0))
            .build()
            .into_diagnostic()?;
        let logical_not_57_built = LogicalNot::LogicalNot57(logical_not_57_built);
        // Calling user action here
        self.user_grammar.logical_not(&logical_not_57_built)?;
        self.push(ASTType::LogicalNot(logical_not_57_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// Relational: Summation RelationalList /* Vec */;
    ///
    fn relational_58(
        &mut self,
        _summation_0: &ParseTreeStackEntry<'t>,
        _relational_list_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "relational_58";
        trace!("{}", self.trace_item_stack(context));
        let relational_list_1 =
            if let Some(ASTType::RelationalList(mut relational_list_1)) = self.pop(context) {
                relational_list_1.reverse();
                relational_list_1
            } else {
                return Err(miette!("{}: Expecting ASTType::RelationalList", context));
            };
        let summation_0 = if let Some(ASTType::Summation(summation_0)) = self.pop(context) {
            summation_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Summation", context));
        };
        let relational_58_built = RelationalBuilder::default()
            .summation_0(Box::new(summation_0))
            .relational_list_1(relational_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.relational(&relational_58_built)?;
        self.push(ASTType::Relational(relational_58_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// RelationalList: RelationalOp Summation RelationalList; // Vec<T>::Push
    ///
    fn relational_list_59(
        &mut self,
        _relational_op_0: &ParseTreeStackEntry<'t>,
        _summation_1: &ParseTreeStackEntry<'t>,
        _relational_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "relational_list_59";
        trace!("{}", self.trace_item_stack(context));
        let mut relational_list_2 =
            if let Some(ASTType::RelationalList(relational_list_2)) = self.pop(context) {
                relational_list_2
            } else {
                return Err(miette!("{}: Expecting ASTType::RelationalList", context));
            };
        let summation_1 = if let Some(ASTType::Summation(summation_1)) = self.pop(context) {
            summation_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Summation", context));
        };
        let relational_op_0 =
            if let Some(ASTType::RelationalOp(relational_op_0)) = self.pop(context) {
                relational_op_0
            } else {
                return Err(miette!("{}: Expecting ASTType::RelationalOp", context));
            };
        let relational_list_59_built = RelationalListBuilder::default()
            .summation_1(Box::new(summation_1))
            .relational_op_0(Box::new(relational_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        relational_list_2.push(relational_list_59_built);
        self.push(ASTType::RelationalList(relational_list_2), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// RelationalList: ; // Vec<T>::New
    ///
    fn relational_list_60(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "relational_list_60";
        trace!("{}", self.trace_item_stack(context));
        let relational_list_60_built = Vec::new();
        self.push(ASTType::RelationalList(relational_list_60_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// Summation: Multiplication SummationList /* Vec */;
    ///
    fn summation_61(
        &mut self,
        _multiplication_0: &ParseTreeStackEntry<'t>,
        _summation_list_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "summation_61";
        trace!("{}", self.trace_item_stack(context));
        let summation_list_1 =
            if let Some(ASTType::SummationList(mut summation_list_1)) = self.pop(context) {
                summation_list_1.reverse();
                summation_list_1
            } else {
                return Err(miette!("{}: Expecting ASTType::SummationList", context));
            };
        let multiplication_0 =
            if let Some(ASTType::Multiplication(multiplication_0)) = self.pop(context) {
                multiplication_0
            } else {
                return Err(miette!("{}: Expecting ASTType::Multiplication", context));
            };
        let summation_61_built = SummationBuilder::default()
            .multiplication_0(Box::new(multiplication_0))
            .summation_list_1(summation_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.summation(&summation_61_built)?;
        self.push(ASTType::Summation(summation_61_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// SummationList: SummationListGroup Multiplication SummationList; // Vec<T>::Push
    ///
    fn summation_list_62(
        &mut self,
        _summation_list_group_0: &ParseTreeStackEntry<'t>,
        _multiplication_1: &ParseTreeStackEntry<'t>,
        _summation_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "summation_list_62";
        trace!("{}", self.trace_item_stack(context));
        let mut summation_list_2 =
            if let Some(ASTType::SummationList(summation_list_2)) = self.pop(context) {
                summation_list_2
            } else {
                return Err(miette!("{}: Expecting ASTType::SummationList", context));
            };
        let multiplication_1 =
            if let Some(ASTType::Multiplication(multiplication_1)) = self.pop(context) {
                multiplication_1
            } else {
                return Err(miette!("{}: Expecting ASTType::Multiplication", context));
            };
        let summation_list_group_0 =
            if let Some(ASTType::SummationListGroup(summation_list_group_0)) = self.pop(context) {
                summation_list_group_0
            } else {
                return Err(miette!(
                    "{}: Expecting ASTType::SummationListGroup",
                    context
                ));
            };
        let summation_list_62_built = SummationListBuilder::default()
            .multiplication_1(Box::new(multiplication_1))
            .summation_list_group_0(Box::new(summation_list_group_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        summation_list_2.push(summation_list_62_built);
        self.push(ASTType::SummationList(summation_list_2), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// SummationListGroup: Plus;
    ///
    fn summation_list_group_63(
        &mut self,
        _plus_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "summation_list_group_63";
        trace!("{}", self.trace_item_stack(context));
        let plus_0 = if let Some(ASTType::Plus(plus_0)) = self.pop(context) {
            plus_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Plus", context));
        };
        let summation_list_group_63_built = SummationListGroup63Builder::default()
            .plus_0(Box::new(plus_0))
            .build()
            .into_diagnostic()?;
        let summation_list_group_63_built =
            SummationListGroup::SummationListGroup63(summation_list_group_63_built);
        self.push(
            ASTType::SummationListGroup(summation_list_group_63_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// SummationListGroup: Minus;
    ///
    fn summation_list_group_64(
        &mut self,
        _minus_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "summation_list_group_64";
        trace!("{}", self.trace_item_stack(context));
        let minus_0 = if let Some(ASTType::Minus(minus_0)) = self.pop(context) {
            minus_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Minus", context));
        };
        let summation_list_group_64_built = SummationListGroup64Builder::default()
            .minus_0(Box::new(minus_0))
            .build()
            .into_diagnostic()?;
        let summation_list_group_64_built =
            SummationListGroup::SummationListGroup64(summation_list_group_64_built);
        self.push(
            ASTType::SummationListGroup(summation_list_group_64_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// SummationList: ; // Vec<T>::New
    ///
    fn summation_list_65(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "summation_list_65";
        trace!("{}", self.trace_item_stack(context));
        let summation_list_65_built = Vec::new();
        self.push(ASTType::SummationList(summation_list_65_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// Multiplication: Factor MultiplicationList /* Vec */;
    ///
    fn multiplication_66(
        &mut self,
        _factor_0: &ParseTreeStackEntry<'t>,
        _multiplication_list_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "multiplication_66";
        trace!("{}", self.trace_item_stack(context));
        let multiplication_list_1 =
            if let Some(ASTType::MultiplicationList(mut multiplication_list_1)) = self.pop(context)
            {
                multiplication_list_1.reverse();
                multiplication_list_1
            } else {
                return Err(miette!(
                    "{}: Expecting ASTType::MultiplicationList",
                    context
                ));
            };
        let factor_0 = if let Some(ASTType::Factor(factor_0)) = self.pop(context) {
            factor_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Factor", context));
        };
        let multiplication_66_built = MultiplicationBuilder::default()
            .factor_0(Box::new(factor_0))
            .multiplication_list_1(multiplication_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.multiplication(&multiplication_66_built)?;
        self.push(ASTType::Multiplication(multiplication_66_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// MultiplicationList: MulOp Factor MultiplicationList; // Vec<T>::Push
    ///
    fn multiplication_list_67(
        &mut self,
        _mul_op_0: &ParseTreeStackEntry<'t>,
        _factor_1: &ParseTreeStackEntry<'t>,
        _multiplication_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "multiplication_list_67";
        trace!("{}", self.trace_item_stack(context));
        let mut multiplication_list_2 =
            if let Some(ASTType::MultiplicationList(multiplication_list_2)) = self.pop(context) {
                multiplication_list_2
            } else {
                return Err(miette!(
                    "{}: Expecting ASTType::MultiplicationList",
                    context
                ));
            };
        let factor_1 = if let Some(ASTType::Factor(factor_1)) = self.pop(context) {
            factor_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Factor", context));
        };
        let mul_op_0 = if let Some(ASTType::MulOp(mul_op_0)) = self.pop(context) {
            mul_op_0
        } else {
            return Err(miette!("{}: Expecting ASTType::MulOp", context));
        };
        let multiplication_list_67_built = MultiplicationListBuilder::default()
            .factor_1(Box::new(factor_1))
            .mul_op_0(Box::new(mul_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        multiplication_list_2.push(multiplication_list_67_built);
        self.push(ASTType::MultiplicationList(multiplication_list_2), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// MultiplicationList: ; // Vec<T>::New
    ///
    fn multiplication_list_68(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "multiplication_list_68";
        trace!("{}", self.trace_item_stack(context));
        let multiplication_list_68_built = Vec::new();
        self.push(
            ASTType::MultiplicationList(multiplication_list_68_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// Factor: Literal;
    ///
    fn factor_69(
        &mut self,
        _literal_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "factor_69";
        trace!("{}", self.trace_item_stack(context));
        let literal_0 = if let Some(ASTType::Literal(literal_0)) = self.pop(context) {
            literal_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Literal", context));
        };
        let factor_69_built = Factor69Builder::default()
            .literal_0(Box::new(literal_0))
            .build()
            .into_diagnostic()?;
        let factor_69_built = Factor::Factor69(factor_69_built);
        // Calling user action here
        self.user_grammar.factor(&factor_69_built)?;
        self.push(ASTType::Factor(factor_69_built), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// Factor: Variable;
    ///
    fn factor_70(
        &mut self,
        _variable_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "factor_70";
        trace!("{}", self.trace_item_stack(context));
        let variable_0 = if let Some(ASTType::Variable(variable_0)) = self.pop(context) {
            variable_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Variable", context));
        };
        let factor_70_built = Factor70Builder::default()
            .variable_0(Box::new(variable_0))
            .build()
            .into_diagnostic()?;
        let factor_70_built = Factor::Factor70(factor_70_built);
        // Calling user action here
        self.user_grammar.factor(&factor_70_built)?;
        self.push(ASTType::Factor(factor_70_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// Factor: Minus Factor;
    ///
    fn factor_71(
        &mut self,
        _minus_0: &ParseTreeStackEntry<'t>,
        _factor_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "factor_71";
        trace!("{}", self.trace_item_stack(context));
        let factor_1 = if let Some(ASTType::Factor(factor_1)) = self.pop(context) {
            factor_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Factor", context));
        };
        let minus_0 = if let Some(ASTType::Minus(minus_0)) = self.pop(context) {
            minus_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Minus", context));
        };
        let factor_71_built = Factor71Builder::default()
            .minus_0(Box::new(minus_0))
            .factor_1(Box::new(factor_1))
            .build()
            .into_diagnostic()?;
        let factor_71_built = Factor::Factor71(factor_71_built);
        // Calling user action here
        self.user_grammar.factor(&factor_71_built)?;
        self.push(ASTType::Factor(factor_71_built), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// Factor: LParen Expression RParen;
    ///
    fn factor_72(
        &mut self,
        _l_paren_0: &ParseTreeStackEntry<'t>,
        _expression_1: &ParseTreeStackEntry<'t>,
        _r_paren_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "factor_72";
        trace!("{}", self.trace_item_stack(context));
        let r_paren_2 = if let Some(ASTType::RParen(r_paren_2)) = self.pop(context) {
            r_paren_2
        } else {
            return Err(miette!("{}: Expecting ASTType::RParen", context));
        };
        let expression_1 = if let Some(ASTType::Expression(expression_1)) = self.pop(context) {
            expression_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let l_paren_0 = if let Some(ASTType::LParen(l_paren_0)) = self.pop(context) {
            l_paren_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LParen", context));
        };
        let factor_72_built = Factor72Builder::default()
            .l_paren_0(Box::new(l_paren_0))
            .expression_1(Box::new(expression_1))
            .r_paren_2(Box::new(r_paren_2))
            .build()
            .into_diagnostic()?;
        let factor_72_built = Factor::Factor72(factor_72_built);
        // Calling user action here
        self.user_grammar.factor(&factor_72_built)?;
        self.push(ASTType::Factor(factor_72_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for BasicGrammarAuto<'t, '_> {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// Is is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, file_name: &Path) {
        self.file_name = file_name.to_owned();
        self.user_grammar.init(file_name);
    }

    ///
    /// This function is implemented automatically for the user's item BasicGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.basic_0(&children[0], &children[1], &children[2], parse_tree),
            1 => self.basic_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            2 => self.basic_suffix1_2(&children[0], parse_tree),
            3 => self.basic_suffix1_3(parse_tree),
            4 => self.basic_suffix_4(&children[0], parse_tree),
            5 => self.basic_suffix_5(parse_tree),
            6 => self.basic_list_6(&children[0], &children[1], &children[2], parse_tree),
            7 => self.basic_list_7(parse_tree),
            8 => self.line_8(&children[0], &children[1], &children[2], parse_tree),
            9 => self.line_list_9(&children[0], &children[1], &children[2], parse_tree),
            10 => self.line_list_10(parse_tree),
            11 => self.statement_11(&children[0], &children[1], parse_tree),
            12 => self.statement_suffix_12(&children[0], parse_tree),
            13 => self.statement_suffix_13(parse_tree),
            14 => self.statement_14(&children[0], &children[1], parse_tree),
            15 => self.statement_15(&children[0], &children[1], &children[2], parse_tree),
            16 => self.statement_16(&children[0], parse_tree),
            17 => self.statement_17(&children[0], parse_tree),
            18 => self.statement_18(&children[0], parse_tree),
            19 => self.assignment_19(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            20 => self.assignment_20(&children[0], &children[1], &children[2], parse_tree),
            21 => self.if_body_21(&children[0], &children[1], parse_tree),
            22 => self.if_body_22(&children[0], &children[1], parse_tree),
            23 => self.print_23(&children[0], &children[1], parse_tree),
            24 => self.print_group_24(&children[0], parse_tree),
            25 => self.print_group_25(&children[0], parse_tree),
            26 => self.stop_26(&children[0], parse_tree),
            27 => self.end_of_line_27(&children[0], parse_tree),
            28 => self.literal_28(&children[0], parse_tree),
            29 => self.line_number_29(&children[0], parse_tree),
            30 => self.number_30(&children[0], parse_tree),
            31 => self.number_31(&children[0], parse_tree),
            32 => self.float_32(&children[0], parse_tree),
            33 => self.float_33(&children[0], parse_tree),
            34 => self.float1_34(&children[0], parse_tree),
            35 => self.float2_35(&children[0], parse_tree),
            36 => self.integer_36(&children[0], parse_tree),
            37 => self.assign_op_37(&children[0], parse_tree),
            38 => self.logical_or_op_38(&children[0], parse_tree),
            39 => self.logical_and_op_39(&children[0], parse_tree),
            40 => self.logical_not_op_40(&children[0], parse_tree),
            41 => self.relational_op_41(&children[0], parse_tree),
            42 => self.plus_42(&children[0], parse_tree),
            43 => self.minus_43(&children[0], parse_tree),
            44 => self.mul_op_44(&children[0], parse_tree),
            45 => self.l_paren_45(&children[0], parse_tree),
            46 => self.r_paren_46(&children[0], parse_tree),
            47 => self.comment_47(&children[0], parse_tree),
            48 => self.variable_48(&children[0], parse_tree),
            49 => self.expression_49(&children[0], parse_tree),
            50 => self.logical_or_50(&children[0], &children[1], parse_tree),
            51 => self.logical_or_list_51(&children[0], &children[1], &children[2], parse_tree),
            52 => self.logical_or_list_52(parse_tree),
            53 => self.logical_and_53(&children[0], &children[1], parse_tree),
            54 => self.logical_and_list_54(&children[0], &children[1], &children[2], parse_tree),
            55 => self.logical_and_list_55(parse_tree),
            56 => self.logical_not_56(&children[0], &children[1], parse_tree),
            57 => self.logical_not_57(&children[0], parse_tree),
            58 => self.relational_58(&children[0], &children[1], parse_tree),
            59 => self.relational_list_59(&children[0], &children[1], &children[2], parse_tree),
            60 => self.relational_list_60(parse_tree),
            61 => self.summation_61(&children[0], &children[1], parse_tree),
            62 => self.summation_list_62(&children[0], &children[1], &children[2], parse_tree),
            63 => self.summation_list_group_63(&children[0], parse_tree),
            64 => self.summation_list_group_64(&children[0], parse_tree),
            65 => self.summation_list_65(parse_tree),
            66 => self.multiplication_66(&children[0], &children[1], parse_tree),
            67 => self.multiplication_list_67(&children[0], &children[1], &children[2], parse_tree),
            68 => self.multiplication_list_68(parse_tree),
            69 => self.factor_69(&children[0], parse_tree),
            70 => self.factor_70(&children[0], parse_tree),
            71 => self.factor_71(&children[0], &children[1], parse_tree),
            72 => self.factor_72(&children[0], &children[1], &children[2], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
