// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

#[allow(unused_imports)]
use crate::basic_grammar::BasicGrammar;
use id_tree::Tree;
use log::trace;
use miette::{miette, IntoDiagnostic, Result};
use parol_runtime::lexer::Token;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};
use std::path::{Path, PathBuf};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait BasicGrammarTrait<'t> {
    fn init(&mut self, _file_name: &Path) {}

    /// Semantic action for user production 0:
    ///
    /// Basic: [EndOfLine] Line {EndOfLine Line} [EndOfLine];
    ///
    fn basic(&mut self, _arg: &Basic<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 1:
    ///
    /// Line: LineNumber Statement {<0>":" Statement};
    ///
    fn line(&mut self, _arg: &Line<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 2:
    ///
    /// Statement: <0>"REM" %push(1) [Comment] %pop() | <0>"GOTO" LineNumber | Assignment;
    ///
    fn statement(&mut self, _arg: &Statement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 3:
    ///
    /// Assignment: Variable AssignOrEqualityOp Expression;
    ///
    fn assignment(&mut self, _arg: &Assignment<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 4:
    ///
    /// EndOfLine: <0>"(\r?\n|\r)+";
    ///
    fn end_of_line(&mut self, _arg: &EndOfLine<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 5:
    ///
    /// Literal: Number;
    ///
    fn literal(&mut self, _arg: &Literal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 6:
    ///
    /// LineNumber: Integer;
    ///
    fn line_number(&mut self, _arg: &LineNumber<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 7:
    ///
    /// Number: %push(2) Float %pop() | Integer;
    ///
    fn number(&mut self, _arg: &Number<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 8:
    ///
    /// Integer: <2, 0>"([0-9] *)+";
    ///
    fn integer(&mut self, _arg: &Integer<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 9:
    ///
    /// DecimalDot: <2>"\.";
    ///
    fn decimal_dot(&mut self, _arg: &DecimalDot<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 10:
    ///
    /// Float: [Integer] DecimalDot [Integer] [Exponent] | Integer Exponent;
    ///
    fn float(&mut self, _arg: &Float<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 11:
    ///
    /// Exponent: <2>"E *[-+]? *([0-9] *)+";
    ///
    fn exponent(&mut self, _arg: &Exponent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 12:
    ///
    /// Variable: <0>"[A-Z][0-9A-Z]*";
    ///
    fn variable(&mut self, _arg: &Variable<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 13:
    ///
    /// AssignOrEqualityOp: <0>"=";
    ///
    fn assign_or_equality_op(&mut self, _arg: &AssignOrEqualityOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 14:
    ///
    /// LogicalOrOp: <0>"N?OR";
    ///
    fn logical_or_op(&mut self, _arg: &LogicalOrOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 15:
    ///
    /// LogicalAndOp: <0>"AND";
    ///
    fn logical_and_op(&mut self, _arg: &LogicalAndOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 16:
    ///
    /// LogicalNotOp: <0>"NOT";
    ///
    fn logical_not_op(&mut self, _arg: &LogicalNotOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 17:
    ///
    /// RelationalOp: <0>"<\s*>|<\s*=|<|>\s*=|>";
    ///
    fn relational_op(&mut self, _arg: &RelationalOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 18:
    ///
    /// Plus: <0>"\+";
    ///
    fn plus(&mut self, _arg: &Plus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 19:
    ///
    /// Minus: <0>"-";
    ///
    fn minus(&mut self, _arg: &Minus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 20:
    ///
    /// MulOp: <0>"\*|/";
    ///
    fn mul_op(&mut self, _arg: &MulOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 21:
    ///
    /// LParen: <0>"\(";
    ///
    fn l_paren(&mut self, _arg: &LParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 22:
    ///
    /// RParen: <0>"\)";
    ///
    fn r_paren(&mut self, _arg: &RParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 23:
    ///
    /// Comment: <0>"[^\r\n]+";
    ///
    fn comment(&mut self, _arg: &Comment<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 24:
    ///
    /// Expression: LogicalOr;
    ///
    fn expression(&mut self, _arg: &Expression<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 25:
    ///
    /// LogicalOr: LogicalAnd {LogicalOrOp LogicalAnd};
    ///
    fn logical_or(&mut self, _arg: &LogicalOr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 26:
    ///
    /// LogicalAnd: LogicalNot {LogicalAndOp LogicalNot};
    ///
    fn logical_and(&mut self, _arg: &LogicalAnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 27:
    ///
    /// LogicalNot: [LogicalNotOp] Relational;
    ///
    fn logical_not(&mut self, _arg: &LogicalNot<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 28:
    ///
    /// Relational: Summation {(AssignOrEqualityOp | RelationalOp) Summation};
    ///
    fn relational(&mut self, _arg: &Relational<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 29:
    ///
    /// Summation: Multiplication {(Plus | Minus) Multiplication};
    ///
    fn summation(&mut self, _arg: &Summation<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 30:
    ///
    /// Multiplication: Factor {MulOp Factor};
    ///
    fn multiplication(&mut self, _arg: &Multiplication<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 31:
    ///
    /// Factor: Literal | Variable | Minus Factor | LParen Expression RParen;
    ///
    fn factor(&mut self, _arg: &Factor<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 0
///
/// Basic: Line BasicList /* Vec */ BasicSuffix1;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Basic0<'t> {
    pub line_0: Box<Line<'t>>,
    pub basic_list_1: Vec<BasicList<'t>>,
    pub basic_suffix1_2: Box<BasicSuffix1<'t>>,
}

///
/// Type derived for production 1
///
/// Basic: EndOfLine Line BasicList /* Vec */ BasicSuffix;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Basic1<'t> {
    pub end_of_line_0: Box<EndOfLine<'t>>,
    pub line_1: Box<Line<'t>>,
    pub basic_list_2: Vec<BasicList<'t>>,
    pub basic_suffix_3: Box<BasicSuffix<'t>>,
}

///
/// Type derived for production 2
///
/// BasicSuffix1: EndOfLine;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix1_2<'t> {
    pub end_of_line_0: Box<EndOfLine<'t>>,
}

///
/// Type derived for production 3
///
/// BasicSuffix1: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix1_3 {}

///
/// Type derived for production 4
///
/// BasicSuffix: EndOfLine;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix4<'t> {
    pub end_of_line_0: Box<EndOfLine<'t>>,
}

///
/// Type derived for production 5
///
/// BasicSuffix: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix5 {}

///
/// Type derived for production 11
///
/// Statement: "REM" %push(Cmnt) StatementSuffix;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement11<'t> {
    pub r_e_m_0: Token<'t>, /* REM */
    pub statement_suffix_2: Box<StatementSuffix<'t>>,
}

///
/// Type derived for production 12
///
/// StatementSuffix: Comment %pop();
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementSuffix12<'t> {
    pub comment_0: Box<Comment<'t>>,
}

///
/// Type derived for production 13
///
/// StatementSuffix: %pop();
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StatementSuffix13 {}

///
/// Type derived for production 14
///
/// Statement: "GOTO" LineNumber;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement14<'t> {
    pub g_o_t_o_0: Token<'t>, /* GOTO */
    pub line_number_1: Box<LineNumber<'t>>,
}

///
/// Type derived for production 15
///
/// Statement: Assignment;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement15<'t> {
    pub assignment_0: Box<Assignment<'t>>,
}

///
/// Type derived for production 20
///
/// Number: %push(Flt) Float %pop();
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number20<'t> {
    pub float_1: Box<Float<'t>>,
}

///
/// Type derived for production 21
///
/// Number: Integer;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number21<'t> {
    pub integer_0: Box<Integer<'t>>,
}

///
/// Type derived for production 24
///
/// Float: Integer FloatSuffix4;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Float24<'t> {
    pub integer_0: Box<Integer<'t>>,
    pub float_suffix4_1: Box<FloatSuffix4<'t>>,
}

///
/// Type derived for production 25
///
/// Float: DecimalDot FloatSuffix3;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Float25<'t> {
    pub decimal_dot_0: Box<DecimalDot<'t>>,
    pub float_suffix3_1: Box<FloatSuffix3<'t>>,
}

///
/// Type derived for production 26
///
/// FloatSuffix4: DecimalDot FloatSuffix1;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FloatSuffix4_26<'t> {
    pub decimal_dot_0: Box<DecimalDot<'t>>,
    pub float_suffix1_1: Box<FloatSuffix1<'t>>,
}

///
/// Type derived for production 27
///
/// FloatSuffix4: Exponent;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FloatSuffix4_27<'t> {
    pub exponent_0: Box<Exponent<'t>>,
}

///
/// Type derived for production 28
///
/// FloatSuffix3: Integer FloatSuffix2;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FloatSuffix3_28<'t> {
    pub integer_0: Box<Integer<'t>>,
    pub float_suffix2_1: Box<FloatSuffix2<'t>>,
}

///
/// Type derived for production 29
///
/// FloatSuffix3: Exponent;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FloatSuffix3_29<'t> {
    pub exponent_0: Box<Exponent<'t>>,
}

///
/// Type derived for production 30
///
/// FloatSuffix3: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FloatSuffix3_30 {}

///
/// Type derived for production 31
///
/// FloatSuffix2: Exponent;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FloatSuffix2_31<'t> {
    pub exponent_0: Box<Exponent<'t>>,
}

///
/// Type derived for production 32
///
/// FloatSuffix2: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FloatSuffix2_32 {}

///
/// Type derived for production 33
///
/// FloatSuffix1: Integer FloatSuffix;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FloatSuffix1_33<'t> {
    pub integer_0: Box<Integer<'t>>,
    pub float_suffix_1: Box<FloatSuffix<'t>>,
}

///
/// Type derived for production 34
///
/// FloatSuffix1: Exponent;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FloatSuffix1_34<'t> {
    pub exponent_0: Box<Exponent<'t>>,
}

///
/// Type derived for production 35
///
/// FloatSuffix1: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FloatSuffix1_35 {}

///
/// Type derived for production 36
///
/// FloatSuffix: Exponent;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FloatSuffix36<'t> {
    pub exponent_0: Box<Exponent<'t>>,
}

///
/// Type derived for production 37
///
/// FloatSuffix: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FloatSuffix37 {}

///
/// Type derived for production 58
///
/// LogicalNot: LogicalNotOp Relational;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalNot58<'t> {
    pub logical_not_op_0: Box<LogicalNotOp<'t>>,
    pub relational_1: Box<Relational<'t>>,
}

///
/// Type derived for production 59
///
/// LogicalNot: Relational;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalNot59<'t> {
    pub relational_0: Box<Relational<'t>>,
}

///
/// Type derived for production 62
///
/// RelationalListGroup: AssignOrEqualityOp;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RelationalListGroup62<'t> {
    pub assign_or_equality_op_0: Box<AssignOrEqualityOp<'t>>,
}

///
/// Type derived for production 63
///
/// RelationalListGroup: RelationalOp;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RelationalListGroup63<'t> {
    pub relational_op_0: Box<RelationalOp<'t>>,
}

///
/// Type derived for production 67
///
/// SummationListGroup: Plus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SummationListGroup67<'t> {
    pub plus_0: Box<Plus<'t>>,
}

///
/// Type derived for production 68
///
/// SummationListGroup: Minus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SummationListGroup68<'t> {
    pub minus_0: Box<Minus<'t>>,
}

///
/// Type derived for production 73
///
/// Factor: Literal;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor73<'t> {
    pub literal_0: Box<Literal<'t>>,
}

///
/// Type derived for production 74
///
/// Factor: Variable;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor74<'t> {
    pub variable_0: Box<Variable<'t>>,
}

///
/// Type derived for production 75
///
/// Factor: Minus Factor;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor75<'t> {
    pub minus_0: Box<Minus<'t>>,
    pub factor_1: Box<Factor<'t>>,
}

///
/// Type derived for production 76
///
/// Factor: LParen Expression RParen;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor76<'t> {
    pub l_paren_0: Box<LParen<'t>>,
    pub expression_1: Box<Expression<'t>>,
    pub r_paren_2: Box<RParen<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal AssignOrEqualityOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AssignOrEqualityOp<'t> {
    pub assign_or_equality_op_0: Token<'t>, /* = */
}

///
/// Type derived for non-terminal Assignment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Assignment<'t> {
    pub variable_0: Box<Variable<'t>>,
    pub assign_or_equality_op_1: Box<AssignOrEqualityOp<'t>>,
    pub expression_2: Box<Expression<'t>>,
}

///
/// Type derived for non-terminal Basic
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Basic<'t> {
    Basic0(Basic0<'t>),
    Basic1(Basic1<'t>),
}

///
/// Type derived for non-terminal BasicList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicList<'t> {
    pub end_of_line_0: Box<EndOfLine<'t>>,
    pub line_1: Box<Line<'t>>,
}

///
/// Type derived for non-terminal BasicSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BasicSuffix<'t> {
    BasicSuffix4(BasicSuffix4<'t>),
    BasicSuffix5(BasicSuffix5),
}

///
/// Type derived for non-terminal BasicSuffix1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BasicSuffix1<'t> {
    BasicSuffix1_2(BasicSuffix1_2<'t>),
    BasicSuffix1_3(BasicSuffix1_3),
}

///
/// Type derived for non-terminal Comment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Comment<'t> {
    pub comment_0: Token<'t>, /* [^\r\n]+ */
}

///
/// Type derived for non-terminal DecimalDot
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DecimalDot<'t> {
    pub decimal_dot_0: Token<'t>, /* \. */
}

///
/// Type derived for non-terminal EndOfLine
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct EndOfLine<'t> {
    pub end_of_line_0: Token<'t>, /* (\r?\n|\r)+ */
}

///
/// Type derived for non-terminal Exponent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Exponent<'t> {
    pub exponent_0: Token<'t>, /* E *[-+]? *([0-9] *)+ */
}

///
/// Type derived for non-terminal Expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression<'t> {
    pub logical_or_0: Box<LogicalOr<'t>>,
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor<'t> {
    Factor73(Factor73<'t>),
    Factor74(Factor74<'t>),
    Factor75(Factor75<'t>),
    Factor76(Factor76<'t>),
}

///
/// Type derived for non-terminal Float
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Float<'t> {
    Float24(Float24<'t>),
    Float25(Float25<'t>),
}

///
/// Type derived for non-terminal FloatSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum FloatSuffix<'t> {
    FloatSuffix36(FloatSuffix36<'t>),
    FloatSuffix37(FloatSuffix37),
}

///
/// Type derived for non-terminal FloatSuffix1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum FloatSuffix1<'t> {
    FloatSuffix1_33(FloatSuffix1_33<'t>),
    FloatSuffix1_34(FloatSuffix1_34<'t>),
    FloatSuffix1_35(FloatSuffix1_35),
}

///
/// Type derived for non-terminal FloatSuffix2
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum FloatSuffix2<'t> {
    FloatSuffix2_31(FloatSuffix2_31<'t>),
    FloatSuffix2_32(FloatSuffix2_32),
}

///
/// Type derived for non-terminal FloatSuffix3
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum FloatSuffix3<'t> {
    FloatSuffix3_28(FloatSuffix3_28<'t>),
    FloatSuffix3_29(FloatSuffix3_29<'t>),
    FloatSuffix3_30(FloatSuffix3_30),
}

///
/// Type derived for non-terminal FloatSuffix4
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum FloatSuffix4<'t> {
    FloatSuffix4_26(FloatSuffix4_26<'t>),
    FloatSuffix4_27(FloatSuffix4_27<'t>),
}

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Integer<'t> {
    pub integer_0: Token<'t>, /* ([0-9] *)+ */
}

///
/// Type derived for non-terminal LParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LParen<'t> {
    pub l_paren_0: Token<'t>, /* \( */
}

///
/// Type derived for non-terminal Line
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Line<'t> {
    pub line_number_0: Box<LineNumber<'t>>,
    pub statement_1: Box<Statement<'t>>,
    pub line_list_2: Vec<LineList<'t>>,
}

///
/// Type derived for non-terminal LineList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LineList<'t> {
    pub colon_0: Token<'t>, /* : */
    pub statement_1: Box<Statement<'t>>,
}

///
/// Type derived for non-terminal LineNumber
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LineNumber<'t> {
    pub integer_0: Box<Integer<'t>>,
}

///
/// Type derived for non-terminal Literal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Literal<'t> {
    pub number_0: Box<Number<'t>>,
}

///
/// Type derived for non-terminal LogicalAnd
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalAnd<'t> {
    pub logical_not_0: Box<LogicalNot<'t>>,
    pub logical_and_list_1: Vec<LogicalAndList<'t>>,
}

///
/// Type derived for non-terminal LogicalAndList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalAndList<'t> {
    pub logical_and_op_0: Box<LogicalAndOp<'t>>,
    pub logical_not_1: Box<LogicalNot<'t>>,
}

///
/// Type derived for non-terminal LogicalAndOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalAndOp<'t> {
    pub logical_and_op_0: Token<'t>, /* AND */
}

///
/// Type derived for non-terminal LogicalNot
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum LogicalNot<'t> {
    LogicalNot58(LogicalNot58<'t>),
    LogicalNot59(LogicalNot59<'t>),
}

///
/// Type derived for non-terminal LogicalNotOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalNotOp<'t> {
    pub logical_not_op_0: Token<'t>, /* NOT */
}

///
/// Type derived for non-terminal LogicalOr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalOr<'t> {
    pub logical_and_0: Box<LogicalAnd<'t>>,
    pub logical_or_list_1: Vec<LogicalOrList<'t>>,
}

///
/// Type derived for non-terminal LogicalOrList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalOrList<'t> {
    pub logical_or_op_0: Box<LogicalOrOp<'t>>,
    pub logical_and_1: Box<LogicalAnd<'t>>,
}

///
/// Type derived for non-terminal LogicalOrOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalOrOp<'t> {
    pub logical_or_op_0: Token<'t>, /* N?OR */
}

///
/// Type derived for non-terminal Minus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Minus<'t> {
    pub minus_0: Token<'t>, /* - */
}

///
/// Type derived for non-terminal MulOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MulOp<'t> {
    pub mul_op_0: Token<'t>, /* \*|/ */
}

///
/// Type derived for non-terminal Multiplication
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Multiplication<'t> {
    pub factor_0: Box<Factor<'t>>,
    pub multiplication_list_1: Vec<MultiplicationList<'t>>,
}

///
/// Type derived for non-terminal MultiplicationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MultiplicationList<'t> {
    pub mul_op_0: Box<MulOp<'t>>,
    pub factor_1: Box<Factor<'t>>,
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Number<'t> {
    Number20(Number20<'t>),
    Number21(Number21<'t>),
}

///
/// Type derived for non-terminal Plus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Plus<'t> {
    pub plus_0: Token<'t>, /* \+ */
}

///
/// Type derived for non-terminal RParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RParen<'t> {
    pub r_paren_0: Token<'t>, /* \) */
}

///
/// Type derived for non-terminal Relational
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relational<'t> {
    pub summation_0: Box<Summation<'t>>,
    pub relational_list_1: Vec<RelationalList<'t>>,
}

///
/// Type derived for non-terminal RelationalList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RelationalList<'t> {
    pub relational_list_group_0: Box<RelationalListGroup<'t>>,
    pub summation_1: Box<Summation<'t>>,
}

///
/// Type derived for non-terminal RelationalListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum RelationalListGroup<'t> {
    RelationalListGroup62(RelationalListGroup62<'t>),
    RelationalListGroup63(RelationalListGroup63<'t>),
}

///
/// Type derived for non-terminal RelationalOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RelationalOp<'t> {
    pub relational_op_0: Token<'t>, /* <\s*>|<\s*=|<|>\s*=|> */
}

///
/// Type derived for non-terminal Statement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Statement<'t> {
    Statement11(Statement11<'t>),
    Statement14(Statement14<'t>),
    Statement15(Statement15<'t>),
}

///
/// Type derived for non-terminal StatementSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StatementSuffix<'t> {
    StatementSuffix12(StatementSuffix12<'t>),
    StatementSuffix13(StatementSuffix13),
}

///
/// Type derived for non-terminal Summation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Summation<'t> {
    pub multiplication_0: Box<Multiplication<'t>>,
    pub summation_list_1: Vec<SummationList<'t>>,
}

///
/// Type derived for non-terminal SummationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SummationList<'t> {
    pub summation_list_group_0: Box<SummationListGroup<'t>>,
    pub multiplication_1: Box<Multiplication<'t>>,
}

///
/// Type derived for non-terminal SummationListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SummationListGroup<'t> {
    SummationListGroup67(SummationListGroup67<'t>),
    SummationListGroup68(SummationListGroup68<'t>),
}

///
/// Type derived for non-terminal Variable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Variable<'t> {
    pub variable_0: Token<'t>, /* [A-Z][0-9A-Z]* */
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    AssignOrEqualityOp(AssignOrEqualityOp<'t>),
    Assignment(Assignment<'t>),
    Basic(Basic<'t>),
    BasicList(Vec<BasicList<'t>>),
    BasicSuffix(BasicSuffix<'t>),
    BasicSuffix1(BasicSuffix1<'t>),
    Comment(Comment<'t>),
    DecimalDot(DecimalDot<'t>),
    EndOfLine(EndOfLine<'t>),
    Exponent(Exponent<'t>),
    Expression(Expression<'t>),
    Factor(Factor<'t>),
    Float(Float<'t>),
    FloatSuffix(FloatSuffix<'t>),
    FloatSuffix1(FloatSuffix1<'t>),
    FloatSuffix2(FloatSuffix2<'t>),
    FloatSuffix3(FloatSuffix3<'t>),
    FloatSuffix4(FloatSuffix4<'t>),
    Integer(Integer<'t>),
    LParen(LParen<'t>),
    Line(Line<'t>),
    LineList(Vec<LineList<'t>>),
    LineNumber(LineNumber<'t>),
    Literal(Literal<'t>),
    LogicalAnd(LogicalAnd<'t>),
    LogicalAndList(Vec<LogicalAndList<'t>>),
    LogicalAndOp(LogicalAndOp<'t>),
    LogicalNot(LogicalNot<'t>),
    LogicalNotOp(LogicalNotOp<'t>),
    LogicalOr(LogicalOr<'t>),
    LogicalOrList(Vec<LogicalOrList<'t>>),
    LogicalOrOp(LogicalOrOp<'t>),
    Minus(Minus<'t>),
    MulOp(MulOp<'t>),
    Multiplication(Multiplication<'t>),
    MultiplicationList(Vec<MultiplicationList<'t>>),
    Number(Number<'t>),
    Plus(Plus<'t>),
    RParen(RParen<'t>),
    Relational(Relational<'t>),
    RelationalList(Vec<RelationalList<'t>>),
    RelationalListGroup(RelationalListGroup<'t>),
    RelationalOp(RelationalOp<'t>),
    Statement(Statement<'t>),
    StatementSuffix(StatementSuffix<'t>),
    Summation(Summation<'t>),
    SummationList(Vec<SummationList<'t>>),
    SummationListGroup(SummationListGroup<'t>),
    Variable(Variable<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct BasicGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn BasicGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
    // Path of the input file. Used for diagnostics.
    file_name: PathBuf,
}

///
/// The `BasicGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> BasicGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn BasicGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            file_name: PathBuf::default(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// Basic: Line BasicList /* Vec */ BasicSuffix1;
    ///
    fn basic_0(
        &mut self,
        _line_0: &ParseTreeStackEntry<'t>,
        _basic_list_1: &ParseTreeStackEntry<'t>,
        _basic_suffix1_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_0";
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix1_2 =
            if let Some(ASTType::BasicSuffix1(basic_suffix1_2)) = self.pop(context) {
                basic_suffix1_2
            } else {
                return Err(miette!("{}: Expecting ASTType::BasicSuffix1", context));
            };
        let basic_list_1 = if let Some(ASTType::BasicList(mut basic_list_1)) = self.pop(context) {
            basic_list_1.reverse();
            basic_list_1
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicList", context));
        };
        let line_0 = if let Some(ASTType::Line(line_0)) = self.pop(context) {
            line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Line", context));
        };
        let basic_0_built = Basic0Builder::default()
            .line_0(Box::new(line_0))
            .basic_list_1(basic_list_1)
            .basic_suffix1_2(Box::new(basic_suffix1_2))
            .build()
            .into_diagnostic()?;
        let basic_0_built = Basic::Basic0(basic_0_built);
        // Calling user action here
        self.user_grammar.basic(&basic_0_built)?;
        self.push(ASTType::Basic(basic_0_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Basic: EndOfLine Line BasicList /* Vec */ BasicSuffix;
    ///
    fn basic_1(
        &mut self,
        _end_of_line_0: &ParseTreeStackEntry<'t>,
        _line_1: &ParseTreeStackEntry<'t>,
        _basic_list_2: &ParseTreeStackEntry<'t>,
        _basic_suffix_3: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_1";
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix_3 = if let Some(ASTType::BasicSuffix(basic_suffix_3)) = self.pop(context) {
            basic_suffix_3
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicSuffix", context));
        };
        let basic_list_2 = if let Some(ASTType::BasicList(mut basic_list_2)) = self.pop(context) {
            basic_list_2.reverse();
            basic_list_2
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicList", context));
        };
        let line_1 = if let Some(ASTType::Line(line_1)) = self.pop(context) {
            line_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Line", context));
        };
        let end_of_line_0 = if let Some(ASTType::EndOfLine(end_of_line_0)) = self.pop(context) {
            end_of_line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_1_built = Basic1Builder::default()
            .end_of_line_0(Box::new(end_of_line_0))
            .line_1(Box::new(line_1))
            .basic_list_2(basic_list_2)
            .basic_suffix_3(Box::new(basic_suffix_3))
            .build()
            .into_diagnostic()?;
        let basic_1_built = Basic::Basic1(basic_1_built);
        // Calling user action here
        self.user_grammar.basic(&basic_1_built)?;
        self.push(ASTType::Basic(basic_1_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// BasicSuffix1: EndOfLine;
    ///
    fn basic_suffix1_2(
        &mut self,
        _end_of_line_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_suffix1_2";
        trace!("{}", self.trace_item_stack(context));
        let end_of_line_0 = if let Some(ASTType::EndOfLine(end_of_line_0)) = self.pop(context) {
            end_of_line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_suffix1_2_built = BasicSuffix1_2Builder::default()
            .end_of_line_0(Box::new(end_of_line_0))
            .build()
            .into_diagnostic()?;
        let basic_suffix1_2_built = BasicSuffix1::BasicSuffix1_2(basic_suffix1_2_built);
        self.push(ASTType::BasicSuffix1(basic_suffix1_2_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// BasicSuffix1: ;
    ///
    fn basic_suffix1_3(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "basic_suffix1_3";
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix1_3_built = BasicSuffix1_3Builder::default().build().into_diagnostic()?;
        let basic_suffix1_3_built = BasicSuffix1::BasicSuffix1_3(basic_suffix1_3_built);
        self.push(ASTType::BasicSuffix1(basic_suffix1_3_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// BasicSuffix: EndOfLine;
    ///
    fn basic_suffix_4(
        &mut self,
        _end_of_line_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_suffix_4";
        trace!("{}", self.trace_item_stack(context));
        let end_of_line_0 = if let Some(ASTType::EndOfLine(end_of_line_0)) = self.pop(context) {
            end_of_line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_suffix_4_built = BasicSuffix4Builder::default()
            .end_of_line_0(Box::new(end_of_line_0))
            .build()
            .into_diagnostic()?;
        let basic_suffix_4_built = BasicSuffix::BasicSuffix4(basic_suffix_4_built);
        self.push(ASTType::BasicSuffix(basic_suffix_4_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// BasicSuffix: ;
    ///
    fn basic_suffix_5(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "basic_suffix_5";
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix_5_built = BasicSuffix5Builder::default().build().into_diagnostic()?;
        let basic_suffix_5_built = BasicSuffix::BasicSuffix5(basic_suffix_5_built);
        self.push(ASTType::BasicSuffix(basic_suffix_5_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// BasicList: EndOfLine Line BasicList; // Vec<T>::Push
    ///
    fn basic_list_6(
        &mut self,
        _end_of_line_0: &ParseTreeStackEntry<'t>,
        _line_1: &ParseTreeStackEntry<'t>,
        _basic_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_list_6";
        trace!("{}", self.trace_item_stack(context));
        let mut basic_list_2 = if let Some(ASTType::BasicList(basic_list_2)) = self.pop(context) {
            basic_list_2
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicList", context));
        };
        let line_1 = if let Some(ASTType::Line(line_1)) = self.pop(context) {
            line_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Line", context));
        };
        let end_of_line_0 = if let Some(ASTType::EndOfLine(end_of_line_0)) = self.pop(context) {
            end_of_line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_list_6_built = BasicListBuilder::default()
            .line_1(Box::new(line_1))
            .end_of_line_0(Box::new(end_of_line_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        basic_list_2.push(basic_list_6_built);
        self.push(ASTType::BasicList(basic_list_2), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// BasicList: ; // Vec<T>::New
    ///
    fn basic_list_7(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "basic_list_7";
        trace!("{}", self.trace_item_stack(context));
        let basic_list_7_built = Vec::new();
        self.push(ASTType::BasicList(basic_list_7_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// Line: LineNumber Statement LineList /* Vec */;
    ///
    fn line_8(
        &mut self,
        _line_number_0: &ParseTreeStackEntry<'t>,
        _statement_1: &ParseTreeStackEntry<'t>,
        _line_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "line_8";
        trace!("{}", self.trace_item_stack(context));
        let line_list_2 = if let Some(ASTType::LineList(mut line_list_2)) = self.pop(context) {
            line_list_2.reverse();
            line_list_2
        } else {
            return Err(miette!("{}: Expecting ASTType::LineList", context));
        };
        let statement_1 = if let Some(ASTType::Statement(statement_1)) = self.pop(context) {
            statement_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Statement", context));
        };
        let line_number_0 = if let Some(ASTType::LineNumber(line_number_0)) = self.pop(context) {
            line_number_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LineNumber", context));
        };
        let line_8_built = LineBuilder::default()
            .line_number_0(Box::new(line_number_0))
            .statement_1(Box::new(statement_1))
            .line_list_2(line_list_2)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.line(&line_8_built)?;
        self.push(ASTType::Line(line_8_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// LineList: ":" Statement LineList; // Vec<T>::Push
    ///
    fn line_list_9(
        &mut self,
        colon_0: &ParseTreeStackEntry<'t>,
        _statement_1: &ParseTreeStackEntry<'t>,
        _line_list_2: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "line_list_9";
        trace!("{}", self.trace_item_stack(context));
        let colon_0 = *colon_0.token(parse_tree)?;
        let mut line_list_2 = if let Some(ASTType::LineList(line_list_2)) = self.pop(context) {
            line_list_2
        } else {
            return Err(miette!("{}: Expecting ASTType::LineList", context));
        };
        let statement_1 = if let Some(ASTType::Statement(statement_1)) = self.pop(context) {
            statement_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Statement", context));
        };
        let line_list_9_built = LineListBuilder::default()
            .statement_1(Box::new(statement_1))
            .colon_0(colon_0)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        line_list_2.push(line_list_9_built);
        self.push(ASTType::LineList(line_list_2), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// LineList: ; // Vec<T>::New
    ///
    fn line_list_10(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "line_list_10";
        trace!("{}", self.trace_item_stack(context));
        let line_list_10_built = Vec::new();
        self.push(ASTType::LineList(line_list_10_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// Statement: "REM" %push(Cmnt) StatementSuffix;
    ///
    fn statement_11(
        &mut self,
        r_e_m_0: &ParseTreeStackEntry<'t>,
        _statement_suffix_2: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_11";
        trace!("{}", self.trace_item_stack(context));
        let r_e_m_0 = *r_e_m_0.token(parse_tree)?;
        let statement_suffix_2 =
            if let Some(ASTType::StatementSuffix(statement_suffix_2)) = self.pop(context) {
                statement_suffix_2
            } else {
                return Err(miette!("{}: Expecting ASTType::StatementSuffix", context));
            };
        let statement_11_built = Statement11Builder::default()
            .r_e_m_0(r_e_m_0)
            .statement_suffix_2(Box::new(statement_suffix_2))
            .build()
            .into_diagnostic()?;
        let statement_11_built = Statement::Statement11(statement_11_built);
        // Calling user action here
        self.user_grammar.statement(&statement_11_built)?;
        self.push(ASTType::Statement(statement_11_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// StatementSuffix: Comment %pop();
    ///
    fn statement_suffix_12(
        &mut self,
        _comment_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_suffix_12";
        trace!("{}", self.trace_item_stack(context));
        let comment_0 = if let Some(ASTType::Comment(comment_0)) = self.pop(context) {
            comment_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Comment", context));
        };
        let statement_suffix_12_built = StatementSuffix12Builder::default()
            .comment_0(Box::new(comment_0))
            .build()
            .into_diagnostic()?;
        let statement_suffix_12_built =
            StatementSuffix::StatementSuffix12(statement_suffix_12_built);
        self.push(ASTType::StatementSuffix(statement_suffix_12_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// StatementSuffix: %pop();
    ///
    fn statement_suffix_13(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "statement_suffix_13";
        trace!("{}", self.trace_item_stack(context));
        let statement_suffix_13_built = StatementSuffix13Builder::default()
            .build()
            .into_diagnostic()?;
        let statement_suffix_13_built =
            StatementSuffix::StatementSuffix13(statement_suffix_13_built);
        self.push(ASTType::StatementSuffix(statement_suffix_13_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// Statement: "GOTO" LineNumber;
    ///
    fn statement_14(
        &mut self,
        g_o_t_o_0: &ParseTreeStackEntry<'t>,
        _line_number_1: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_14";
        trace!("{}", self.trace_item_stack(context));
        let g_o_t_o_0 = *g_o_t_o_0.token(parse_tree)?;
        let line_number_1 = if let Some(ASTType::LineNumber(line_number_1)) = self.pop(context) {
            line_number_1
        } else {
            return Err(miette!("{}: Expecting ASTType::LineNumber", context));
        };
        let statement_14_built = Statement14Builder::default()
            .g_o_t_o_0(g_o_t_o_0)
            .line_number_1(Box::new(line_number_1))
            .build()
            .into_diagnostic()?;
        let statement_14_built = Statement::Statement14(statement_14_built);
        // Calling user action here
        self.user_grammar.statement(&statement_14_built)?;
        self.push(ASTType::Statement(statement_14_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// Statement: Assignment;
    ///
    fn statement_15(
        &mut self,
        _assignment_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_15";
        trace!("{}", self.trace_item_stack(context));
        let assignment_0 = if let Some(ASTType::Assignment(assignment_0)) = self.pop(context) {
            assignment_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Assignment", context));
        };
        let statement_15_built = Statement15Builder::default()
            .assignment_0(Box::new(assignment_0))
            .build()
            .into_diagnostic()?;
        let statement_15_built = Statement::Statement15(statement_15_built);
        // Calling user action here
        self.user_grammar.statement(&statement_15_built)?;
        self.push(ASTType::Statement(statement_15_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// Assignment: Variable AssignOrEqualityOp Expression;
    ///
    fn assignment_16(
        &mut self,
        _variable_0: &ParseTreeStackEntry<'t>,
        _assign_or_equality_op_1: &ParseTreeStackEntry<'t>,
        _expression_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "assignment_16";
        trace!("{}", self.trace_item_stack(context));
        let expression_2 = if let Some(ASTType::Expression(expression_2)) = self.pop(context) {
            expression_2
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let assign_or_equality_op_1 =
            if let Some(ASTType::AssignOrEqualityOp(assign_or_equality_op_1)) = self.pop(context) {
                assign_or_equality_op_1
            } else {
                return Err(miette!(
                    "{}: Expecting ASTType::AssignOrEqualityOp",
                    context
                ));
            };
        let variable_0 = if let Some(ASTType::Variable(variable_0)) = self.pop(context) {
            variable_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Variable", context));
        };
        let assignment_16_built = AssignmentBuilder::default()
            .variable_0(Box::new(variable_0))
            .assign_or_equality_op_1(Box::new(assign_or_equality_op_1))
            .expression_2(Box::new(expression_2))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.assignment(&assignment_16_built)?;
        self.push(ASTType::Assignment(assignment_16_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// EndOfLine: "(\r?\n|\r)+";
    ///
    fn end_of_line_17(
        &mut self,
        end_of_line_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "end_of_line_17";
        trace!("{}", self.trace_item_stack(context));
        let end_of_line_0 = *end_of_line_0.token(parse_tree)?;
        let end_of_line_17_built = EndOfLineBuilder::default()
            .end_of_line_0(end_of_line_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.end_of_line(&end_of_line_17_built)?;
        self.push(ASTType::EndOfLine(end_of_line_17_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// Literal: Number;
    ///
    fn literal_18(
        &mut self,
        _number_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "literal_18";
        trace!("{}", self.trace_item_stack(context));
        let number_0 = if let Some(ASTType::Number(number_0)) = self.pop(context) {
            number_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Number", context));
        };
        let literal_18_built = LiteralBuilder::default()
            .number_0(Box::new(number_0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.literal(&literal_18_built)?;
        self.push(ASTType::Literal(literal_18_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// LineNumber: Integer;
    ///
    fn line_number_19(
        &mut self,
        _integer_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "line_number_19";
        trace!("{}", self.trace_item_stack(context));
        let integer_0 = if let Some(ASTType::Integer(integer_0)) = self.pop(context) {
            integer_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Integer", context));
        };
        let line_number_19_built = LineNumberBuilder::default()
            .integer_0(Box::new(integer_0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.line_number(&line_number_19_built)?;
        self.push(ASTType::LineNumber(line_number_19_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// Number: %push(Flt) Float %pop();
    ///
    fn number_20(
        &mut self,
        _float_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "number_20";
        trace!("{}", self.trace_item_stack(context));
        let float_1 = if let Some(ASTType::Float(float_1)) = self.pop(context) {
            float_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Float", context));
        };
        let number_20_built = Number20Builder::default()
            .float_1(Box::new(float_1))
            .build()
            .into_diagnostic()?;
        let number_20_built = Number::Number20(number_20_built);
        // Calling user action here
        self.user_grammar.number(&number_20_built)?;
        self.push(ASTType::Number(number_20_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// Number: Integer;
    ///
    fn number_21(
        &mut self,
        _integer_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "number_21";
        trace!("{}", self.trace_item_stack(context));
        let integer_0 = if let Some(ASTType::Integer(integer_0)) = self.pop(context) {
            integer_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Integer", context));
        };
        let number_21_built = Number21Builder::default()
            .integer_0(Box::new(integer_0))
            .build()
            .into_diagnostic()?;
        let number_21_built = Number::Number21(number_21_built);
        // Calling user action here
        self.user_grammar.number(&number_21_built)?;
        self.push(ASTType::Number(number_21_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// Integer: <Flt, INITIAL>"([0-9] *)+";
    ///
    fn integer_22(
        &mut self,
        integer_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "integer_22";
        trace!("{}", self.trace_item_stack(context));
        let integer_0 = *integer_0.token(parse_tree)?;
        let integer_22_built = IntegerBuilder::default()
            .integer_0(integer_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.integer(&integer_22_built)?;
        self.push(ASTType::Integer(integer_22_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// DecimalDot: <Flt>"\.";
    ///
    fn decimal_dot_23(
        &mut self,
        decimal_dot_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "decimal_dot_23";
        trace!("{}", self.trace_item_stack(context));
        let decimal_dot_0 = *decimal_dot_0.token(parse_tree)?;
        let decimal_dot_23_built = DecimalDotBuilder::default()
            .decimal_dot_0(decimal_dot_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.decimal_dot(&decimal_dot_23_built)?;
        self.push(ASTType::DecimalDot(decimal_dot_23_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// Float: Integer FloatSuffix4;
    ///
    fn float_24(
        &mut self,
        _integer_0: &ParseTreeStackEntry<'t>,
        _float_suffix4_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float_24";
        trace!("{}", self.trace_item_stack(context));
        let float_suffix4_1 =
            if let Some(ASTType::FloatSuffix4(float_suffix4_1)) = self.pop(context) {
                float_suffix4_1
            } else {
                return Err(miette!("{}: Expecting ASTType::FloatSuffix4", context));
            };
        let integer_0 = if let Some(ASTType::Integer(integer_0)) = self.pop(context) {
            integer_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Integer", context));
        };
        let float_24_built = Float24Builder::default()
            .integer_0(Box::new(integer_0))
            .float_suffix4_1(Box::new(float_suffix4_1))
            .build()
            .into_diagnostic()?;
        let float_24_built = Float::Float24(float_24_built);
        // Calling user action here
        self.user_grammar.float(&float_24_built)?;
        self.push(ASTType::Float(float_24_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// Float: DecimalDot FloatSuffix3;
    ///
    fn float_25(
        &mut self,
        _decimal_dot_0: &ParseTreeStackEntry<'t>,
        _float_suffix3_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float_25";
        trace!("{}", self.trace_item_stack(context));
        let float_suffix3_1 =
            if let Some(ASTType::FloatSuffix3(float_suffix3_1)) = self.pop(context) {
                float_suffix3_1
            } else {
                return Err(miette!("{}: Expecting ASTType::FloatSuffix3", context));
            };
        let decimal_dot_0 = if let Some(ASTType::DecimalDot(decimal_dot_0)) = self.pop(context) {
            decimal_dot_0
        } else {
            return Err(miette!("{}: Expecting ASTType::DecimalDot", context));
        };
        let float_25_built = Float25Builder::default()
            .decimal_dot_0(Box::new(decimal_dot_0))
            .float_suffix3_1(Box::new(float_suffix3_1))
            .build()
            .into_diagnostic()?;
        let float_25_built = Float::Float25(float_25_built);
        // Calling user action here
        self.user_grammar.float(&float_25_built)?;
        self.push(ASTType::Float(float_25_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// FloatSuffix4: DecimalDot FloatSuffix1;
    ///
    fn float_suffix4_26(
        &mut self,
        _decimal_dot_0: &ParseTreeStackEntry<'t>,
        _float_suffix1_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float_suffix4_26";
        trace!("{}", self.trace_item_stack(context));
        let float_suffix1_1 =
            if let Some(ASTType::FloatSuffix1(float_suffix1_1)) = self.pop(context) {
                float_suffix1_1
            } else {
                return Err(miette!("{}: Expecting ASTType::FloatSuffix1", context));
            };
        let decimal_dot_0 = if let Some(ASTType::DecimalDot(decimal_dot_0)) = self.pop(context) {
            decimal_dot_0
        } else {
            return Err(miette!("{}: Expecting ASTType::DecimalDot", context));
        };
        let float_suffix4_26_built = FloatSuffix4_26Builder::default()
            .decimal_dot_0(Box::new(decimal_dot_0))
            .float_suffix1_1(Box::new(float_suffix1_1))
            .build()
            .into_diagnostic()?;
        let float_suffix4_26_built = FloatSuffix4::FloatSuffix4_26(float_suffix4_26_built);
        self.push(ASTType::FloatSuffix4(float_suffix4_26_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// FloatSuffix4: Exponent;
    ///
    fn float_suffix4_27(
        &mut self,
        _exponent_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float_suffix4_27";
        trace!("{}", self.trace_item_stack(context));
        let exponent_0 = if let Some(ASTType::Exponent(exponent_0)) = self.pop(context) {
            exponent_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Exponent", context));
        };
        let float_suffix4_27_built = FloatSuffix4_27Builder::default()
            .exponent_0(Box::new(exponent_0))
            .build()
            .into_diagnostic()?;
        let float_suffix4_27_built = FloatSuffix4::FloatSuffix4_27(float_suffix4_27_built);
        self.push(ASTType::FloatSuffix4(float_suffix4_27_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// FloatSuffix3: Integer FloatSuffix2;
    ///
    fn float_suffix3_28(
        &mut self,
        _integer_0: &ParseTreeStackEntry<'t>,
        _float_suffix2_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float_suffix3_28";
        trace!("{}", self.trace_item_stack(context));
        let float_suffix2_1 =
            if let Some(ASTType::FloatSuffix2(float_suffix2_1)) = self.pop(context) {
                float_suffix2_1
            } else {
                return Err(miette!("{}: Expecting ASTType::FloatSuffix2", context));
            };
        let integer_0 = if let Some(ASTType::Integer(integer_0)) = self.pop(context) {
            integer_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Integer", context));
        };
        let float_suffix3_28_built = FloatSuffix3_28Builder::default()
            .integer_0(Box::new(integer_0))
            .float_suffix2_1(Box::new(float_suffix2_1))
            .build()
            .into_diagnostic()?;
        let float_suffix3_28_built = FloatSuffix3::FloatSuffix3_28(float_suffix3_28_built);
        self.push(ASTType::FloatSuffix3(float_suffix3_28_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// FloatSuffix3: Exponent;
    ///
    fn float_suffix3_29(
        &mut self,
        _exponent_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float_suffix3_29";
        trace!("{}", self.trace_item_stack(context));
        let exponent_0 = if let Some(ASTType::Exponent(exponent_0)) = self.pop(context) {
            exponent_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Exponent", context));
        };
        let float_suffix3_29_built = FloatSuffix3_29Builder::default()
            .exponent_0(Box::new(exponent_0))
            .build()
            .into_diagnostic()?;
        let float_suffix3_29_built = FloatSuffix3::FloatSuffix3_29(float_suffix3_29_built);
        self.push(ASTType::FloatSuffix3(float_suffix3_29_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// FloatSuffix3: ;
    ///
    fn float_suffix3_30(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "float_suffix3_30";
        trace!("{}", self.trace_item_stack(context));
        let float_suffix3_30_built = FloatSuffix3_30Builder::default()
            .build()
            .into_diagnostic()?;
        let float_suffix3_30_built = FloatSuffix3::FloatSuffix3_30(float_suffix3_30_built);
        self.push(ASTType::FloatSuffix3(float_suffix3_30_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// FloatSuffix2: Exponent;
    ///
    fn float_suffix2_31(
        &mut self,
        _exponent_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float_suffix2_31";
        trace!("{}", self.trace_item_stack(context));
        let exponent_0 = if let Some(ASTType::Exponent(exponent_0)) = self.pop(context) {
            exponent_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Exponent", context));
        };
        let float_suffix2_31_built = FloatSuffix2_31Builder::default()
            .exponent_0(Box::new(exponent_0))
            .build()
            .into_diagnostic()?;
        let float_suffix2_31_built = FloatSuffix2::FloatSuffix2_31(float_suffix2_31_built);
        self.push(ASTType::FloatSuffix2(float_suffix2_31_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// FloatSuffix2: ;
    ///
    fn float_suffix2_32(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "float_suffix2_32";
        trace!("{}", self.trace_item_stack(context));
        let float_suffix2_32_built = FloatSuffix2_32Builder::default()
            .build()
            .into_diagnostic()?;
        let float_suffix2_32_built = FloatSuffix2::FloatSuffix2_32(float_suffix2_32_built);
        self.push(ASTType::FloatSuffix2(float_suffix2_32_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// FloatSuffix1: Integer FloatSuffix;
    ///
    fn float_suffix1_33(
        &mut self,
        _integer_0: &ParseTreeStackEntry<'t>,
        _float_suffix_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float_suffix1_33";
        trace!("{}", self.trace_item_stack(context));
        let float_suffix_1 = if let Some(ASTType::FloatSuffix(float_suffix_1)) = self.pop(context) {
            float_suffix_1
        } else {
            return Err(miette!("{}: Expecting ASTType::FloatSuffix", context));
        };
        let integer_0 = if let Some(ASTType::Integer(integer_0)) = self.pop(context) {
            integer_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Integer", context));
        };
        let float_suffix1_33_built = FloatSuffix1_33Builder::default()
            .integer_0(Box::new(integer_0))
            .float_suffix_1(Box::new(float_suffix_1))
            .build()
            .into_diagnostic()?;
        let float_suffix1_33_built = FloatSuffix1::FloatSuffix1_33(float_suffix1_33_built);
        self.push(ASTType::FloatSuffix1(float_suffix1_33_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// FloatSuffix1: Exponent;
    ///
    fn float_suffix1_34(
        &mut self,
        _exponent_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float_suffix1_34";
        trace!("{}", self.trace_item_stack(context));
        let exponent_0 = if let Some(ASTType::Exponent(exponent_0)) = self.pop(context) {
            exponent_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Exponent", context));
        };
        let float_suffix1_34_built = FloatSuffix1_34Builder::default()
            .exponent_0(Box::new(exponent_0))
            .build()
            .into_diagnostic()?;
        let float_suffix1_34_built = FloatSuffix1::FloatSuffix1_34(float_suffix1_34_built);
        self.push(ASTType::FloatSuffix1(float_suffix1_34_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// FloatSuffix1: ;
    ///
    fn float_suffix1_35(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "float_suffix1_35";
        trace!("{}", self.trace_item_stack(context));
        let float_suffix1_35_built = FloatSuffix1_35Builder::default()
            .build()
            .into_diagnostic()?;
        let float_suffix1_35_built = FloatSuffix1::FloatSuffix1_35(float_suffix1_35_built);
        self.push(ASTType::FloatSuffix1(float_suffix1_35_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// FloatSuffix: Exponent;
    ///
    fn float_suffix_36(
        &mut self,
        _exponent_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float_suffix_36";
        trace!("{}", self.trace_item_stack(context));
        let exponent_0 = if let Some(ASTType::Exponent(exponent_0)) = self.pop(context) {
            exponent_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Exponent", context));
        };
        let float_suffix_36_built = FloatSuffix36Builder::default()
            .exponent_0(Box::new(exponent_0))
            .build()
            .into_diagnostic()?;
        let float_suffix_36_built = FloatSuffix::FloatSuffix36(float_suffix_36_built);
        self.push(ASTType::FloatSuffix(float_suffix_36_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// FloatSuffix: ;
    ///
    fn float_suffix_37(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "float_suffix_37";
        trace!("{}", self.trace_item_stack(context));
        let float_suffix_37_built = FloatSuffix37Builder::default().build().into_diagnostic()?;
        let float_suffix_37_built = FloatSuffix::FloatSuffix37(float_suffix_37_built);
        self.push(ASTType::FloatSuffix(float_suffix_37_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// Exponent: <Flt>"E *[-+]? *([0-9] *)+";
    ///
    fn exponent_38(
        &mut self,
        exponent_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "exponent_38";
        trace!("{}", self.trace_item_stack(context));
        let exponent_0 = *exponent_0.token(parse_tree)?;
        let exponent_38_built = ExponentBuilder::default()
            .exponent_0(exponent_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.exponent(&exponent_38_built)?;
        self.push(ASTType::Exponent(exponent_38_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// Variable: "[A-Z][0-9A-Z]*";
    ///
    fn variable_39(
        &mut self,
        variable_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "variable_39";
        trace!("{}", self.trace_item_stack(context));
        let variable_0 = *variable_0.token(parse_tree)?;
        let variable_39_built = VariableBuilder::default()
            .variable_0(variable_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.variable(&variable_39_built)?;
        self.push(ASTType::Variable(variable_39_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// AssignOrEqualityOp: "=";
    ///
    fn assign_or_equality_op_40(
        &mut self,
        assign_or_equality_op_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "assign_or_equality_op_40";
        trace!("{}", self.trace_item_stack(context));
        let assign_or_equality_op_0 = *assign_or_equality_op_0.token(parse_tree)?;
        let assign_or_equality_op_40_built = AssignOrEqualityOpBuilder::default()
            .assign_or_equality_op_0(assign_or_equality_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .assign_or_equality_op(&assign_or_equality_op_40_built)?;
        self.push(
            ASTType::AssignOrEqualityOp(assign_or_equality_op_40_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// LogicalOrOp: "N?OR";
    ///
    fn logical_or_op_41(
        &mut self,
        logical_or_op_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_or_op_41";
        trace!("{}", self.trace_item_stack(context));
        let logical_or_op_0 = *logical_or_op_0.token(parse_tree)?;
        let logical_or_op_41_built = LogicalOrOpBuilder::default()
            .logical_or_op_0(logical_or_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_or_op(&logical_or_op_41_built)?;
        self.push(ASTType::LogicalOrOp(logical_or_op_41_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// LogicalAndOp: "AND";
    ///
    fn logical_and_op_42(
        &mut self,
        logical_and_op_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_and_op_42";
        trace!("{}", self.trace_item_stack(context));
        let logical_and_op_0 = *logical_and_op_0.token(parse_tree)?;
        let logical_and_op_42_built = LogicalAndOpBuilder::default()
            .logical_and_op_0(logical_and_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_and_op(&logical_and_op_42_built)?;
        self.push(ASTType::LogicalAndOp(logical_and_op_42_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// LogicalNotOp: "NOT";
    ///
    fn logical_not_op_43(
        &mut self,
        logical_not_op_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_not_op_43";
        trace!("{}", self.trace_item_stack(context));
        let logical_not_op_0 = *logical_not_op_0.token(parse_tree)?;
        let logical_not_op_43_built = LogicalNotOpBuilder::default()
            .logical_not_op_0(logical_not_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_not_op(&logical_not_op_43_built)?;
        self.push(ASTType::LogicalNotOp(logical_not_op_43_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// RelationalOp: "<\s*>|<\s*=|<|>\s*=|>";
    ///
    fn relational_op_44(
        &mut self,
        relational_op_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "relational_op_44";
        trace!("{}", self.trace_item_stack(context));
        let relational_op_0 = *relational_op_0.token(parse_tree)?;
        let relational_op_44_built = RelationalOpBuilder::default()
            .relational_op_0(relational_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.relational_op(&relational_op_44_built)?;
        self.push(ASTType::RelationalOp(relational_op_44_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// Plus: "\+";
    ///
    fn plus_45(
        &mut self,
        plus_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "plus_45";
        trace!("{}", self.trace_item_stack(context));
        let plus_0 = *plus_0.token(parse_tree)?;
        let plus_45_built = PlusBuilder::default()
            .plus_0(plus_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.plus(&plus_45_built)?;
        self.push(ASTType::Plus(plus_45_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// Minus: "-";
    ///
    fn minus_46(
        &mut self,
        minus_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "minus_46";
        trace!("{}", self.trace_item_stack(context));
        let minus_0 = *minus_0.token(parse_tree)?;
        let minus_46_built = MinusBuilder::default()
            .minus_0(minus_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.minus(&minus_46_built)?;
        self.push(ASTType::Minus(minus_46_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// MulOp: "\*|/";
    ///
    fn mul_op_47(
        &mut self,
        mul_op_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "mul_op_47";
        trace!("{}", self.trace_item_stack(context));
        let mul_op_0 = *mul_op_0.token(parse_tree)?;
        let mul_op_47_built = MulOpBuilder::default()
            .mul_op_0(mul_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_47_built)?;
        self.push(ASTType::MulOp(mul_op_47_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// LParen: "\(";
    ///
    fn l_paren_48(
        &mut self,
        l_paren_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "l_paren_48";
        trace!("{}", self.trace_item_stack(context));
        let l_paren_0 = *l_paren_0.token(parse_tree)?;
        let l_paren_48_built = LParenBuilder::default()
            .l_paren_0(l_paren_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_paren(&l_paren_48_built)?;
        self.push(ASTType::LParen(l_paren_48_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// RParen: "\)";
    ///
    fn r_paren_49(
        &mut self,
        r_paren_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "r_paren_49";
        trace!("{}", self.trace_item_stack(context));
        let r_paren_0 = *r_paren_0.token(parse_tree)?;
        let r_paren_49_built = RParenBuilder::default()
            .r_paren_0(r_paren_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_paren(&r_paren_49_built)?;
        self.push(ASTType::RParen(r_paren_49_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// Comment: "[^\r\n]+";
    ///
    fn comment_50(
        &mut self,
        comment_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "comment_50";
        trace!("{}", self.trace_item_stack(context));
        let comment_0 = *comment_0.token(parse_tree)?;
        let comment_50_built = CommentBuilder::default()
            .comment_0(comment_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comment(&comment_50_built)?;
        self.push(ASTType::Comment(comment_50_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// Expression: LogicalOr;
    ///
    fn expression_51(
        &mut self,
        _logical_or_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "expression_51";
        trace!("{}", self.trace_item_stack(context));
        let logical_or_0 = if let Some(ASTType::LogicalOr(logical_or_0)) = self.pop(context) {
            logical_or_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalOr", context));
        };
        let expression_51_built = ExpressionBuilder::default()
            .logical_or_0(Box::new(logical_or_0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression(&expression_51_built)?;
        self.push(ASTType::Expression(expression_51_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// LogicalOr: LogicalAnd LogicalOrList /* Vec */;
    ///
    fn logical_or_52(
        &mut self,
        _logical_and_0: &ParseTreeStackEntry<'t>,
        _logical_or_list_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_or_52";
        trace!("{}", self.trace_item_stack(context));
        let logical_or_list_1 =
            if let Some(ASTType::LogicalOrList(mut logical_or_list_1)) = self.pop(context) {
                logical_or_list_1.reverse();
                logical_or_list_1
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalOrList", context));
            };
        let logical_and_0 = if let Some(ASTType::LogicalAnd(logical_and_0)) = self.pop(context) {
            logical_and_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalAnd", context));
        };
        let logical_or_52_built = LogicalOrBuilder::default()
            .logical_and_0(Box::new(logical_and_0))
            .logical_or_list_1(logical_or_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_or(&logical_or_52_built)?;
        self.push(ASTType::LogicalOr(logical_or_52_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// LogicalOrList: LogicalOrOp LogicalAnd LogicalOrList; // Vec<T>::Push
    ///
    fn logical_or_list_53(
        &mut self,
        _logical_or_op_0: &ParseTreeStackEntry<'t>,
        _logical_and_1: &ParseTreeStackEntry<'t>,
        _logical_or_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_or_list_53";
        trace!("{}", self.trace_item_stack(context));
        let mut logical_or_list_2 =
            if let Some(ASTType::LogicalOrList(logical_or_list_2)) = self.pop(context) {
                logical_or_list_2
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalOrList", context));
            };
        let logical_and_1 = if let Some(ASTType::LogicalAnd(logical_and_1)) = self.pop(context) {
            logical_and_1
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalAnd", context));
        };
        let logical_or_op_0 = if let Some(ASTType::LogicalOrOp(logical_or_op_0)) = self.pop(context)
        {
            logical_or_op_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalOrOp", context));
        };
        let logical_or_list_53_built = LogicalOrListBuilder::default()
            .logical_and_1(Box::new(logical_and_1))
            .logical_or_op_0(Box::new(logical_or_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        logical_or_list_2.push(logical_or_list_53_built);
        self.push(ASTType::LogicalOrList(logical_or_list_2), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// LogicalOrList: ; // Vec<T>::New
    ///
    fn logical_or_list_54(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "logical_or_list_54";
        trace!("{}", self.trace_item_stack(context));
        let logical_or_list_54_built = Vec::new();
        self.push(ASTType::LogicalOrList(logical_or_list_54_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// LogicalAnd: LogicalNot LogicalAndList /* Vec */;
    ///
    fn logical_and_55(
        &mut self,
        _logical_not_0: &ParseTreeStackEntry<'t>,
        _logical_and_list_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_and_55";
        trace!("{}", self.trace_item_stack(context));
        let logical_and_list_1 =
            if let Some(ASTType::LogicalAndList(mut logical_and_list_1)) = self.pop(context) {
                logical_and_list_1.reverse();
                logical_and_list_1
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalAndList", context));
            };
        let logical_not_0 = if let Some(ASTType::LogicalNot(logical_not_0)) = self.pop(context) {
            logical_not_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalNot", context));
        };
        let logical_and_55_built = LogicalAndBuilder::default()
            .logical_not_0(Box::new(logical_not_0))
            .logical_and_list_1(logical_and_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_and(&logical_and_55_built)?;
        self.push(ASTType::LogicalAnd(logical_and_55_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// LogicalAndList: LogicalAndOp LogicalNot LogicalAndList; // Vec<T>::Push
    ///
    fn logical_and_list_56(
        &mut self,
        _logical_and_op_0: &ParseTreeStackEntry<'t>,
        _logical_not_1: &ParseTreeStackEntry<'t>,
        _logical_and_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_and_list_56";
        trace!("{}", self.trace_item_stack(context));
        let mut logical_and_list_2 =
            if let Some(ASTType::LogicalAndList(logical_and_list_2)) = self.pop(context) {
                logical_and_list_2
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalAndList", context));
            };
        let logical_not_1 = if let Some(ASTType::LogicalNot(logical_not_1)) = self.pop(context) {
            logical_not_1
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalNot", context));
        };
        let logical_and_op_0 =
            if let Some(ASTType::LogicalAndOp(logical_and_op_0)) = self.pop(context) {
                logical_and_op_0
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalAndOp", context));
            };
        let logical_and_list_56_built = LogicalAndListBuilder::default()
            .logical_not_1(Box::new(logical_not_1))
            .logical_and_op_0(Box::new(logical_and_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        logical_and_list_2.push(logical_and_list_56_built);
        self.push(ASTType::LogicalAndList(logical_and_list_2), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// LogicalAndList: ; // Vec<T>::New
    ///
    fn logical_and_list_57(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "logical_and_list_57";
        trace!("{}", self.trace_item_stack(context));
        let logical_and_list_57_built = Vec::new();
        self.push(ASTType::LogicalAndList(logical_and_list_57_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// LogicalNot: LogicalNotOp Relational;
    ///
    fn logical_not_58(
        &mut self,
        _logical_not_op_0: &ParseTreeStackEntry<'t>,
        _relational_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_not_58";
        trace!("{}", self.trace_item_stack(context));
        let relational_1 = if let Some(ASTType::Relational(relational_1)) = self.pop(context) {
            relational_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Relational", context));
        };
        let logical_not_op_0 =
            if let Some(ASTType::LogicalNotOp(logical_not_op_0)) = self.pop(context) {
                logical_not_op_0
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalNotOp", context));
            };
        let logical_not_58_built = LogicalNot58Builder::default()
            .logical_not_op_0(Box::new(logical_not_op_0))
            .relational_1(Box::new(relational_1))
            .build()
            .into_diagnostic()?;
        let logical_not_58_built = LogicalNot::LogicalNot58(logical_not_58_built);
        // Calling user action here
        self.user_grammar.logical_not(&logical_not_58_built)?;
        self.push(ASTType::LogicalNot(logical_not_58_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// LogicalNot: Relational;
    ///
    fn logical_not_59(
        &mut self,
        _relational_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_not_59";
        trace!("{}", self.trace_item_stack(context));
        let relational_0 = if let Some(ASTType::Relational(relational_0)) = self.pop(context) {
            relational_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Relational", context));
        };
        let logical_not_59_built = LogicalNot59Builder::default()
            .relational_0(Box::new(relational_0))
            .build()
            .into_diagnostic()?;
        let logical_not_59_built = LogicalNot::LogicalNot59(logical_not_59_built);
        // Calling user action here
        self.user_grammar.logical_not(&logical_not_59_built)?;
        self.push(ASTType::LogicalNot(logical_not_59_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// Relational: Summation RelationalList /* Vec */;
    ///
    fn relational_60(
        &mut self,
        _summation_0: &ParseTreeStackEntry<'t>,
        _relational_list_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "relational_60";
        trace!("{}", self.trace_item_stack(context));
        let relational_list_1 =
            if let Some(ASTType::RelationalList(mut relational_list_1)) = self.pop(context) {
                relational_list_1.reverse();
                relational_list_1
            } else {
                return Err(miette!("{}: Expecting ASTType::RelationalList", context));
            };
        let summation_0 = if let Some(ASTType::Summation(summation_0)) = self.pop(context) {
            summation_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Summation", context));
        };
        let relational_60_built = RelationalBuilder::default()
            .summation_0(Box::new(summation_0))
            .relational_list_1(relational_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.relational(&relational_60_built)?;
        self.push(ASTType::Relational(relational_60_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// RelationalList: RelationalListGroup Summation RelationalList; // Vec<T>::Push
    ///
    fn relational_list_61(
        &mut self,
        _relational_list_group_0: &ParseTreeStackEntry<'t>,
        _summation_1: &ParseTreeStackEntry<'t>,
        _relational_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "relational_list_61";
        trace!("{}", self.trace_item_stack(context));
        let mut relational_list_2 =
            if let Some(ASTType::RelationalList(relational_list_2)) = self.pop(context) {
                relational_list_2
            } else {
                return Err(miette!("{}: Expecting ASTType::RelationalList", context));
            };
        let summation_1 = if let Some(ASTType::Summation(summation_1)) = self.pop(context) {
            summation_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Summation", context));
        };
        let relational_list_group_0 = if let Some(ASTType::RelationalListGroup(
            relational_list_group_0,
        )) = self.pop(context)
        {
            relational_list_group_0
        } else {
            return Err(miette!(
                "{}: Expecting ASTType::RelationalListGroup",
                context
            ));
        };
        let relational_list_61_built = RelationalListBuilder::default()
            .summation_1(Box::new(summation_1))
            .relational_list_group_0(Box::new(relational_list_group_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        relational_list_2.push(relational_list_61_built);
        self.push(ASTType::RelationalList(relational_list_2), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// RelationalListGroup: AssignOrEqualityOp;
    ///
    fn relational_list_group_62(
        &mut self,
        _assign_or_equality_op_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "relational_list_group_62";
        trace!("{}", self.trace_item_stack(context));
        let assign_or_equality_op_0 =
            if let Some(ASTType::AssignOrEqualityOp(assign_or_equality_op_0)) = self.pop(context) {
                assign_or_equality_op_0
            } else {
                return Err(miette!(
                    "{}: Expecting ASTType::AssignOrEqualityOp",
                    context
                ));
            };
        let relational_list_group_62_built = RelationalListGroup62Builder::default()
            .assign_or_equality_op_0(Box::new(assign_or_equality_op_0))
            .build()
            .into_diagnostic()?;
        let relational_list_group_62_built =
            RelationalListGroup::RelationalListGroup62(relational_list_group_62_built);
        self.push(
            ASTType::RelationalListGroup(relational_list_group_62_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// RelationalListGroup: RelationalOp;
    ///
    fn relational_list_group_63(
        &mut self,
        _relational_op_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "relational_list_group_63";
        trace!("{}", self.trace_item_stack(context));
        let relational_op_0 =
            if let Some(ASTType::RelationalOp(relational_op_0)) = self.pop(context) {
                relational_op_0
            } else {
                return Err(miette!("{}: Expecting ASTType::RelationalOp", context));
            };
        let relational_list_group_63_built = RelationalListGroup63Builder::default()
            .relational_op_0(Box::new(relational_op_0))
            .build()
            .into_diagnostic()?;
        let relational_list_group_63_built =
            RelationalListGroup::RelationalListGroup63(relational_list_group_63_built);
        self.push(
            ASTType::RelationalListGroup(relational_list_group_63_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// RelationalList: ; // Vec<T>::New
    ///
    fn relational_list_64(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "relational_list_64";
        trace!("{}", self.trace_item_stack(context));
        let relational_list_64_built = Vec::new();
        self.push(ASTType::RelationalList(relational_list_64_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// Summation: Multiplication SummationList /* Vec */;
    ///
    fn summation_65(
        &mut self,
        _multiplication_0: &ParseTreeStackEntry<'t>,
        _summation_list_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "summation_65";
        trace!("{}", self.trace_item_stack(context));
        let summation_list_1 =
            if let Some(ASTType::SummationList(mut summation_list_1)) = self.pop(context) {
                summation_list_1.reverse();
                summation_list_1
            } else {
                return Err(miette!("{}: Expecting ASTType::SummationList", context));
            };
        let multiplication_0 =
            if let Some(ASTType::Multiplication(multiplication_0)) = self.pop(context) {
                multiplication_0
            } else {
                return Err(miette!("{}: Expecting ASTType::Multiplication", context));
            };
        let summation_65_built = SummationBuilder::default()
            .multiplication_0(Box::new(multiplication_0))
            .summation_list_1(summation_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.summation(&summation_65_built)?;
        self.push(ASTType::Summation(summation_65_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// SummationList: SummationListGroup Multiplication SummationList; // Vec<T>::Push
    ///
    fn summation_list_66(
        &mut self,
        _summation_list_group_0: &ParseTreeStackEntry<'t>,
        _multiplication_1: &ParseTreeStackEntry<'t>,
        _summation_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "summation_list_66";
        trace!("{}", self.trace_item_stack(context));
        let mut summation_list_2 =
            if let Some(ASTType::SummationList(summation_list_2)) = self.pop(context) {
                summation_list_2
            } else {
                return Err(miette!("{}: Expecting ASTType::SummationList", context));
            };
        let multiplication_1 =
            if let Some(ASTType::Multiplication(multiplication_1)) = self.pop(context) {
                multiplication_1
            } else {
                return Err(miette!("{}: Expecting ASTType::Multiplication", context));
            };
        let summation_list_group_0 =
            if let Some(ASTType::SummationListGroup(summation_list_group_0)) = self.pop(context) {
                summation_list_group_0
            } else {
                return Err(miette!(
                    "{}: Expecting ASTType::SummationListGroup",
                    context
                ));
            };
        let summation_list_66_built = SummationListBuilder::default()
            .multiplication_1(Box::new(multiplication_1))
            .summation_list_group_0(Box::new(summation_list_group_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        summation_list_2.push(summation_list_66_built);
        self.push(ASTType::SummationList(summation_list_2), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// SummationListGroup: Plus;
    ///
    fn summation_list_group_67(
        &mut self,
        _plus_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "summation_list_group_67";
        trace!("{}", self.trace_item_stack(context));
        let plus_0 = if let Some(ASTType::Plus(plus_0)) = self.pop(context) {
            plus_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Plus", context));
        };
        let summation_list_group_67_built = SummationListGroup67Builder::default()
            .plus_0(Box::new(plus_0))
            .build()
            .into_diagnostic()?;
        let summation_list_group_67_built =
            SummationListGroup::SummationListGroup67(summation_list_group_67_built);
        self.push(
            ASTType::SummationListGroup(summation_list_group_67_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// SummationListGroup: Minus;
    ///
    fn summation_list_group_68(
        &mut self,
        _minus_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "summation_list_group_68";
        trace!("{}", self.trace_item_stack(context));
        let minus_0 = if let Some(ASTType::Minus(minus_0)) = self.pop(context) {
            minus_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Minus", context));
        };
        let summation_list_group_68_built = SummationListGroup68Builder::default()
            .minus_0(Box::new(minus_0))
            .build()
            .into_diagnostic()?;
        let summation_list_group_68_built =
            SummationListGroup::SummationListGroup68(summation_list_group_68_built);
        self.push(
            ASTType::SummationListGroup(summation_list_group_68_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// SummationList: ; // Vec<T>::New
    ///
    fn summation_list_69(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "summation_list_69";
        trace!("{}", self.trace_item_stack(context));
        let summation_list_69_built = Vec::new();
        self.push(ASTType::SummationList(summation_list_69_built), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// Multiplication: Factor MultiplicationList /* Vec */;
    ///
    fn multiplication_70(
        &mut self,
        _factor_0: &ParseTreeStackEntry<'t>,
        _multiplication_list_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "multiplication_70";
        trace!("{}", self.trace_item_stack(context));
        let multiplication_list_1 =
            if let Some(ASTType::MultiplicationList(mut multiplication_list_1)) = self.pop(context)
            {
                multiplication_list_1.reverse();
                multiplication_list_1
            } else {
                return Err(miette!(
                    "{}: Expecting ASTType::MultiplicationList",
                    context
                ));
            };
        let factor_0 = if let Some(ASTType::Factor(factor_0)) = self.pop(context) {
            factor_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Factor", context));
        };
        let multiplication_70_built = MultiplicationBuilder::default()
            .factor_0(Box::new(factor_0))
            .multiplication_list_1(multiplication_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.multiplication(&multiplication_70_built)?;
        self.push(ASTType::Multiplication(multiplication_70_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// MultiplicationList: MulOp Factor MultiplicationList; // Vec<T>::Push
    ///
    fn multiplication_list_71(
        &mut self,
        _mul_op_0: &ParseTreeStackEntry<'t>,
        _factor_1: &ParseTreeStackEntry<'t>,
        _multiplication_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "multiplication_list_71";
        trace!("{}", self.trace_item_stack(context));
        let mut multiplication_list_2 =
            if let Some(ASTType::MultiplicationList(multiplication_list_2)) = self.pop(context) {
                multiplication_list_2
            } else {
                return Err(miette!(
                    "{}: Expecting ASTType::MultiplicationList",
                    context
                ));
            };
        let factor_1 = if let Some(ASTType::Factor(factor_1)) = self.pop(context) {
            factor_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Factor", context));
        };
        let mul_op_0 = if let Some(ASTType::MulOp(mul_op_0)) = self.pop(context) {
            mul_op_0
        } else {
            return Err(miette!("{}: Expecting ASTType::MulOp", context));
        };
        let multiplication_list_71_built = MultiplicationListBuilder::default()
            .factor_1(Box::new(factor_1))
            .mul_op_0(Box::new(mul_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        multiplication_list_2.push(multiplication_list_71_built);
        self.push(ASTType::MultiplicationList(multiplication_list_2), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// MultiplicationList: ; // Vec<T>::New
    ///
    fn multiplication_list_72(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "multiplication_list_72";
        trace!("{}", self.trace_item_stack(context));
        let multiplication_list_72_built = Vec::new();
        self.push(
            ASTType::MultiplicationList(multiplication_list_72_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// Factor: Literal;
    ///
    fn factor_73(
        &mut self,
        _literal_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "factor_73";
        trace!("{}", self.trace_item_stack(context));
        let literal_0 = if let Some(ASTType::Literal(literal_0)) = self.pop(context) {
            literal_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Literal", context));
        };
        let factor_73_built = Factor73Builder::default()
            .literal_0(Box::new(literal_0))
            .build()
            .into_diagnostic()?;
        let factor_73_built = Factor::Factor73(factor_73_built);
        // Calling user action here
        self.user_grammar.factor(&factor_73_built)?;
        self.push(ASTType::Factor(factor_73_built), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// Factor: Variable;
    ///
    fn factor_74(
        &mut self,
        _variable_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "factor_74";
        trace!("{}", self.trace_item_stack(context));
        let variable_0 = if let Some(ASTType::Variable(variable_0)) = self.pop(context) {
            variable_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Variable", context));
        };
        let factor_74_built = Factor74Builder::default()
            .variable_0(Box::new(variable_0))
            .build()
            .into_diagnostic()?;
        let factor_74_built = Factor::Factor74(factor_74_built);
        // Calling user action here
        self.user_grammar.factor(&factor_74_built)?;
        self.push(ASTType::Factor(factor_74_built), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// Factor: Minus Factor;
    ///
    fn factor_75(
        &mut self,
        _minus_0: &ParseTreeStackEntry<'t>,
        _factor_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "factor_75";
        trace!("{}", self.trace_item_stack(context));
        let factor_1 = if let Some(ASTType::Factor(factor_1)) = self.pop(context) {
            factor_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Factor", context));
        };
        let minus_0 = if let Some(ASTType::Minus(minus_0)) = self.pop(context) {
            minus_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Minus", context));
        };
        let factor_75_built = Factor75Builder::default()
            .minus_0(Box::new(minus_0))
            .factor_1(Box::new(factor_1))
            .build()
            .into_diagnostic()?;
        let factor_75_built = Factor::Factor75(factor_75_built);
        // Calling user action here
        self.user_grammar.factor(&factor_75_built)?;
        self.push(ASTType::Factor(factor_75_built), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// Factor: LParen Expression RParen;
    ///
    fn factor_76(
        &mut self,
        _l_paren_0: &ParseTreeStackEntry<'t>,
        _expression_1: &ParseTreeStackEntry<'t>,
        _r_paren_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "factor_76";
        trace!("{}", self.trace_item_stack(context));
        let r_paren_2 = if let Some(ASTType::RParen(r_paren_2)) = self.pop(context) {
            r_paren_2
        } else {
            return Err(miette!("{}: Expecting ASTType::RParen", context));
        };
        let expression_1 = if let Some(ASTType::Expression(expression_1)) = self.pop(context) {
            expression_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let l_paren_0 = if let Some(ASTType::LParen(l_paren_0)) = self.pop(context) {
            l_paren_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LParen", context));
        };
        let factor_76_built = Factor76Builder::default()
            .l_paren_0(Box::new(l_paren_0))
            .expression_1(Box::new(expression_1))
            .r_paren_2(Box::new(r_paren_2))
            .build()
            .into_diagnostic()?;
        let factor_76_built = Factor::Factor76(factor_76_built);
        // Calling user action here
        self.user_grammar.factor(&factor_76_built)?;
        self.push(ASTType::Factor(factor_76_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for BasicGrammarAuto<'t, '_> {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// Is is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, file_name: &Path) {
        self.file_name = file_name.to_owned();
        self.user_grammar.init(file_name);
    }

    ///
    /// This function is implemented automatically for the user's item BasicGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.basic_0(&children[0], &children[1], &children[2], parse_tree),
            1 => self.basic_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            2 => self.basic_suffix1_2(&children[0], parse_tree),
            3 => self.basic_suffix1_3(parse_tree),
            4 => self.basic_suffix_4(&children[0], parse_tree),
            5 => self.basic_suffix_5(parse_tree),
            6 => self.basic_list_6(&children[0], &children[1], &children[2], parse_tree),
            7 => self.basic_list_7(parse_tree),
            8 => self.line_8(&children[0], &children[1], &children[2], parse_tree),
            9 => self.line_list_9(&children[0], &children[1], &children[2], parse_tree),
            10 => self.line_list_10(parse_tree),
            11 => self.statement_11(&children[0], &children[1], parse_tree),
            12 => self.statement_suffix_12(&children[0], parse_tree),
            13 => self.statement_suffix_13(parse_tree),
            14 => self.statement_14(&children[0], &children[1], parse_tree),
            15 => self.statement_15(&children[0], parse_tree),
            16 => self.assignment_16(&children[0], &children[1], &children[2], parse_tree),
            17 => self.end_of_line_17(&children[0], parse_tree),
            18 => self.literal_18(&children[0], parse_tree),
            19 => self.line_number_19(&children[0], parse_tree),
            20 => self.number_20(&children[0], parse_tree),
            21 => self.number_21(&children[0], parse_tree),
            22 => self.integer_22(&children[0], parse_tree),
            23 => self.decimal_dot_23(&children[0], parse_tree),
            24 => self.float_24(&children[0], &children[1], parse_tree),
            25 => self.float_25(&children[0], &children[1], parse_tree),
            26 => self.float_suffix4_26(&children[0], &children[1], parse_tree),
            27 => self.float_suffix4_27(&children[0], parse_tree),
            28 => self.float_suffix3_28(&children[0], &children[1], parse_tree),
            29 => self.float_suffix3_29(&children[0], parse_tree),
            30 => self.float_suffix3_30(parse_tree),
            31 => self.float_suffix2_31(&children[0], parse_tree),
            32 => self.float_suffix2_32(parse_tree),
            33 => self.float_suffix1_33(&children[0], &children[1], parse_tree),
            34 => self.float_suffix1_34(&children[0], parse_tree),
            35 => self.float_suffix1_35(parse_tree),
            36 => self.float_suffix_36(&children[0], parse_tree),
            37 => self.float_suffix_37(parse_tree),
            38 => self.exponent_38(&children[0], parse_tree),
            39 => self.variable_39(&children[0], parse_tree),
            40 => self.assign_or_equality_op_40(&children[0], parse_tree),
            41 => self.logical_or_op_41(&children[0], parse_tree),
            42 => self.logical_and_op_42(&children[0], parse_tree),
            43 => self.logical_not_op_43(&children[0], parse_tree),
            44 => self.relational_op_44(&children[0], parse_tree),
            45 => self.plus_45(&children[0], parse_tree),
            46 => self.minus_46(&children[0], parse_tree),
            47 => self.mul_op_47(&children[0], parse_tree),
            48 => self.l_paren_48(&children[0], parse_tree),
            49 => self.r_paren_49(&children[0], parse_tree),
            50 => self.comment_50(&children[0], parse_tree),
            51 => self.expression_51(&children[0], parse_tree),
            52 => self.logical_or_52(&children[0], &children[1], parse_tree),
            53 => self.logical_or_list_53(&children[0], &children[1], &children[2], parse_tree),
            54 => self.logical_or_list_54(parse_tree),
            55 => self.logical_and_55(&children[0], &children[1], parse_tree),
            56 => self.logical_and_list_56(&children[0], &children[1], &children[2], parse_tree),
            57 => self.logical_and_list_57(parse_tree),
            58 => self.logical_not_58(&children[0], &children[1], parse_tree),
            59 => self.logical_not_59(&children[0], parse_tree),
            60 => self.relational_60(&children[0], &children[1], parse_tree),
            61 => self.relational_list_61(&children[0], &children[1], &children[2], parse_tree),
            62 => self.relational_list_group_62(&children[0], parse_tree),
            63 => self.relational_list_group_63(&children[0], parse_tree),
            64 => self.relational_list_64(parse_tree),
            65 => self.summation_65(&children[0], &children[1], parse_tree),
            66 => self.summation_list_66(&children[0], &children[1], &children[2], parse_tree),
            67 => self.summation_list_group_67(&children[0], parse_tree),
            68 => self.summation_list_group_68(&children[0], parse_tree),
            69 => self.summation_list_69(parse_tree),
            70 => self.multiplication_70(&children[0], &children[1], parse_tree),
            71 => self.multiplication_list_71(&children[0], &children[1], &children[2], parse_tree),
            72 => self.multiplication_list_72(parse_tree),
            73 => self.factor_73(&children[0], parse_tree),
            74 => self.factor_74(&children[0], parse_tree),
            75 => self.factor_75(&children[0], &children[1], parse_tree),
            76 => self.factor_76(&children[0], &children[1], &children[2], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
