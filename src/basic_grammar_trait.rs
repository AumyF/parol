// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

#[allow(unused_imports)]
use crate::basic_grammar::BasicGrammar;
use id_tree::Tree;
use log::trace;
use miette::{miette, IntoDiagnostic, Result};
use parol_runtime::lexer::Token;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};
use std::path::{Path, PathBuf};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait BasicGrammarTrait<'t> {
    fn init(&mut self, _file_name: &Path) {}

    /// Semantic action for user production 0:
    ///
    /// Basic: [EndOfLine] Line {EndOfLine Line} [EndOfLine];
    ///
    fn basic(&mut self, _arg: &Basic<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 1:
    ///
    /// Line: LineNumber Statement {<2, 0>":" Statement};
    ///
    fn line(&mut self, _arg: &Line<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 2:
    ///
    /// LineNumber: <0>"[0 ]*[1-9] *(?:[0-9] *){1,4}|[0 ]+";
    ///
    fn line_number(&mut self, _arg: &LineNumber<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 3:
    ///
    /// Statement: Remark | GotoStatement | IfStatement | Assignment | PrintStatement | EndStatement;
    ///
    fn statement(&mut self, _arg: &Statement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 4:
    ///
    /// Remark: <0>"REM" %push(1) [Comment] %pop();
    ///
    fn remark(&mut self, _arg: &Remark<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 5:
    ///
    /// GotoStatement: Goto LineNumber;
    ///
    fn goto_statement(&mut self, _arg: &GotoStatement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 6:
    ///
    /// IfStatement: If %push(2) Expression %pop() IfBody;
    ///
    fn if_statement(&mut self, _arg: &IfStatement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 7:
    ///
    /// Assignment: [Let] Variable AssignOp %push(2) Expression %pop();
    ///
    fn assignment(&mut self, _arg: &Assignment<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 8:
    ///
    /// IfBody: Then Statement | Goto LineNumber;
    ///
    fn if_body(&mut self, _arg: &IfBody<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 9:
    ///
    /// PrintStatement: Print %push(2) Expression {<2, 0>"," Expression} %pop();
    ///
    fn print_statement(&mut self, _arg: &PrintStatement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 10:
    ///
    /// EndStatement: End;
    ///
    fn end_statement(&mut self, _arg: &EndStatement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 11:
    ///
    /// EndOfLine: <2, 0>"(?:\r?\n|\r)+";
    ///
    fn end_of_line(&mut self, _arg: &EndOfLine<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 12:
    ///
    /// Literal: Number;
    ///
    fn literal(&mut self, _arg: &Literal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 13:
    ///
    /// Number: Float | Integer;
    ///
    fn number(&mut self, _arg: &Number<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 14:
    ///
    /// Float: Float1 | Float2;
    ///
    fn float(&mut self, _arg: &Float<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 15:
    ///
    /// Float1: <2>"(?:(?:[0-9] *)+)?\. *(?:(?:[0-9] *)+)? *(?:E *[-+]? *(?:[0-9] *)+)?";
    ///
    fn float1(&mut self, _arg: &Float1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 16:
    ///
    /// Float2: <2>"(?:[0-9] *)+E *[-+]? *(?:[0-9] *)+";
    ///
    fn float2(&mut self, _arg: &Float2<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 17:
    ///
    /// Integer: <2>"(?:[0-9] *)+";
    ///
    fn integer(&mut self, _arg: &Integer<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 18:
    ///
    /// If: <0>"IF";
    ///
    fn r#if(&mut self, _arg: &If<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 19:
    ///
    /// Then: <2, 0>"THEN";
    ///
    fn then(&mut self, _arg: &Then<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 20:
    ///
    /// Goto: <2, 0>"GOTO";
    ///
    fn goto(&mut self, _arg: &Goto<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 21:
    ///
    /// Let: <0>"LET";
    ///
    fn r#let(&mut self, _arg: &Let<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 22:
    ///
    /// Print: <0>"PRINT|\?";
    ///
    fn print(&mut self, _arg: &Print<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 23:
    ///
    /// End: <0>"END";
    ///
    fn end(&mut self, _arg: &End<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 24:
    ///
    /// AssignOp: <0>"=";
    ///
    fn assign_op(&mut self, _arg: &AssignOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 25:
    ///
    /// LogicalOrOp: <2>"N?OR";
    ///
    fn logical_or_op(&mut self, _arg: &LogicalOrOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 26:
    ///
    /// LogicalAndOp: <2>"AND";
    ///
    fn logical_and_op(&mut self, _arg: &LogicalAndOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 27:
    ///
    /// LogicalNotOp: <2>"NOT";
    ///
    fn logical_not_op(&mut self, _arg: &LogicalNotOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 28:
    ///
    /// RelationalOp: <2>"<\s*>|<\s*=|<|>\s*=|>|=";
    ///
    fn relational_op(&mut self, _arg: &RelationalOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 29:
    ///
    /// Plus: <2>"\+";
    ///
    fn plus(&mut self, _arg: &Plus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 30:
    ///
    /// Minus: <2>"-";
    ///
    fn minus(&mut self, _arg: &Minus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 31:
    ///
    /// MulOp: <2>"\*|/";
    ///
    fn mul_op(&mut self, _arg: &MulOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 32:
    ///
    /// LParen: <2>"\(";
    ///
    fn l_paren(&mut self, _arg: &LParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 33:
    ///
    /// RParen: <2>"\)";
    ///
    fn r_paren(&mut self, _arg: &RParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 34:
    ///
    /// Comment: <1>"[^\r\n]+";
    ///
    fn comment(&mut self, _arg: &Comment<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 35:
    ///
    /// Variable: <2, 0>"[A-Z][0-9A-Z]*";
    ///
    fn variable(&mut self, _arg: &Variable<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 36:
    ///
    /// Expression: LogicalOr;
    ///
    fn expression(&mut self, _arg: &Expression<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 37:
    ///
    /// LogicalOr: LogicalAnd {LogicalOrOp LogicalAnd};
    ///
    fn logical_or(&mut self, _arg: &LogicalOr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 38:
    ///
    /// LogicalAnd: LogicalNot {LogicalAndOp LogicalNot};
    ///
    fn logical_and(&mut self, _arg: &LogicalAnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 39:
    ///
    /// LogicalNot: [LogicalNotOp] Relational;
    ///
    fn logical_not(&mut self, _arg: &LogicalNot<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 40:
    ///
    /// Relational: Summation {RelationalOp Summation};
    ///
    fn relational(&mut self, _arg: &Relational<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 41:
    ///
    /// Summation: Multiplication {(Plus | Minus) Multiplication};
    ///
    fn summation(&mut self, _arg: &Summation<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 42:
    ///
    /// Multiplication: Factor {MulOp Factor};
    ///
    fn multiplication(&mut self, _arg: &Multiplication<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for user production 43:
    ///
    /// Factor: Literal | Variable | Minus Factor | LParen Expression RParen;
    ///
    fn factor(&mut self, _arg: &Factor<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 0
///
/// Basic: Line BasicList /* Vec */ BasicSuffix1;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Basic0<'t> {
    pub line_0: Box<Line<'t>>,
    pub basic_list_1: Vec<BasicList<'t>>,
    pub basic_suffix1_2: Box<BasicSuffix1<'t>>,
}

///
/// Type derived for production 1
///
/// Basic: EndOfLine Line BasicList /* Vec */ BasicSuffix;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Basic1<'t> {
    pub end_of_line_0: Box<EndOfLine<'t>>,
    pub line_1: Box<Line<'t>>,
    pub basic_list_2: Vec<BasicList<'t>>,
    pub basic_suffix_3: Box<BasicSuffix<'t>>,
}

///
/// Type derived for production 2
///
/// BasicSuffix1: EndOfLine;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix1_2<'t> {
    pub end_of_line_0: Box<EndOfLine<'t>>,
}

///
/// Type derived for production 3
///
/// BasicSuffix1: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix1_3 {}

///
/// Type derived for production 4
///
/// BasicSuffix: EndOfLine;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix4<'t> {
    pub end_of_line_0: Box<EndOfLine<'t>>,
}

///
/// Type derived for production 5
///
/// BasicSuffix: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicSuffix5 {}

///
/// Type derived for production 12
///
/// Statement: Remark;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement12<'t> {
    pub remark_0: Box<Remark<'t>>,
}

///
/// Type derived for production 13
///
/// Statement: GotoStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement13<'t> {
    pub goto_statement_0: Box<GotoStatement<'t>>,
}

///
/// Type derived for production 14
///
/// Statement: IfStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement14<'t> {
    pub if_statement_0: Box<IfStatement<'t>>,
}

///
/// Type derived for production 15
///
/// Statement: Assignment;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement15<'t> {
    pub assignment_0: Box<Assignment<'t>>,
}

///
/// Type derived for production 16
///
/// Statement: PrintStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement16<'t> {
    pub print_statement_0: Box<PrintStatement<'t>>,
}

///
/// Type derived for production 17
///
/// Statement: EndStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement17<'t> {
    pub end_statement_0: Box<EndStatement<'t>>,
}

///
/// Type derived for production 19
///
/// RemarkSuffix: Comment %pop();
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RemarkSuffix19<'t> {
    pub comment_0: Box<Comment<'t>>,
}

///
/// Type derived for production 20
///
/// RemarkSuffix: %pop();
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RemarkSuffix20 {}

///
/// Type derived for production 23
///
/// Assignment: Let Variable AssignOp %push(Expr) Expression %pop();
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Assignment23<'t> {
    pub r#let_0: Box<Let<'t>>,
    pub variable_1: Box<Variable<'t>>,
    pub assign_op_2: Box<AssignOp<'t>>,
    pub expression_4: Box<Expression<'t>>,
}

///
/// Type derived for production 24
///
/// Assignment: Variable AssignOp %push(Expr) Expression %pop();
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Assignment24<'t> {
    pub variable_0: Box<Variable<'t>>,
    pub assign_op_1: Box<AssignOp<'t>>,
    pub expression_3: Box<Expression<'t>>,
}

///
/// Type derived for production 25
///
/// IfBody: Then Statement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfBody25<'t> {
    pub then_0: Box<Then<'t>>,
    pub statement_1: Box<Statement<'t>>,
}

///
/// Type derived for production 26
///
/// IfBody: Goto LineNumber;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfBody26<'t> {
    pub goto_0: Box<Goto<'t>>,
    pub line_number_1: Box<LineNumber<'t>>,
}

///
/// Type derived for production 33
///
/// Number: Float;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number33<'t> {
    pub float_0: Box<Float<'t>>,
}

///
/// Type derived for production 34
///
/// Number: Integer;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number34<'t> {
    pub integer_0: Box<Integer<'t>>,
}

///
/// Type derived for production 35
///
/// Float: Float1;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Float35<'t> {
    pub float1_0: Box<Float1<'t>>,
}

///
/// Type derived for production 36
///
/// Float: Float2;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Float36<'t> {
    pub float2_0: Box<Float2<'t>>,
}

///
/// Type derived for production 65
///
/// LogicalNot: LogicalNotOp Relational;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalNot65<'t> {
    pub logical_not_op_0: Box<LogicalNotOp<'t>>,
    pub relational_1: Box<Relational<'t>>,
}

///
/// Type derived for production 66
///
/// LogicalNot: Relational;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalNot66<'t> {
    pub relational_0: Box<Relational<'t>>,
}

///
/// Type derived for production 72
///
/// SummationListGroup: Plus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SummationListGroup72<'t> {
    pub plus_0: Box<Plus<'t>>,
}

///
/// Type derived for production 73
///
/// SummationListGroup: Minus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SummationListGroup73<'t> {
    pub minus_0: Box<Minus<'t>>,
}

///
/// Type derived for production 78
///
/// Factor: Literal;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor78<'t> {
    pub literal_0: Box<Literal<'t>>,
}

///
/// Type derived for production 79
///
/// Factor: Variable;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor79<'t> {
    pub variable_0: Box<Variable<'t>>,
}

///
/// Type derived for production 80
///
/// Factor: Minus Factor;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor80<'t> {
    pub minus_0: Box<Minus<'t>>,
    pub factor_1: Box<Factor<'t>>,
}

///
/// Type derived for production 81
///
/// Factor: LParen Expression RParen;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor81<'t> {
    pub l_paren_0: Box<LParen<'t>>,
    pub expression_1: Box<Expression<'t>>,
    pub r_paren_2: Box<RParen<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal AssignOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AssignOp<'t> {
    pub assign_op_0: Token<'t>, /* = */
}

///
/// Type derived for non-terminal Assignment
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Assignment<'t> {
    Assignment23(Assignment23<'t>),
    Assignment24(Assignment24<'t>),
}

///
/// Type derived for non-terminal Basic
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Basic<'t> {
    Basic0(Basic0<'t>),
    Basic1(Basic1<'t>),
}

///
/// Type derived for non-terminal BasicList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasicList<'t> {
    pub end_of_line_0: Box<EndOfLine<'t>>,
    pub line_1: Box<Line<'t>>,
}

///
/// Type derived for non-terminal BasicSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BasicSuffix<'t> {
    BasicSuffix4(BasicSuffix4<'t>),
    BasicSuffix5(BasicSuffix5),
}

///
/// Type derived for non-terminal BasicSuffix1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BasicSuffix1<'t> {
    BasicSuffix1_2(BasicSuffix1_2<'t>),
    BasicSuffix1_3(BasicSuffix1_3),
}

///
/// Type derived for non-terminal Comment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Comment<'t> {
    pub comment_0: Token<'t>, /* [^\r\n]+ */
}

///
/// Type derived for non-terminal End
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct End<'t> {
    pub end_0: Token<'t>, /* END */
}

///
/// Type derived for non-terminal EndOfLine
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct EndOfLine<'t> {
    pub end_of_line_0: Token<'t>, /* (?:\r?\n|\r)+ */
}

///
/// Type derived for non-terminal EndStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct EndStatement<'t> {
    pub end_0: Box<End<'t>>,
}

///
/// Type derived for non-terminal Expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression<'t> {
    pub logical_or_0: Box<LogicalOr<'t>>,
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor<'t> {
    Factor78(Factor78<'t>),
    Factor79(Factor79<'t>),
    Factor80(Factor80<'t>),
    Factor81(Factor81<'t>),
}

///
/// Type derived for non-terminal Float
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Float<'t> {
    Float35(Float35<'t>),
    Float36(Float36<'t>),
}

///
/// Type derived for non-terminal Float1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Float1<'t> {
    pub float1_0: Token<'t>, /* (?:(?:[0-9] *)+)?\. *(?:(?:[0-9] *)+)? *(?:E *[-+]? *(?:[0-9] *)+)? */
}

///
/// Type derived for non-terminal Float2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Float2<'t> {
    pub float2_0: Token<'t>, /* (?:[0-9] *)+E *[-+]? *(?:[0-9] *)+ */
}

///
/// Type derived for non-terminal Goto
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Goto<'t> {
    pub goto_0: Token<'t>, /* GOTO */
}

///
/// Type derived for non-terminal GotoStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct GotoStatement<'t> {
    pub goto_0: Box<Goto<'t>>,
    pub line_number_1: Box<LineNumber<'t>>,
}

///
/// Type derived for non-terminal If
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct If<'t> {
    pub r#if_0: Token<'t>, /* IF */
}

///
/// Type derived for non-terminal IfBody
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IfBody<'t> {
    IfBody25(IfBody25<'t>),
    IfBody26(IfBody26<'t>),
}

///
/// Type derived for non-terminal IfStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfStatement<'t> {
    pub r#if_0: Box<If<'t>>,
    pub expression_2: Box<Expression<'t>>,
    pub if_body_4: Box<IfBody<'t>>,
}

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Integer<'t> {
    pub integer_0: Token<'t>, /* (?:[0-9] *)+ */
}

///
/// Type derived for non-terminal LParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LParen<'t> {
    pub l_paren_0: Token<'t>, /* \( */
}

///
/// Type derived for non-terminal Let
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Let<'t> {
    pub r#let_0: Token<'t>, /* LET */
}

///
/// Type derived for non-terminal Line
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Line<'t> {
    pub line_number_0: Box<LineNumber<'t>>,
    pub statement_1: Box<Statement<'t>>,
    pub line_list_2: Vec<LineList<'t>>,
}

///
/// Type derived for non-terminal LineList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LineList<'t> {
    pub colon_0: Token<'t>, /* : */
    pub statement_1: Box<Statement<'t>>,
}

///
/// Type derived for non-terminal LineNumber
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LineNumber<'t> {
    pub line_number_0: Token<'t>, /* [0 ]*[1-9] *(?:[0-9] *){1,4}|[0 ]+ */
}

///
/// Type derived for non-terminal Literal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Literal<'t> {
    pub number_0: Box<Number<'t>>,
}

///
/// Type derived for non-terminal LogicalAnd
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalAnd<'t> {
    pub logical_not_0: Box<LogicalNot<'t>>,
    pub logical_and_list_1: Vec<LogicalAndList<'t>>,
}

///
/// Type derived for non-terminal LogicalAndList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalAndList<'t> {
    pub logical_and_op_0: Box<LogicalAndOp<'t>>,
    pub logical_not_1: Box<LogicalNot<'t>>,
}

///
/// Type derived for non-terminal LogicalAndOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalAndOp<'t> {
    pub logical_and_op_0: Token<'t>, /* AND */
}

///
/// Type derived for non-terminal LogicalNot
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum LogicalNot<'t> {
    LogicalNot65(LogicalNot65<'t>),
    LogicalNot66(LogicalNot66<'t>),
}

///
/// Type derived for non-terminal LogicalNotOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalNotOp<'t> {
    pub logical_not_op_0: Token<'t>, /* NOT */
}

///
/// Type derived for non-terminal LogicalOr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalOr<'t> {
    pub logical_and_0: Box<LogicalAnd<'t>>,
    pub logical_or_list_1: Vec<LogicalOrList<'t>>,
}

///
/// Type derived for non-terminal LogicalOrList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalOrList<'t> {
    pub logical_or_op_0: Box<LogicalOrOp<'t>>,
    pub logical_and_1: Box<LogicalAnd<'t>>,
}

///
/// Type derived for non-terminal LogicalOrOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicalOrOp<'t> {
    pub logical_or_op_0: Token<'t>, /* N?OR */
}

///
/// Type derived for non-terminal Minus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Minus<'t> {
    pub minus_0: Token<'t>, /* - */
}

///
/// Type derived for non-terminal MulOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MulOp<'t> {
    pub mul_op_0: Token<'t>, /* \*|/ */
}

///
/// Type derived for non-terminal Multiplication
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Multiplication<'t> {
    pub factor_0: Box<Factor<'t>>,
    pub multiplication_list_1: Vec<MultiplicationList<'t>>,
}

///
/// Type derived for non-terminal MultiplicationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MultiplicationList<'t> {
    pub mul_op_0: Box<MulOp<'t>>,
    pub factor_1: Box<Factor<'t>>,
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Number<'t> {
    Number33(Number33<'t>),
    Number34(Number34<'t>),
}

///
/// Type derived for non-terminal Plus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Plus<'t> {
    pub plus_0: Token<'t>, /* \+ */
}

///
/// Type derived for non-terminal Print
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Print<'t> {
    pub print_0: Token<'t>, /* PRINT|\? */
}

///
/// Type derived for non-terminal PrintStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct PrintStatement<'t> {
    pub print_0: Box<Print<'t>>,
    pub expression_2: Box<Expression<'t>>,
    pub print_statement_list_3: Vec<PrintStatementList<'t>>,
}

///
/// Type derived for non-terminal PrintStatementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct PrintStatementList<'t> {
    pub comma_0: Token<'t>, /* , */
    pub expression_1: Box<Expression<'t>>,
}

///
/// Type derived for non-terminal RParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RParen<'t> {
    pub r_paren_0: Token<'t>, /* \) */
}

///
/// Type derived for non-terminal Relational
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Relational<'t> {
    pub summation_0: Box<Summation<'t>>,
    pub relational_list_1: Vec<RelationalList<'t>>,
}

///
/// Type derived for non-terminal RelationalList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RelationalList<'t> {
    pub relational_op_0: Box<RelationalOp<'t>>,
    pub summation_1: Box<Summation<'t>>,
}

///
/// Type derived for non-terminal RelationalOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RelationalOp<'t> {
    pub relational_op_0: Token<'t>, /* <\s*>|<\s*=|<|>\s*=|>|= */
}

///
/// Type derived for non-terminal Remark
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Remark<'t> {
    pub r_e_m_0: Token<'t>, /* REM */
    pub remark_suffix_2: Box<RemarkSuffix<'t>>,
}

///
/// Type derived for non-terminal RemarkSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum RemarkSuffix<'t> {
    RemarkSuffix19(RemarkSuffix19<'t>),
    RemarkSuffix20(RemarkSuffix20),
}

///
/// Type derived for non-terminal Statement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Statement<'t> {
    Statement12(Statement12<'t>),
    Statement13(Statement13<'t>),
    Statement14(Statement14<'t>),
    Statement15(Statement15<'t>),
    Statement16(Statement16<'t>),
    Statement17(Statement17<'t>),
}

///
/// Type derived for non-terminal Summation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Summation<'t> {
    pub multiplication_0: Box<Multiplication<'t>>,
    pub summation_list_1: Vec<SummationList<'t>>,
}

///
/// Type derived for non-terminal SummationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SummationList<'t> {
    pub summation_list_group_0: Box<SummationListGroup<'t>>,
    pub multiplication_1: Box<Multiplication<'t>>,
}

///
/// Type derived for non-terminal SummationListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SummationListGroup<'t> {
    SummationListGroup72(SummationListGroup72<'t>),
    SummationListGroup73(SummationListGroup73<'t>),
}

///
/// Type derived for non-terminal Then
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Then<'t> {
    pub then_0: Token<'t>, /* THEN */
}

///
/// Type derived for non-terminal Variable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Variable<'t> {
    pub variable_0: Token<'t>, /* [A-Z][0-9A-Z]* */
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    AssignOp(AssignOp<'t>),
    Assignment(Assignment<'t>),
    Basic(Basic<'t>),
    BasicList(Vec<BasicList<'t>>),
    BasicSuffix(BasicSuffix<'t>),
    BasicSuffix1(BasicSuffix1<'t>),
    Comment(Comment<'t>),
    End(End<'t>),
    EndOfLine(EndOfLine<'t>),
    EndStatement(EndStatement<'t>),
    Expression(Expression<'t>),
    Factor(Factor<'t>),
    Float(Float<'t>),
    Float1(Float1<'t>),
    Float2(Float2<'t>),
    Goto(Goto<'t>),
    GotoStatement(GotoStatement<'t>),
    If(If<'t>),
    IfBody(IfBody<'t>),
    IfStatement(IfStatement<'t>),
    Integer(Integer<'t>),
    LParen(LParen<'t>),
    Let(Let<'t>),
    Line(Line<'t>),
    LineList(Vec<LineList<'t>>),
    LineNumber(LineNumber<'t>),
    Literal(Literal<'t>),
    LogicalAnd(LogicalAnd<'t>),
    LogicalAndList(Vec<LogicalAndList<'t>>),
    LogicalAndOp(LogicalAndOp<'t>),
    LogicalNot(LogicalNot<'t>),
    LogicalNotOp(LogicalNotOp<'t>),
    LogicalOr(LogicalOr<'t>),
    LogicalOrList(Vec<LogicalOrList<'t>>),
    LogicalOrOp(LogicalOrOp<'t>),
    Minus(Minus<'t>),
    MulOp(MulOp<'t>),
    Multiplication(Multiplication<'t>),
    MultiplicationList(Vec<MultiplicationList<'t>>),
    Number(Number<'t>),
    Plus(Plus<'t>),
    Print(Print<'t>),
    PrintStatement(PrintStatement<'t>),
    PrintStatementList(Vec<PrintStatementList<'t>>),
    RParen(RParen<'t>),
    Relational(Relational<'t>),
    RelationalList(Vec<RelationalList<'t>>),
    RelationalOp(RelationalOp<'t>),
    Remark(Remark<'t>),
    RemarkSuffix(RemarkSuffix<'t>),
    Statement(Statement<'t>),
    Summation(Summation<'t>),
    SummationList(Vec<SummationList<'t>>),
    SummationListGroup(SummationListGroup<'t>),
    Then(Then<'t>),
    Variable(Variable<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct BasicGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn BasicGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
    // Path of the input file. Used for diagnostics.
    file_name: PathBuf,
}

///
/// The `BasicGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> BasicGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn BasicGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            file_name: PathBuf::default(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// Basic: Line BasicList /* Vec */ BasicSuffix1;
    ///
    fn basic_0(
        &mut self,
        _line_0: &ParseTreeStackEntry<'t>,
        _basic_list_1: &ParseTreeStackEntry<'t>,
        _basic_suffix1_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_0";
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix1_2 =
            if let Some(ASTType::BasicSuffix1(basic_suffix1_2)) = self.pop(context) {
                basic_suffix1_2
            } else {
                return Err(miette!("{}: Expecting ASTType::BasicSuffix1", context));
            };
        let basic_list_1 = if let Some(ASTType::BasicList(mut basic_list_1)) = self.pop(context) {
            basic_list_1.reverse();
            basic_list_1
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicList", context));
        };
        let line_0 = if let Some(ASTType::Line(line_0)) = self.pop(context) {
            line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Line", context));
        };
        let basic_0_built = Basic0Builder::default()
            .line_0(Box::new(line_0))
            .basic_list_1(basic_list_1)
            .basic_suffix1_2(Box::new(basic_suffix1_2))
            .build()
            .into_diagnostic()?;
        let basic_0_built = Basic::Basic0(basic_0_built);
        // Calling user action here
        self.user_grammar.basic(&basic_0_built)?;
        self.push(ASTType::Basic(basic_0_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Basic: EndOfLine Line BasicList /* Vec */ BasicSuffix;
    ///
    fn basic_1(
        &mut self,
        _end_of_line_0: &ParseTreeStackEntry<'t>,
        _line_1: &ParseTreeStackEntry<'t>,
        _basic_list_2: &ParseTreeStackEntry<'t>,
        _basic_suffix_3: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_1";
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix_3 = if let Some(ASTType::BasicSuffix(basic_suffix_3)) = self.pop(context) {
            basic_suffix_3
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicSuffix", context));
        };
        let basic_list_2 = if let Some(ASTType::BasicList(mut basic_list_2)) = self.pop(context) {
            basic_list_2.reverse();
            basic_list_2
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicList", context));
        };
        let line_1 = if let Some(ASTType::Line(line_1)) = self.pop(context) {
            line_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Line", context));
        };
        let end_of_line_0 = if let Some(ASTType::EndOfLine(end_of_line_0)) = self.pop(context) {
            end_of_line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_1_built = Basic1Builder::default()
            .end_of_line_0(Box::new(end_of_line_0))
            .line_1(Box::new(line_1))
            .basic_list_2(basic_list_2)
            .basic_suffix_3(Box::new(basic_suffix_3))
            .build()
            .into_diagnostic()?;
        let basic_1_built = Basic::Basic1(basic_1_built);
        // Calling user action here
        self.user_grammar.basic(&basic_1_built)?;
        self.push(ASTType::Basic(basic_1_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// BasicSuffix1: EndOfLine;
    ///
    fn basic_suffix1_2(
        &mut self,
        _end_of_line_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_suffix1_2";
        trace!("{}", self.trace_item_stack(context));
        let end_of_line_0 = if let Some(ASTType::EndOfLine(end_of_line_0)) = self.pop(context) {
            end_of_line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_suffix1_2_built = BasicSuffix1_2Builder::default()
            .end_of_line_0(Box::new(end_of_line_0))
            .build()
            .into_diagnostic()?;
        let basic_suffix1_2_built = BasicSuffix1::BasicSuffix1_2(basic_suffix1_2_built);
        self.push(ASTType::BasicSuffix1(basic_suffix1_2_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// BasicSuffix1: ;
    ///
    fn basic_suffix1_3(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "basic_suffix1_3";
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix1_3_built = BasicSuffix1_3Builder::default().build().into_diagnostic()?;
        let basic_suffix1_3_built = BasicSuffix1::BasicSuffix1_3(basic_suffix1_3_built);
        self.push(ASTType::BasicSuffix1(basic_suffix1_3_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// BasicSuffix: EndOfLine;
    ///
    fn basic_suffix_4(
        &mut self,
        _end_of_line_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_suffix_4";
        trace!("{}", self.trace_item_stack(context));
        let end_of_line_0 = if let Some(ASTType::EndOfLine(end_of_line_0)) = self.pop(context) {
            end_of_line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_suffix_4_built = BasicSuffix4Builder::default()
            .end_of_line_0(Box::new(end_of_line_0))
            .build()
            .into_diagnostic()?;
        let basic_suffix_4_built = BasicSuffix::BasicSuffix4(basic_suffix_4_built);
        self.push(ASTType::BasicSuffix(basic_suffix_4_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// BasicSuffix: ;
    ///
    fn basic_suffix_5(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "basic_suffix_5";
        trace!("{}", self.trace_item_stack(context));
        let basic_suffix_5_built = BasicSuffix5Builder::default().build().into_diagnostic()?;
        let basic_suffix_5_built = BasicSuffix::BasicSuffix5(basic_suffix_5_built);
        self.push(ASTType::BasicSuffix(basic_suffix_5_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// BasicList: EndOfLine Line BasicList; // Vec<T>::Push
    ///
    fn basic_list_6(
        &mut self,
        _end_of_line_0: &ParseTreeStackEntry<'t>,
        _line_1: &ParseTreeStackEntry<'t>,
        _basic_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "basic_list_6";
        trace!("{}", self.trace_item_stack(context));
        let mut basic_list_2 = if let Some(ASTType::BasicList(basic_list_2)) = self.pop(context) {
            basic_list_2
        } else {
            return Err(miette!("{}: Expecting ASTType::BasicList", context));
        };
        let line_1 = if let Some(ASTType::Line(line_1)) = self.pop(context) {
            line_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Line", context));
        };
        let end_of_line_0 = if let Some(ASTType::EndOfLine(end_of_line_0)) = self.pop(context) {
            end_of_line_0
        } else {
            return Err(miette!("{}: Expecting ASTType::EndOfLine", context));
        };
        let basic_list_6_built = BasicListBuilder::default()
            .line_1(Box::new(line_1))
            .end_of_line_0(Box::new(end_of_line_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        basic_list_2.push(basic_list_6_built);
        self.push(ASTType::BasicList(basic_list_2), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// BasicList: ; // Vec<T>::New
    ///
    fn basic_list_7(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "basic_list_7";
        trace!("{}", self.trace_item_stack(context));
        let basic_list_7_built = Vec::new();
        self.push(ASTType::BasicList(basic_list_7_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// Line: LineNumber Statement LineList /* Vec */;
    ///
    fn line_8(
        &mut self,
        _line_number_0: &ParseTreeStackEntry<'t>,
        _statement_1: &ParseTreeStackEntry<'t>,
        _line_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "line_8";
        trace!("{}", self.trace_item_stack(context));
        let line_list_2 = if let Some(ASTType::LineList(mut line_list_2)) = self.pop(context) {
            line_list_2.reverse();
            line_list_2
        } else {
            return Err(miette!("{}: Expecting ASTType::LineList", context));
        };
        let statement_1 = if let Some(ASTType::Statement(statement_1)) = self.pop(context) {
            statement_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Statement", context));
        };
        let line_number_0 = if let Some(ASTType::LineNumber(line_number_0)) = self.pop(context) {
            line_number_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LineNumber", context));
        };
        let line_8_built = LineBuilder::default()
            .line_number_0(Box::new(line_number_0))
            .statement_1(Box::new(statement_1))
            .line_list_2(line_list_2)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.line(&line_8_built)?;
        self.push(ASTType::Line(line_8_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// LineList: <Expr, INITIAL>":" Statement LineList; // Vec<T>::Push
    ///
    fn line_list_9(
        &mut self,
        colon_0: &ParseTreeStackEntry<'t>,
        _statement_1: &ParseTreeStackEntry<'t>,
        _line_list_2: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "line_list_9";
        trace!("{}", self.trace_item_stack(context));
        let colon_0 = *colon_0.token(parse_tree)?;
        let mut line_list_2 = if let Some(ASTType::LineList(line_list_2)) = self.pop(context) {
            line_list_2
        } else {
            return Err(miette!("{}: Expecting ASTType::LineList", context));
        };
        let statement_1 = if let Some(ASTType::Statement(statement_1)) = self.pop(context) {
            statement_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Statement", context));
        };
        let line_list_9_built = LineListBuilder::default()
            .statement_1(Box::new(statement_1))
            .colon_0(colon_0)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        line_list_2.push(line_list_9_built);
        self.push(ASTType::LineList(line_list_2), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// LineList: ; // Vec<T>::New
    ///
    fn line_list_10(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "line_list_10";
        trace!("{}", self.trace_item_stack(context));
        let line_list_10_built = Vec::new();
        self.push(ASTType::LineList(line_list_10_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// LineNumber: "[0 ]*[1-9] *(?:[0-9] *){1,4}|[0 ]+";
    ///
    fn line_number_11(
        &mut self,
        line_number_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "line_number_11";
        trace!("{}", self.trace_item_stack(context));
        let line_number_0 = *line_number_0.token(parse_tree)?;
        let line_number_11_built = LineNumberBuilder::default()
            .line_number_0(line_number_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.line_number(&line_number_11_built)?;
        self.push(ASTType::LineNumber(line_number_11_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// Statement: Remark;
    ///
    fn statement_12(
        &mut self,
        _remark_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_12";
        trace!("{}", self.trace_item_stack(context));
        let remark_0 = if let Some(ASTType::Remark(remark_0)) = self.pop(context) {
            remark_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Remark", context));
        };
        let statement_12_built = Statement12Builder::default()
            .remark_0(Box::new(remark_0))
            .build()
            .into_diagnostic()?;
        let statement_12_built = Statement::Statement12(statement_12_built);
        // Calling user action here
        self.user_grammar.statement(&statement_12_built)?;
        self.push(ASTType::Statement(statement_12_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// Statement: GotoStatement;
    ///
    fn statement_13(
        &mut self,
        _goto_statement_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_13";
        trace!("{}", self.trace_item_stack(context));
        let goto_statement_0 =
            if let Some(ASTType::GotoStatement(goto_statement_0)) = self.pop(context) {
                goto_statement_0
            } else {
                return Err(miette!("{}: Expecting ASTType::GotoStatement", context));
            };
        let statement_13_built = Statement13Builder::default()
            .goto_statement_0(Box::new(goto_statement_0))
            .build()
            .into_diagnostic()?;
        let statement_13_built = Statement::Statement13(statement_13_built);
        // Calling user action here
        self.user_grammar.statement(&statement_13_built)?;
        self.push(ASTType::Statement(statement_13_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// Statement: IfStatement;
    ///
    fn statement_14(
        &mut self,
        _if_statement_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_14";
        trace!("{}", self.trace_item_stack(context));
        let if_statement_0 = if let Some(ASTType::IfStatement(if_statement_0)) = self.pop(context) {
            if_statement_0
        } else {
            return Err(miette!("{}: Expecting ASTType::IfStatement", context));
        };
        let statement_14_built = Statement14Builder::default()
            .if_statement_0(Box::new(if_statement_0))
            .build()
            .into_diagnostic()?;
        let statement_14_built = Statement::Statement14(statement_14_built);
        // Calling user action here
        self.user_grammar.statement(&statement_14_built)?;
        self.push(ASTType::Statement(statement_14_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// Statement: Assignment;
    ///
    fn statement_15(
        &mut self,
        _assignment_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_15";
        trace!("{}", self.trace_item_stack(context));
        let assignment_0 = if let Some(ASTType::Assignment(assignment_0)) = self.pop(context) {
            assignment_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Assignment", context));
        };
        let statement_15_built = Statement15Builder::default()
            .assignment_0(Box::new(assignment_0))
            .build()
            .into_diagnostic()?;
        let statement_15_built = Statement::Statement15(statement_15_built);
        // Calling user action here
        self.user_grammar.statement(&statement_15_built)?;
        self.push(ASTType::Statement(statement_15_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// Statement: PrintStatement;
    ///
    fn statement_16(
        &mut self,
        _print_statement_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_16";
        trace!("{}", self.trace_item_stack(context));
        let print_statement_0 =
            if let Some(ASTType::PrintStatement(print_statement_0)) = self.pop(context) {
                print_statement_0
            } else {
                return Err(miette!("{}: Expecting ASTType::PrintStatement", context));
            };
        let statement_16_built = Statement16Builder::default()
            .print_statement_0(Box::new(print_statement_0))
            .build()
            .into_diagnostic()?;
        let statement_16_built = Statement::Statement16(statement_16_built);
        // Calling user action here
        self.user_grammar.statement(&statement_16_built)?;
        self.push(ASTType::Statement(statement_16_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// Statement: EndStatement;
    ///
    fn statement_17(
        &mut self,
        _end_statement_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "statement_17";
        trace!("{}", self.trace_item_stack(context));
        let end_statement_0 =
            if let Some(ASTType::EndStatement(end_statement_0)) = self.pop(context) {
                end_statement_0
            } else {
                return Err(miette!("{}: Expecting ASTType::EndStatement", context));
            };
        let statement_17_built = Statement17Builder::default()
            .end_statement_0(Box::new(end_statement_0))
            .build()
            .into_diagnostic()?;
        let statement_17_built = Statement::Statement17(statement_17_built);
        // Calling user action here
        self.user_grammar.statement(&statement_17_built)?;
        self.push(ASTType::Statement(statement_17_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// Remark: "REM" %push(Cmnt) RemarkSuffix;
    ///
    fn remark_18(
        &mut self,
        r_e_m_0: &ParseTreeStackEntry<'t>,
        _remark_suffix_2: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "remark_18";
        trace!("{}", self.trace_item_stack(context));
        let r_e_m_0 = *r_e_m_0.token(parse_tree)?;
        let remark_suffix_2 =
            if let Some(ASTType::RemarkSuffix(remark_suffix_2)) = self.pop(context) {
                remark_suffix_2
            } else {
                return Err(miette!("{}: Expecting ASTType::RemarkSuffix", context));
            };
        let remark_18_built = RemarkBuilder::default()
            .r_e_m_0(r_e_m_0)
            .remark_suffix_2(Box::new(remark_suffix_2))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.remark(&remark_18_built)?;
        self.push(ASTType::Remark(remark_18_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// RemarkSuffix: Comment %pop();
    ///
    fn remark_suffix_19(
        &mut self,
        _comment_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "remark_suffix_19";
        trace!("{}", self.trace_item_stack(context));
        let comment_0 = if let Some(ASTType::Comment(comment_0)) = self.pop(context) {
            comment_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Comment", context));
        };
        let remark_suffix_19_built = RemarkSuffix19Builder::default()
            .comment_0(Box::new(comment_0))
            .build()
            .into_diagnostic()?;
        let remark_suffix_19_built = RemarkSuffix::RemarkSuffix19(remark_suffix_19_built);
        self.push(ASTType::RemarkSuffix(remark_suffix_19_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// RemarkSuffix: %pop();
    ///
    fn remark_suffix_20(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "remark_suffix_20";
        trace!("{}", self.trace_item_stack(context));
        let remark_suffix_20_built = RemarkSuffix20Builder::default().build().into_diagnostic()?;
        let remark_suffix_20_built = RemarkSuffix::RemarkSuffix20(remark_suffix_20_built);
        self.push(ASTType::RemarkSuffix(remark_suffix_20_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// GotoStatement: Goto LineNumber;
    ///
    fn goto_statement_21(
        &mut self,
        _goto_0: &ParseTreeStackEntry<'t>,
        _line_number_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "goto_statement_21";
        trace!("{}", self.trace_item_stack(context));
        let line_number_1 = if let Some(ASTType::LineNumber(line_number_1)) = self.pop(context) {
            line_number_1
        } else {
            return Err(miette!("{}: Expecting ASTType::LineNumber", context));
        };
        let goto_0 = if let Some(ASTType::Goto(goto_0)) = self.pop(context) {
            goto_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Goto", context));
        };
        let goto_statement_21_built = GotoStatementBuilder::default()
            .goto_0(Box::new(goto_0))
            .line_number_1(Box::new(line_number_1))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.goto_statement(&goto_statement_21_built)?;
        self.push(ASTType::GotoStatement(goto_statement_21_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// IfStatement: If %push(Expr) Expression %pop() IfBody;
    ///
    fn if_statement_22(
        &mut self,
        _if_0: &ParseTreeStackEntry<'t>,
        _expression_2: &ParseTreeStackEntry<'t>,
        _if_body_4: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "if_statement_22";
        trace!("{}", self.trace_item_stack(context));
        let if_body_4 = if let Some(ASTType::IfBody(if_body_4)) = self.pop(context) {
            if_body_4
        } else {
            return Err(miette!("{}: Expecting ASTType::IfBody", context));
        };
        let expression_2 = if let Some(ASTType::Expression(expression_2)) = self.pop(context) {
            expression_2
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let r#if_0 = if let Some(ASTType::If(r#if_0)) = self.pop(context) {
            r#if_0
        } else {
            return Err(miette!("{}: Expecting ASTType::If", context));
        };
        let if_statement_22_built = IfStatementBuilder::default()
            .r#if_0(Box::new(r#if_0))
            .expression_2(Box::new(expression_2))
            .if_body_4(Box::new(if_body_4))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.if_statement(&if_statement_22_built)?;
        self.push(ASTType::IfStatement(if_statement_22_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// Assignment: Let Variable AssignOp %push(Expr) Expression %pop();
    ///
    fn assignment_23(
        &mut self,
        _let_0: &ParseTreeStackEntry<'t>,
        _variable_1: &ParseTreeStackEntry<'t>,
        _assign_op_2: &ParseTreeStackEntry<'t>,
        _expression_4: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "assignment_23";
        trace!("{}", self.trace_item_stack(context));
        let expression_4 = if let Some(ASTType::Expression(expression_4)) = self.pop(context) {
            expression_4
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let assign_op_2 = if let Some(ASTType::AssignOp(assign_op_2)) = self.pop(context) {
            assign_op_2
        } else {
            return Err(miette!("{}: Expecting ASTType::AssignOp", context));
        };
        let variable_1 = if let Some(ASTType::Variable(variable_1)) = self.pop(context) {
            variable_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Variable", context));
        };
        let r#let_0 = if let Some(ASTType::Let(r#let_0)) = self.pop(context) {
            r#let_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Let", context));
        };
        let assignment_23_built = Assignment23Builder::default()
            .r#let_0(Box::new(r#let_0))
            .variable_1(Box::new(variable_1))
            .assign_op_2(Box::new(assign_op_2))
            .expression_4(Box::new(expression_4))
            .build()
            .into_diagnostic()?;
        let assignment_23_built = Assignment::Assignment23(assignment_23_built);
        // Calling user action here
        self.user_grammar.assignment(&assignment_23_built)?;
        self.push(ASTType::Assignment(assignment_23_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// Assignment: Variable AssignOp %push(Expr) Expression %pop();
    ///
    fn assignment_24(
        &mut self,
        _variable_0: &ParseTreeStackEntry<'t>,
        _assign_op_1: &ParseTreeStackEntry<'t>,
        _expression_3: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "assignment_24";
        trace!("{}", self.trace_item_stack(context));
        let expression_3 = if let Some(ASTType::Expression(expression_3)) = self.pop(context) {
            expression_3
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let assign_op_1 = if let Some(ASTType::AssignOp(assign_op_1)) = self.pop(context) {
            assign_op_1
        } else {
            return Err(miette!("{}: Expecting ASTType::AssignOp", context));
        };
        let variable_0 = if let Some(ASTType::Variable(variable_0)) = self.pop(context) {
            variable_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Variable", context));
        };
        let assignment_24_built = Assignment24Builder::default()
            .variable_0(Box::new(variable_0))
            .assign_op_1(Box::new(assign_op_1))
            .expression_3(Box::new(expression_3))
            .build()
            .into_diagnostic()?;
        let assignment_24_built = Assignment::Assignment24(assignment_24_built);
        // Calling user action here
        self.user_grammar.assignment(&assignment_24_built)?;
        self.push(ASTType::Assignment(assignment_24_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// IfBody: Then Statement;
    ///
    fn if_body_25(
        &mut self,
        _then_0: &ParseTreeStackEntry<'t>,
        _statement_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "if_body_25";
        trace!("{}", self.trace_item_stack(context));
        let statement_1 = if let Some(ASTType::Statement(statement_1)) = self.pop(context) {
            statement_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Statement", context));
        };
        let then_0 = if let Some(ASTType::Then(then_0)) = self.pop(context) {
            then_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Then", context));
        };
        let if_body_25_built = IfBody25Builder::default()
            .then_0(Box::new(then_0))
            .statement_1(Box::new(statement_1))
            .build()
            .into_diagnostic()?;
        let if_body_25_built = IfBody::IfBody25(if_body_25_built);
        // Calling user action here
        self.user_grammar.if_body(&if_body_25_built)?;
        self.push(ASTType::IfBody(if_body_25_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// IfBody: Goto LineNumber;
    ///
    fn if_body_26(
        &mut self,
        _goto_0: &ParseTreeStackEntry<'t>,
        _line_number_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "if_body_26";
        trace!("{}", self.trace_item_stack(context));
        let line_number_1 = if let Some(ASTType::LineNumber(line_number_1)) = self.pop(context) {
            line_number_1
        } else {
            return Err(miette!("{}: Expecting ASTType::LineNumber", context));
        };
        let goto_0 = if let Some(ASTType::Goto(goto_0)) = self.pop(context) {
            goto_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Goto", context));
        };
        let if_body_26_built = IfBody26Builder::default()
            .goto_0(Box::new(goto_0))
            .line_number_1(Box::new(line_number_1))
            .build()
            .into_diagnostic()?;
        let if_body_26_built = IfBody::IfBody26(if_body_26_built);
        // Calling user action here
        self.user_grammar.if_body(&if_body_26_built)?;
        self.push(ASTType::IfBody(if_body_26_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// PrintStatement: Print %push(Expr) Expression PrintStatementList /* Vec */ %pop();
    ///
    fn print_statement_27(
        &mut self,
        _print_0: &ParseTreeStackEntry<'t>,
        _expression_2: &ParseTreeStackEntry<'t>,
        _print_statement_list_3: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "print_statement_27";
        trace!("{}", self.trace_item_stack(context));
        let print_statement_list_3 = if let Some(ASTType::PrintStatementList(
            mut print_statement_list_3,
        )) = self.pop(context)
        {
            print_statement_list_3.reverse();
            print_statement_list_3
        } else {
            return Err(miette!(
                "{}: Expecting ASTType::PrintStatementList",
                context
            ));
        };
        let expression_2 = if let Some(ASTType::Expression(expression_2)) = self.pop(context) {
            expression_2
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let print_0 = if let Some(ASTType::Print(print_0)) = self.pop(context) {
            print_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Print", context));
        };
        let print_statement_27_built = PrintStatementBuilder::default()
            .print_0(Box::new(print_0))
            .expression_2(Box::new(expression_2))
            .print_statement_list_3(print_statement_list_3)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .print_statement(&print_statement_27_built)?;
        self.push(ASTType::PrintStatement(print_statement_27_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// PrintStatementList: <Expr, INITIAL>"," Expression PrintStatementList; // Vec<T>::Push
    ///
    fn print_statement_list_28(
        &mut self,
        comma_0: &ParseTreeStackEntry<'t>,
        _expression_1: &ParseTreeStackEntry<'t>,
        _print_statement_list_2: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "print_statement_list_28";
        trace!("{}", self.trace_item_stack(context));
        let comma_0 = *comma_0.token(parse_tree)?;
        let mut print_statement_list_2 =
            if let Some(ASTType::PrintStatementList(print_statement_list_2)) = self.pop(context) {
                print_statement_list_2
            } else {
                return Err(miette!(
                    "{}: Expecting ASTType::PrintStatementList",
                    context
                ));
            };
        let expression_1 = if let Some(ASTType::Expression(expression_1)) = self.pop(context) {
            expression_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let print_statement_list_28_built = PrintStatementListBuilder::default()
            .expression_1(Box::new(expression_1))
            .comma_0(comma_0)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        print_statement_list_2.push(print_statement_list_28_built);
        self.push(ASTType::PrintStatementList(print_statement_list_2), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// PrintStatementList: ; // Vec<T>::New
    ///
    fn print_statement_list_29(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "print_statement_list_29";
        trace!("{}", self.trace_item_stack(context));
        let print_statement_list_29_built = Vec::new();
        self.push(
            ASTType::PrintStatementList(print_statement_list_29_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// EndStatement: End;
    ///
    fn end_statement_30(
        &mut self,
        _end_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "end_statement_30";
        trace!("{}", self.trace_item_stack(context));
        let end_0 = if let Some(ASTType::End(end_0)) = self.pop(context) {
            end_0
        } else {
            return Err(miette!("{}: Expecting ASTType::End", context));
        };
        let end_statement_30_built = EndStatementBuilder::default()
            .end_0(Box::new(end_0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.end_statement(&end_statement_30_built)?;
        self.push(ASTType::EndStatement(end_statement_30_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// EndOfLine: <Expr, INITIAL>"(?:\r?\n|\r)+";
    ///
    fn end_of_line_31(
        &mut self,
        end_of_line_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "end_of_line_31";
        trace!("{}", self.trace_item_stack(context));
        let end_of_line_0 = *end_of_line_0.token(parse_tree)?;
        let end_of_line_31_built = EndOfLineBuilder::default()
            .end_of_line_0(end_of_line_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.end_of_line(&end_of_line_31_built)?;
        self.push(ASTType::EndOfLine(end_of_line_31_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// Literal: Number;
    ///
    fn literal_32(
        &mut self,
        _number_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "literal_32";
        trace!("{}", self.trace_item_stack(context));
        let number_0 = if let Some(ASTType::Number(number_0)) = self.pop(context) {
            number_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Number", context));
        };
        let literal_32_built = LiteralBuilder::default()
            .number_0(Box::new(number_0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.literal(&literal_32_built)?;
        self.push(ASTType::Literal(literal_32_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// Number: Float;
    ///
    fn number_33(
        &mut self,
        _float_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "number_33";
        trace!("{}", self.trace_item_stack(context));
        let float_0 = if let Some(ASTType::Float(float_0)) = self.pop(context) {
            float_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Float", context));
        };
        let number_33_built = Number33Builder::default()
            .float_0(Box::new(float_0))
            .build()
            .into_diagnostic()?;
        let number_33_built = Number::Number33(number_33_built);
        // Calling user action here
        self.user_grammar.number(&number_33_built)?;
        self.push(ASTType::Number(number_33_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// Number: Integer;
    ///
    fn number_34(
        &mut self,
        _integer_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "number_34";
        trace!("{}", self.trace_item_stack(context));
        let integer_0 = if let Some(ASTType::Integer(integer_0)) = self.pop(context) {
            integer_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Integer", context));
        };
        let number_34_built = Number34Builder::default()
            .integer_0(Box::new(integer_0))
            .build()
            .into_diagnostic()?;
        let number_34_built = Number::Number34(number_34_built);
        // Calling user action here
        self.user_grammar.number(&number_34_built)?;
        self.push(ASTType::Number(number_34_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// Float: Float1;
    ///
    fn float_35(
        &mut self,
        _float1_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float_35";
        trace!("{}", self.trace_item_stack(context));
        let float1_0 = if let Some(ASTType::Float1(float1_0)) = self.pop(context) {
            float1_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Float1", context));
        };
        let float_35_built = Float35Builder::default()
            .float1_0(Box::new(float1_0))
            .build()
            .into_diagnostic()?;
        let float_35_built = Float::Float35(float_35_built);
        // Calling user action here
        self.user_grammar.float(&float_35_built)?;
        self.push(ASTType::Float(float_35_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// Float: Float2;
    ///
    fn float_36(
        &mut self,
        _float2_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float_36";
        trace!("{}", self.trace_item_stack(context));
        let float2_0 = if let Some(ASTType::Float2(float2_0)) = self.pop(context) {
            float2_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Float2", context));
        };
        let float_36_built = Float36Builder::default()
            .float2_0(Box::new(float2_0))
            .build()
            .into_diagnostic()?;
        let float_36_built = Float::Float36(float_36_built);
        // Calling user action here
        self.user_grammar.float(&float_36_built)?;
        self.push(ASTType::Float(float_36_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// Float1: <Expr>"(?:(?:[0-9] *)+)?\. *(?:(?:[0-9] *)+)? *(?:E *[-+]? *(?:[0-9] *)+)?";
    ///
    fn float1_37(
        &mut self,
        float1_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float1_37";
        trace!("{}", self.trace_item_stack(context));
        let float1_0 = *float1_0.token(parse_tree)?;
        let float1_37_built = Float1Builder::default()
            .float1_0(float1_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.float1(&float1_37_built)?;
        self.push(ASTType::Float1(float1_37_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// Float2: <Expr>"(?:[0-9] *)+E *[-+]? *(?:[0-9] *)+";
    ///
    fn float2_38(
        &mut self,
        float2_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "float2_38";
        trace!("{}", self.trace_item_stack(context));
        let float2_0 = *float2_0.token(parse_tree)?;
        let float2_38_built = Float2Builder::default()
            .float2_0(float2_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.float2(&float2_38_built)?;
        self.push(ASTType::Float2(float2_38_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// Integer: <Expr>"(?:[0-9] *)+";
    ///
    fn integer_39(
        &mut self,
        integer_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "integer_39";
        trace!("{}", self.trace_item_stack(context));
        let integer_0 = *integer_0.token(parse_tree)?;
        let integer_39_built = IntegerBuilder::default()
            .integer_0(integer_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.integer(&integer_39_built)?;
        self.push(ASTType::Integer(integer_39_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// If: "IF";
    ///
    fn if_40(
        &mut self,
        r#if_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "if_40";
        trace!("{}", self.trace_item_stack(context));
        let r#if_0 = *r#if_0.token(parse_tree)?;
        let if_40_built = IfBuilder::default()
            .r#if_0(r#if_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#if(&if_40_built)?;
        self.push(ASTType::If(if_40_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// Then: <Expr, INITIAL>"THEN";
    ///
    fn then_41(
        &mut self,
        then_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "then_41";
        trace!("{}", self.trace_item_stack(context));
        let then_0 = *then_0.token(parse_tree)?;
        let then_41_built = ThenBuilder::default()
            .then_0(then_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.then(&then_41_built)?;
        self.push(ASTType::Then(then_41_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// Goto: <Expr, INITIAL>"GOTO";
    ///
    fn goto_42(
        &mut self,
        goto_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "goto_42";
        trace!("{}", self.trace_item_stack(context));
        let goto_0 = *goto_0.token(parse_tree)?;
        let goto_42_built = GotoBuilder::default()
            .goto_0(goto_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.goto(&goto_42_built)?;
        self.push(ASTType::Goto(goto_42_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// Let: "LET";
    ///
    fn let_43(
        &mut self,
        r#let_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "let_43";
        trace!("{}", self.trace_item_stack(context));
        let r#let_0 = *r#let_0.token(parse_tree)?;
        let let_43_built = LetBuilder::default()
            .r#let_0(r#let_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#let(&let_43_built)?;
        self.push(ASTType::Let(let_43_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// Print: "PRINT|\?";
    ///
    fn print_44(
        &mut self,
        print_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "print_44";
        trace!("{}", self.trace_item_stack(context));
        let print_0 = *print_0.token(parse_tree)?;
        let print_44_built = PrintBuilder::default()
            .print_0(print_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.print(&print_44_built)?;
        self.push(ASTType::Print(print_44_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// End: "END";
    ///
    fn end_45(
        &mut self,
        end_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "end_45";
        trace!("{}", self.trace_item_stack(context));
        let end_0 = *end_0.token(parse_tree)?;
        let end_45_built = EndBuilder::default()
            .end_0(end_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.end(&end_45_built)?;
        self.push(ASTType::End(end_45_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// AssignOp: "=";
    ///
    fn assign_op_46(
        &mut self,
        assign_op_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "assign_op_46";
        trace!("{}", self.trace_item_stack(context));
        let assign_op_0 = *assign_op_0.token(parse_tree)?;
        let assign_op_46_built = AssignOpBuilder::default()
            .assign_op_0(assign_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.assign_op(&assign_op_46_built)?;
        self.push(ASTType::AssignOp(assign_op_46_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// LogicalOrOp: <Expr>"N?OR";
    ///
    fn logical_or_op_47(
        &mut self,
        logical_or_op_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_or_op_47";
        trace!("{}", self.trace_item_stack(context));
        let logical_or_op_0 = *logical_or_op_0.token(parse_tree)?;
        let logical_or_op_47_built = LogicalOrOpBuilder::default()
            .logical_or_op_0(logical_or_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_or_op(&logical_or_op_47_built)?;
        self.push(ASTType::LogicalOrOp(logical_or_op_47_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// LogicalAndOp: <Expr>"AND";
    ///
    fn logical_and_op_48(
        &mut self,
        logical_and_op_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_and_op_48";
        trace!("{}", self.trace_item_stack(context));
        let logical_and_op_0 = *logical_and_op_0.token(parse_tree)?;
        let logical_and_op_48_built = LogicalAndOpBuilder::default()
            .logical_and_op_0(logical_and_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_and_op(&logical_and_op_48_built)?;
        self.push(ASTType::LogicalAndOp(logical_and_op_48_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// LogicalNotOp: <Expr>"NOT";
    ///
    fn logical_not_op_49(
        &mut self,
        logical_not_op_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_not_op_49";
        trace!("{}", self.trace_item_stack(context));
        let logical_not_op_0 = *logical_not_op_0.token(parse_tree)?;
        let logical_not_op_49_built = LogicalNotOpBuilder::default()
            .logical_not_op_0(logical_not_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_not_op(&logical_not_op_49_built)?;
        self.push(ASTType::LogicalNotOp(logical_not_op_49_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// RelationalOp: <Expr>"<\s*>|<\s*=|<|>\s*=|>|=";
    ///
    fn relational_op_50(
        &mut self,
        relational_op_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "relational_op_50";
        trace!("{}", self.trace_item_stack(context));
        let relational_op_0 = *relational_op_0.token(parse_tree)?;
        let relational_op_50_built = RelationalOpBuilder::default()
            .relational_op_0(relational_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.relational_op(&relational_op_50_built)?;
        self.push(ASTType::RelationalOp(relational_op_50_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// Plus: <Expr>"\+";
    ///
    fn plus_51(
        &mut self,
        plus_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "plus_51";
        trace!("{}", self.trace_item_stack(context));
        let plus_0 = *plus_0.token(parse_tree)?;
        let plus_51_built = PlusBuilder::default()
            .plus_0(plus_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.plus(&plus_51_built)?;
        self.push(ASTType::Plus(plus_51_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// Minus: <Expr>"-";
    ///
    fn minus_52(
        &mut self,
        minus_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "minus_52";
        trace!("{}", self.trace_item_stack(context));
        let minus_0 = *minus_0.token(parse_tree)?;
        let minus_52_built = MinusBuilder::default()
            .minus_0(minus_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.minus(&minus_52_built)?;
        self.push(ASTType::Minus(minus_52_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// MulOp: <Expr>"\*|/";
    ///
    fn mul_op_53(
        &mut self,
        mul_op_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "mul_op_53";
        trace!("{}", self.trace_item_stack(context));
        let mul_op_0 = *mul_op_0.token(parse_tree)?;
        let mul_op_53_built = MulOpBuilder::default()
            .mul_op_0(mul_op_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_53_built)?;
        self.push(ASTType::MulOp(mul_op_53_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// LParen: <Expr>"\(";
    ///
    fn l_paren_54(
        &mut self,
        l_paren_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "l_paren_54";
        trace!("{}", self.trace_item_stack(context));
        let l_paren_0 = *l_paren_0.token(parse_tree)?;
        let l_paren_54_built = LParenBuilder::default()
            .l_paren_0(l_paren_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_paren(&l_paren_54_built)?;
        self.push(ASTType::LParen(l_paren_54_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// RParen: <Expr>"\)";
    ///
    fn r_paren_55(
        &mut self,
        r_paren_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "r_paren_55";
        trace!("{}", self.trace_item_stack(context));
        let r_paren_0 = *r_paren_0.token(parse_tree)?;
        let r_paren_55_built = RParenBuilder::default()
            .r_paren_0(r_paren_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_paren(&r_paren_55_built)?;
        self.push(ASTType::RParen(r_paren_55_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// Comment: <Cmnt>"[^\r\n]+";
    ///
    fn comment_56(
        &mut self,
        comment_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "comment_56";
        trace!("{}", self.trace_item_stack(context));
        let comment_0 = *comment_0.token(parse_tree)?;
        let comment_56_built = CommentBuilder::default()
            .comment_0(comment_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comment(&comment_56_built)?;
        self.push(ASTType::Comment(comment_56_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// Variable: <Expr, INITIAL>"[A-Z][0-9A-Z]*";
    ///
    fn variable_57(
        &mut self,
        variable_0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "variable_57";
        trace!("{}", self.trace_item_stack(context));
        let variable_0 = *variable_0.token(parse_tree)?;
        let variable_57_built = VariableBuilder::default()
            .variable_0(variable_0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.variable(&variable_57_built)?;
        self.push(ASTType::Variable(variable_57_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// Expression: LogicalOr;
    ///
    fn expression_58(
        &mut self,
        _logical_or_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "expression_58";
        trace!("{}", self.trace_item_stack(context));
        let logical_or_0 = if let Some(ASTType::LogicalOr(logical_or_0)) = self.pop(context) {
            logical_or_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalOr", context));
        };
        let expression_58_built = ExpressionBuilder::default()
            .logical_or_0(Box::new(logical_or_0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression(&expression_58_built)?;
        self.push(ASTType::Expression(expression_58_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// LogicalOr: LogicalAnd LogicalOrList /* Vec */;
    ///
    fn logical_or_59(
        &mut self,
        _logical_and_0: &ParseTreeStackEntry<'t>,
        _logical_or_list_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_or_59";
        trace!("{}", self.trace_item_stack(context));
        let logical_or_list_1 =
            if let Some(ASTType::LogicalOrList(mut logical_or_list_1)) = self.pop(context) {
                logical_or_list_1.reverse();
                logical_or_list_1
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalOrList", context));
            };
        let logical_and_0 = if let Some(ASTType::LogicalAnd(logical_and_0)) = self.pop(context) {
            logical_and_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalAnd", context));
        };
        let logical_or_59_built = LogicalOrBuilder::default()
            .logical_and_0(Box::new(logical_and_0))
            .logical_or_list_1(logical_or_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_or(&logical_or_59_built)?;
        self.push(ASTType::LogicalOr(logical_or_59_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// LogicalOrList: LogicalOrOp LogicalAnd LogicalOrList; // Vec<T>::Push
    ///
    fn logical_or_list_60(
        &mut self,
        _logical_or_op_0: &ParseTreeStackEntry<'t>,
        _logical_and_1: &ParseTreeStackEntry<'t>,
        _logical_or_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_or_list_60";
        trace!("{}", self.trace_item_stack(context));
        let mut logical_or_list_2 =
            if let Some(ASTType::LogicalOrList(logical_or_list_2)) = self.pop(context) {
                logical_or_list_2
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalOrList", context));
            };
        let logical_and_1 = if let Some(ASTType::LogicalAnd(logical_and_1)) = self.pop(context) {
            logical_and_1
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalAnd", context));
        };
        let logical_or_op_0 = if let Some(ASTType::LogicalOrOp(logical_or_op_0)) = self.pop(context)
        {
            logical_or_op_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalOrOp", context));
        };
        let logical_or_list_60_built = LogicalOrListBuilder::default()
            .logical_and_1(Box::new(logical_and_1))
            .logical_or_op_0(Box::new(logical_or_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        logical_or_list_2.push(logical_or_list_60_built);
        self.push(ASTType::LogicalOrList(logical_or_list_2), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// LogicalOrList: ; // Vec<T>::New
    ///
    fn logical_or_list_61(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "logical_or_list_61";
        trace!("{}", self.trace_item_stack(context));
        let logical_or_list_61_built = Vec::new();
        self.push(ASTType::LogicalOrList(logical_or_list_61_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// LogicalAnd: LogicalNot LogicalAndList /* Vec */;
    ///
    fn logical_and_62(
        &mut self,
        _logical_not_0: &ParseTreeStackEntry<'t>,
        _logical_and_list_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_and_62";
        trace!("{}", self.trace_item_stack(context));
        let logical_and_list_1 =
            if let Some(ASTType::LogicalAndList(mut logical_and_list_1)) = self.pop(context) {
                logical_and_list_1.reverse();
                logical_and_list_1
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalAndList", context));
            };
        let logical_not_0 = if let Some(ASTType::LogicalNot(logical_not_0)) = self.pop(context) {
            logical_not_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalNot", context));
        };
        let logical_and_62_built = LogicalAndBuilder::default()
            .logical_not_0(Box::new(logical_not_0))
            .logical_and_list_1(logical_and_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_and(&logical_and_62_built)?;
        self.push(ASTType::LogicalAnd(logical_and_62_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// LogicalAndList: LogicalAndOp LogicalNot LogicalAndList; // Vec<T>::Push
    ///
    fn logical_and_list_63(
        &mut self,
        _logical_and_op_0: &ParseTreeStackEntry<'t>,
        _logical_not_1: &ParseTreeStackEntry<'t>,
        _logical_and_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_and_list_63";
        trace!("{}", self.trace_item_stack(context));
        let mut logical_and_list_2 =
            if let Some(ASTType::LogicalAndList(logical_and_list_2)) = self.pop(context) {
                logical_and_list_2
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalAndList", context));
            };
        let logical_not_1 = if let Some(ASTType::LogicalNot(logical_not_1)) = self.pop(context) {
            logical_not_1
        } else {
            return Err(miette!("{}: Expecting ASTType::LogicalNot", context));
        };
        let logical_and_op_0 =
            if let Some(ASTType::LogicalAndOp(logical_and_op_0)) = self.pop(context) {
                logical_and_op_0
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalAndOp", context));
            };
        let logical_and_list_63_built = LogicalAndListBuilder::default()
            .logical_not_1(Box::new(logical_not_1))
            .logical_and_op_0(Box::new(logical_and_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        logical_and_list_2.push(logical_and_list_63_built);
        self.push(ASTType::LogicalAndList(logical_and_list_2), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// LogicalAndList: ; // Vec<T>::New
    ///
    fn logical_and_list_64(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "logical_and_list_64";
        trace!("{}", self.trace_item_stack(context));
        let logical_and_list_64_built = Vec::new();
        self.push(ASTType::LogicalAndList(logical_and_list_64_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// LogicalNot: LogicalNotOp Relational;
    ///
    fn logical_not_65(
        &mut self,
        _logical_not_op_0: &ParseTreeStackEntry<'t>,
        _relational_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_not_65";
        trace!("{}", self.trace_item_stack(context));
        let relational_1 = if let Some(ASTType::Relational(relational_1)) = self.pop(context) {
            relational_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Relational", context));
        };
        let logical_not_op_0 =
            if let Some(ASTType::LogicalNotOp(logical_not_op_0)) = self.pop(context) {
                logical_not_op_0
            } else {
                return Err(miette!("{}: Expecting ASTType::LogicalNotOp", context));
            };
        let logical_not_65_built = LogicalNot65Builder::default()
            .logical_not_op_0(Box::new(logical_not_op_0))
            .relational_1(Box::new(relational_1))
            .build()
            .into_diagnostic()?;
        let logical_not_65_built = LogicalNot::LogicalNot65(logical_not_65_built);
        // Calling user action here
        self.user_grammar.logical_not(&logical_not_65_built)?;
        self.push(ASTType::LogicalNot(logical_not_65_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// LogicalNot: Relational;
    ///
    fn logical_not_66(
        &mut self,
        _relational_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "logical_not_66";
        trace!("{}", self.trace_item_stack(context));
        let relational_0 = if let Some(ASTType::Relational(relational_0)) = self.pop(context) {
            relational_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Relational", context));
        };
        let logical_not_66_built = LogicalNot66Builder::default()
            .relational_0(Box::new(relational_0))
            .build()
            .into_diagnostic()?;
        let logical_not_66_built = LogicalNot::LogicalNot66(logical_not_66_built);
        // Calling user action here
        self.user_grammar.logical_not(&logical_not_66_built)?;
        self.push(ASTType::LogicalNot(logical_not_66_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// Relational: Summation RelationalList /* Vec */;
    ///
    fn relational_67(
        &mut self,
        _summation_0: &ParseTreeStackEntry<'t>,
        _relational_list_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "relational_67";
        trace!("{}", self.trace_item_stack(context));
        let relational_list_1 =
            if let Some(ASTType::RelationalList(mut relational_list_1)) = self.pop(context) {
                relational_list_1.reverse();
                relational_list_1
            } else {
                return Err(miette!("{}: Expecting ASTType::RelationalList", context));
            };
        let summation_0 = if let Some(ASTType::Summation(summation_0)) = self.pop(context) {
            summation_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Summation", context));
        };
        let relational_67_built = RelationalBuilder::default()
            .summation_0(Box::new(summation_0))
            .relational_list_1(relational_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.relational(&relational_67_built)?;
        self.push(ASTType::Relational(relational_67_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// RelationalList: RelationalOp Summation RelationalList; // Vec<T>::Push
    ///
    fn relational_list_68(
        &mut self,
        _relational_op_0: &ParseTreeStackEntry<'t>,
        _summation_1: &ParseTreeStackEntry<'t>,
        _relational_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "relational_list_68";
        trace!("{}", self.trace_item_stack(context));
        let mut relational_list_2 =
            if let Some(ASTType::RelationalList(relational_list_2)) = self.pop(context) {
                relational_list_2
            } else {
                return Err(miette!("{}: Expecting ASTType::RelationalList", context));
            };
        let summation_1 = if let Some(ASTType::Summation(summation_1)) = self.pop(context) {
            summation_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Summation", context));
        };
        let relational_op_0 =
            if let Some(ASTType::RelationalOp(relational_op_0)) = self.pop(context) {
                relational_op_0
            } else {
                return Err(miette!("{}: Expecting ASTType::RelationalOp", context));
            };
        let relational_list_68_built = RelationalListBuilder::default()
            .summation_1(Box::new(summation_1))
            .relational_op_0(Box::new(relational_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        relational_list_2.push(relational_list_68_built);
        self.push(ASTType::RelationalList(relational_list_2), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// RelationalList: ; // Vec<T>::New
    ///
    fn relational_list_69(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "relational_list_69";
        trace!("{}", self.trace_item_stack(context));
        let relational_list_69_built = Vec::new();
        self.push(ASTType::RelationalList(relational_list_69_built), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// Summation: Multiplication SummationList /* Vec */;
    ///
    fn summation_70(
        &mut self,
        _multiplication_0: &ParseTreeStackEntry<'t>,
        _summation_list_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "summation_70";
        trace!("{}", self.trace_item_stack(context));
        let summation_list_1 =
            if let Some(ASTType::SummationList(mut summation_list_1)) = self.pop(context) {
                summation_list_1.reverse();
                summation_list_1
            } else {
                return Err(miette!("{}: Expecting ASTType::SummationList", context));
            };
        let multiplication_0 =
            if let Some(ASTType::Multiplication(multiplication_0)) = self.pop(context) {
                multiplication_0
            } else {
                return Err(miette!("{}: Expecting ASTType::Multiplication", context));
            };
        let summation_70_built = SummationBuilder::default()
            .multiplication_0(Box::new(multiplication_0))
            .summation_list_1(summation_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.summation(&summation_70_built)?;
        self.push(ASTType::Summation(summation_70_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// SummationList: SummationListGroup Multiplication SummationList; // Vec<T>::Push
    ///
    fn summation_list_71(
        &mut self,
        _summation_list_group_0: &ParseTreeStackEntry<'t>,
        _multiplication_1: &ParseTreeStackEntry<'t>,
        _summation_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "summation_list_71";
        trace!("{}", self.trace_item_stack(context));
        let mut summation_list_2 =
            if let Some(ASTType::SummationList(summation_list_2)) = self.pop(context) {
                summation_list_2
            } else {
                return Err(miette!("{}: Expecting ASTType::SummationList", context));
            };
        let multiplication_1 =
            if let Some(ASTType::Multiplication(multiplication_1)) = self.pop(context) {
                multiplication_1
            } else {
                return Err(miette!("{}: Expecting ASTType::Multiplication", context));
            };
        let summation_list_group_0 =
            if let Some(ASTType::SummationListGroup(summation_list_group_0)) = self.pop(context) {
                summation_list_group_0
            } else {
                return Err(miette!(
                    "{}: Expecting ASTType::SummationListGroup",
                    context
                ));
            };
        let summation_list_71_built = SummationListBuilder::default()
            .multiplication_1(Box::new(multiplication_1))
            .summation_list_group_0(Box::new(summation_list_group_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        summation_list_2.push(summation_list_71_built);
        self.push(ASTType::SummationList(summation_list_2), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// SummationListGroup: Plus;
    ///
    fn summation_list_group_72(
        &mut self,
        _plus_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "summation_list_group_72";
        trace!("{}", self.trace_item_stack(context));
        let plus_0 = if let Some(ASTType::Plus(plus_0)) = self.pop(context) {
            plus_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Plus", context));
        };
        let summation_list_group_72_built = SummationListGroup72Builder::default()
            .plus_0(Box::new(plus_0))
            .build()
            .into_diagnostic()?;
        let summation_list_group_72_built =
            SummationListGroup::SummationListGroup72(summation_list_group_72_built);
        self.push(
            ASTType::SummationListGroup(summation_list_group_72_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// SummationListGroup: Minus;
    ///
    fn summation_list_group_73(
        &mut self,
        _minus_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "summation_list_group_73";
        trace!("{}", self.trace_item_stack(context));
        let minus_0 = if let Some(ASTType::Minus(minus_0)) = self.pop(context) {
            minus_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Minus", context));
        };
        let summation_list_group_73_built = SummationListGroup73Builder::default()
            .minus_0(Box::new(minus_0))
            .build()
            .into_diagnostic()?;
        let summation_list_group_73_built =
            SummationListGroup::SummationListGroup73(summation_list_group_73_built);
        self.push(
            ASTType::SummationListGroup(summation_list_group_73_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// SummationList: ; // Vec<T>::New
    ///
    fn summation_list_74(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "summation_list_74";
        trace!("{}", self.trace_item_stack(context));
        let summation_list_74_built = Vec::new();
        self.push(ASTType::SummationList(summation_list_74_built), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// Multiplication: Factor MultiplicationList /* Vec */;
    ///
    fn multiplication_75(
        &mut self,
        _factor_0: &ParseTreeStackEntry<'t>,
        _multiplication_list_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "multiplication_75";
        trace!("{}", self.trace_item_stack(context));
        let multiplication_list_1 =
            if let Some(ASTType::MultiplicationList(mut multiplication_list_1)) = self.pop(context)
            {
                multiplication_list_1.reverse();
                multiplication_list_1
            } else {
                return Err(miette!(
                    "{}: Expecting ASTType::MultiplicationList",
                    context
                ));
            };
        let factor_0 = if let Some(ASTType::Factor(factor_0)) = self.pop(context) {
            factor_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Factor", context));
        };
        let multiplication_75_built = MultiplicationBuilder::default()
            .factor_0(Box::new(factor_0))
            .multiplication_list_1(multiplication_list_1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.multiplication(&multiplication_75_built)?;
        self.push(ASTType::Multiplication(multiplication_75_built), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// MultiplicationList: MulOp Factor MultiplicationList; // Vec<T>::Push
    ///
    fn multiplication_list_76(
        &mut self,
        _mul_op_0: &ParseTreeStackEntry<'t>,
        _factor_1: &ParseTreeStackEntry<'t>,
        _multiplication_list_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "multiplication_list_76";
        trace!("{}", self.trace_item_stack(context));
        let mut multiplication_list_2 =
            if let Some(ASTType::MultiplicationList(multiplication_list_2)) = self.pop(context) {
                multiplication_list_2
            } else {
                return Err(miette!(
                    "{}: Expecting ASTType::MultiplicationList",
                    context
                ));
            };
        let factor_1 = if let Some(ASTType::Factor(factor_1)) = self.pop(context) {
            factor_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Factor", context));
        };
        let mul_op_0 = if let Some(ASTType::MulOp(mul_op_0)) = self.pop(context) {
            mul_op_0
        } else {
            return Err(miette!("{}: Expecting ASTType::MulOp", context));
        };
        let multiplication_list_76_built = MultiplicationListBuilder::default()
            .factor_1(Box::new(factor_1))
            .mul_op_0(Box::new(mul_op_0))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        multiplication_list_2.push(multiplication_list_76_built);
        self.push(ASTType::MultiplicationList(multiplication_list_2), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// MultiplicationList: ; // Vec<T>::New
    ///
    fn multiplication_list_77(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = "multiplication_list_77";
        trace!("{}", self.trace_item_stack(context));
        let multiplication_list_77_built = Vec::new();
        self.push(
            ASTType::MultiplicationList(multiplication_list_77_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// Factor: Literal;
    ///
    fn factor_78(
        &mut self,
        _literal_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "factor_78";
        trace!("{}", self.trace_item_stack(context));
        let literal_0 = if let Some(ASTType::Literal(literal_0)) = self.pop(context) {
            literal_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Literal", context));
        };
        let factor_78_built = Factor78Builder::default()
            .literal_0(Box::new(literal_0))
            .build()
            .into_diagnostic()?;
        let factor_78_built = Factor::Factor78(factor_78_built);
        // Calling user action here
        self.user_grammar.factor(&factor_78_built)?;
        self.push(ASTType::Factor(factor_78_built), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// Factor: Variable;
    ///
    fn factor_79(
        &mut self,
        _variable_0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "factor_79";
        trace!("{}", self.trace_item_stack(context));
        let variable_0 = if let Some(ASTType::Variable(variable_0)) = self.pop(context) {
            variable_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Variable", context));
        };
        let factor_79_built = Factor79Builder::default()
            .variable_0(Box::new(variable_0))
            .build()
            .into_diagnostic()?;
        let factor_79_built = Factor::Factor79(factor_79_built);
        // Calling user action here
        self.user_grammar.factor(&factor_79_built)?;
        self.push(ASTType::Factor(factor_79_built), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// Factor: Minus Factor;
    ///
    fn factor_80(
        &mut self,
        _minus_0: &ParseTreeStackEntry<'t>,
        _factor_1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "factor_80";
        trace!("{}", self.trace_item_stack(context));
        let factor_1 = if let Some(ASTType::Factor(factor_1)) = self.pop(context) {
            factor_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Factor", context));
        };
        let minus_0 = if let Some(ASTType::Minus(minus_0)) = self.pop(context) {
            minus_0
        } else {
            return Err(miette!("{}: Expecting ASTType::Minus", context));
        };
        let factor_80_built = Factor80Builder::default()
            .minus_0(Box::new(minus_0))
            .factor_1(Box::new(factor_1))
            .build()
            .into_diagnostic()?;
        let factor_80_built = Factor::Factor80(factor_80_built);
        // Calling user action here
        self.user_grammar.factor(&factor_80_built)?;
        self.push(ASTType::Factor(factor_80_built), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// Factor: LParen Expression RParen;
    ///
    fn factor_81(
        &mut self,
        _l_paren_0: &ParseTreeStackEntry<'t>,
        _expression_1: &ParseTreeStackEntry<'t>,
        _r_paren_2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = "factor_81";
        trace!("{}", self.trace_item_stack(context));
        let r_paren_2 = if let Some(ASTType::RParen(r_paren_2)) = self.pop(context) {
            r_paren_2
        } else {
            return Err(miette!("{}: Expecting ASTType::RParen", context));
        };
        let expression_1 = if let Some(ASTType::Expression(expression_1)) = self.pop(context) {
            expression_1
        } else {
            return Err(miette!("{}: Expecting ASTType::Expression", context));
        };
        let l_paren_0 = if let Some(ASTType::LParen(l_paren_0)) = self.pop(context) {
            l_paren_0
        } else {
            return Err(miette!("{}: Expecting ASTType::LParen", context));
        };
        let factor_81_built = Factor81Builder::default()
            .l_paren_0(Box::new(l_paren_0))
            .expression_1(Box::new(expression_1))
            .r_paren_2(Box::new(r_paren_2))
            .build()
            .into_diagnostic()?;
        let factor_81_built = Factor::Factor81(factor_81_built);
        // Calling user action here
        self.user_grammar.factor(&factor_81_built)?;
        self.push(ASTType::Factor(factor_81_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for BasicGrammarAuto<'t, '_> {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// Is is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, file_name: &Path) {
        self.file_name = file_name.to_owned();
        self.user_grammar.init(file_name);
    }

    ///
    /// This function is implemented automatically for the user's item BasicGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.basic_0(&children[0], &children[1], &children[2], parse_tree),
            1 => self.basic_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            2 => self.basic_suffix1_2(&children[0], parse_tree),
            3 => self.basic_suffix1_3(parse_tree),
            4 => self.basic_suffix_4(&children[0], parse_tree),
            5 => self.basic_suffix_5(parse_tree),
            6 => self.basic_list_6(&children[0], &children[1], &children[2], parse_tree),
            7 => self.basic_list_7(parse_tree),
            8 => self.line_8(&children[0], &children[1], &children[2], parse_tree),
            9 => self.line_list_9(&children[0], &children[1], &children[2], parse_tree),
            10 => self.line_list_10(parse_tree),
            11 => self.line_number_11(&children[0], parse_tree),
            12 => self.statement_12(&children[0], parse_tree),
            13 => self.statement_13(&children[0], parse_tree),
            14 => self.statement_14(&children[0], parse_tree),
            15 => self.statement_15(&children[0], parse_tree),
            16 => self.statement_16(&children[0], parse_tree),
            17 => self.statement_17(&children[0], parse_tree),
            18 => self.remark_18(&children[0], &children[1], parse_tree),
            19 => self.remark_suffix_19(&children[0], parse_tree),
            20 => self.remark_suffix_20(parse_tree),
            21 => self.goto_statement_21(&children[0], &children[1], parse_tree),
            22 => self.if_statement_22(&children[0], &children[1], &children[2], parse_tree),
            23 => self.assignment_23(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            24 => self.assignment_24(&children[0], &children[1], &children[2], parse_tree),
            25 => self.if_body_25(&children[0], &children[1], parse_tree),
            26 => self.if_body_26(&children[0], &children[1], parse_tree),
            27 => self.print_statement_27(&children[0], &children[1], &children[2], parse_tree),
            28 => {
                self.print_statement_list_28(&children[0], &children[1], &children[2], parse_tree)
            }
            29 => self.print_statement_list_29(parse_tree),
            30 => self.end_statement_30(&children[0], parse_tree),
            31 => self.end_of_line_31(&children[0], parse_tree),
            32 => self.literal_32(&children[0], parse_tree),
            33 => self.number_33(&children[0], parse_tree),
            34 => self.number_34(&children[0], parse_tree),
            35 => self.float_35(&children[0], parse_tree),
            36 => self.float_36(&children[0], parse_tree),
            37 => self.float1_37(&children[0], parse_tree),
            38 => self.float2_38(&children[0], parse_tree),
            39 => self.integer_39(&children[0], parse_tree),
            40 => self.if_40(&children[0], parse_tree),
            41 => self.then_41(&children[0], parse_tree),
            42 => self.goto_42(&children[0], parse_tree),
            43 => self.let_43(&children[0], parse_tree),
            44 => self.print_44(&children[0], parse_tree),
            45 => self.end_45(&children[0], parse_tree),
            46 => self.assign_op_46(&children[0], parse_tree),
            47 => self.logical_or_op_47(&children[0], parse_tree),
            48 => self.logical_and_op_48(&children[0], parse_tree),
            49 => self.logical_not_op_49(&children[0], parse_tree),
            50 => self.relational_op_50(&children[0], parse_tree),
            51 => self.plus_51(&children[0], parse_tree),
            52 => self.minus_52(&children[0], parse_tree),
            53 => self.mul_op_53(&children[0], parse_tree),
            54 => self.l_paren_54(&children[0], parse_tree),
            55 => self.r_paren_55(&children[0], parse_tree),
            56 => self.comment_56(&children[0], parse_tree),
            57 => self.variable_57(&children[0], parse_tree),
            58 => self.expression_58(&children[0], parse_tree),
            59 => self.logical_or_59(&children[0], &children[1], parse_tree),
            60 => self.logical_or_list_60(&children[0], &children[1], &children[2], parse_tree),
            61 => self.logical_or_list_61(parse_tree),
            62 => self.logical_and_62(&children[0], &children[1], parse_tree),
            63 => self.logical_and_list_63(&children[0], &children[1], &children[2], parse_tree),
            64 => self.logical_and_list_64(parse_tree),
            65 => self.logical_not_65(&children[0], &children[1], parse_tree),
            66 => self.logical_not_66(&children[0], parse_tree),
            67 => self.relational_67(&children[0], &children[1], parse_tree),
            68 => self.relational_list_68(&children[0], &children[1], &children[2], parse_tree),
            69 => self.relational_list_69(parse_tree),
            70 => self.summation_70(&children[0], &children[1], parse_tree),
            71 => self.summation_list_71(&children[0], &children[1], &children[2], parse_tree),
            72 => self.summation_list_group_72(&children[0], parse_tree),
            73 => self.summation_list_group_73(&children[0], parse_tree),
            74 => self.summation_list_74(parse_tree),
            75 => self.multiplication_75(&children[0], &children[1], parse_tree),
            76 => self.multiplication_list_76(&children[0], &children[1], &children[2], parse_tree),
            77 => self.multiplication_list_77(parse_tree),
            78 => self.factor_78(&children[0], parse_tree),
            79 => self.factor_79(&children[0], parse_tree),
            80 => self.factor_80(&children[0], &children[1], parse_tree),
            81 => self.factor_81(&children[0], &children[1], &children[2], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
