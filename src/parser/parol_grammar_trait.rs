// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

#![allow(unused_imports)]
use crate::parser::parol_grammar::ParolGrammar;
use id_tree::Tree;
use log::trace;
use miette::{bail, miette, IntoDiagnostic, Result};
use parol_runtime::lexer::Token;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};
use std::path::{Path, PathBuf};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait ParolGrammarTrait<'t> {
    fn init(&mut self, _file_name: &Path) {}

    /// Semantic action for non-terminal 'Parol'
    fn parol(&mut self, _arg: &Parol<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Prolog'
    fn prolog(&mut self, _arg: &Prolog<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StartDeclaration'
    fn start_declaration(&mut self, _arg: &StartDeclaration<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Declaration'
    fn declaration(&mut self, _arg: &Declaration<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScannerDirectives'
    fn scanner_directives(&mut self, _arg: &ScannerDirectives<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GrammarDefinition'
    fn grammar_definition(&mut self, _arg: &GrammarDefinition<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DoubleColon'
    fn double_colon(&mut self, _arg: &DoubleColon<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Production'
    fn production(&mut self, _arg: &Production<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Alternations'
    fn alternations(&mut self, _arg: &Alternations<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Alternation'
    fn alternation(&mut self, _arg: &Alternation<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Factor'
    fn factor(&mut self, _arg: &Factor<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Symbol'
    fn symbol(&mut self, _arg: &Symbol<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SimpleToken'
    fn simple_token(&mut self, _arg: &SimpleToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TokenWithStates'
    fn token_with_states(&mut self, _arg: &TokenWithStates<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Group'
    fn group(&mut self, _arg: &Group<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Optional'
    fn optional(&mut self, _arg: &Optional<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Repeat'
    fn repeat(&mut self, _arg: &Repeat<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NonTerminal'
    fn non_terminal(&mut self, _arg: &NonTerminal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Identifier'
    fn identifier(&mut self, _arg: &Identifier<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'String'
    fn string(&mut self, _arg: &String<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScannerState'
    fn scanner_state(&mut self, _arg: &ScannerState<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StateList'
    fn state_list(&mut self, _arg: &StateList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScannerSwitch'
    fn scanner_switch(&mut self, _arg: &ScannerSwitch<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ASTControl'
    fn a_s_t_control(&mut self, _arg: &ASTControl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CutOperator'
    fn cut_operator(&mut self, _arg: &CutOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UserTypeDeclaration'
    fn user_type_declaration(&mut self, _arg: &UserTypeDeclaration<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UserTypeName'
    fn user_type_name(&mut self, _arg: &UserTypeName<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 7
///
/// Declaration: "%title"^ /* Clipped */ String;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Declaration0<'t> {
    pub string: Box<String<'t>>,
}

///
/// Type derived for production 8
///
/// Declaration: "%comment"^ /* Clipped */ String;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Declaration1<'t> {
    pub string: Box<String<'t>>,
}

///
/// Type derived for production 9
///
/// Declaration: ScannerDirectives;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Declaration2<'t> {
    pub scanner_directives: Box<ScannerDirectives<'t>>,
}

///
/// Type derived for production 10
///
/// ScannerDirectives: "%line_comment"^ /* Clipped */ String;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ScannerDirectives0<'t> {
    pub string: Box<String<'t>>,
}

///
/// Type derived for production 11
///
/// ScannerDirectives: "%block_comment"^ /* Clipped */ String String;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ScannerDirectives1<'t> {
    pub string: Box<String<'t>>,
    pub string0: Box<String<'t>>,
}

///
/// Type derived for production 12
///
/// ScannerDirectives: "%auto_newline_off"^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ScannerDirectives2 {}

///
/// Type derived for production 13
///
/// ScannerDirectives: "%auto_ws_off"^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ScannerDirectives3 {}

///
/// Type derived for production 25
///
/// Factor: Group;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor0<'t> {
    pub group: Box<Group<'t>>,
}

///
/// Type derived for production 26
///
/// Factor: Repeat;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor1<'t> {
    pub repeat: Box<Repeat<'t>>,
}

///
/// Type derived for production 27
///
/// Factor: Optional;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor2<'t> {
    pub optional: Box<Optional<'t>>,
}

///
/// Type derived for production 28
///
/// Factor: Symbol;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor3<'t> {
    pub symbol: Box<Symbol<'t>>,
}

///
/// Type derived for production 29
///
/// Symbol: NonTerminal;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Symbol0<'t> {
    pub non_terminal: Box<NonTerminal<'t>>,
}

///
/// Type derived for production 30
///
/// Symbol: SimpleToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Symbol1<'t> {
    pub simple_token: Box<SimpleToken<'t>>,
}

///
/// Type derived for production 31
///
/// Symbol: TokenWithStates;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Symbol2<'t> {
    pub token_with_states: Box<TokenWithStates<'t>>,
}

///
/// Type derived for production 32
///
/// Symbol: ScannerSwitch;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Symbol3<'t> {
    pub scanner_switch: Box<ScannerSwitch<'t>>,
}

///
/// Type derived for production 53
///
/// ScannerSwitch: "%sc"^ /* Clipped */ "\("^ /* Clipped */ ScannerSwitchOpt /* Option */ "\)"^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ScannerSwitch0<'t> {
    pub scanner_switch_opt: Option<Box<ScannerSwitchOpt<'t>>>,
}

///
/// Type derived for production 54
///
/// ScannerSwitch: "%push"^ /* Clipped */ "\("^ /* Clipped */ Identifier "\)"^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ScannerSwitch1<'t> {
    pub identifier: Box<Identifier<'t>>,
}

///
/// Type derived for production 55
///
/// ScannerSwitch: "%pop"^ /* Clipped */ "\("^ /* Clipped */ "\)"^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ScannerSwitch2 {}

///
/// Type derived for production 58
///
/// ASTControl: CutOperator;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ASTControl0 {
    pub cut_operator: Box<CutOperator>,
}

///
/// Type derived for production 59
///
/// ASTControl: UserTypeDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ASTControl1<'t> {
    pub user_type_declaration: Box<UserTypeDeclaration<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal ASTControl
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTControl<'t> {
    ASTControl0(ASTControl0),
    ASTControl1(ASTControl1<'t>),
}

///
/// Type derived for non-terminal Alternation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Alternation<'t> {
    pub alternation_list: Vec<AlternationList<'t>>,
}

///
/// Type derived for non-terminal AlternationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlternationList<'t> {
    pub factor: Box<Factor<'t>>,
}

///
/// Type derived for non-terminal Alternations
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Alternations<'t> {
    pub alternation: Box<Alternation<'t>>,
    pub alternations_list: Vec<AlternationsList<'t>>,
}

///
/// Type derived for non-terminal AlternationsList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlternationsList<'t> {
    pub alternation: Box<Alternation<'t>>,
}

///
/// Type derived for non-terminal CutOperator
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CutOperator {}

///
/// Type derived for non-terminal Declaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Declaration<'t> {
    Declaration0(Declaration0<'t>),
    Declaration1(Declaration1<'t>),
    Declaration2(Declaration2<'t>),
}

///
/// Type derived for non-terminal DoubleColon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DoubleColon<'t> {
    pub double_colon: Token<'t>, /* :: */
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor<'t> {
    Factor0(Factor0<'t>),
    Factor1(Factor1<'t>),
    Factor2(Factor2<'t>),
    Factor3(Factor3<'t>),
}

///
/// Type derived for non-terminal GrammarDefinition
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct GrammarDefinition<'t> {
    pub production: Box<Production<'t>>,
    pub grammar_definition_list: Vec<GrammarDefinitionList<'t>>,
}

///
/// Type derived for non-terminal GrammarDefinitionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct GrammarDefinitionList<'t> {
    pub production: Box<Production<'t>>,
}

///
/// Type derived for non-terminal Group
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Group<'t> {
    pub alternations: Box<Alternations<'t>>,
}

///
/// Type derived for non-terminal Identifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Identifier<'t> {
    pub identifier: Token<'t>, /* [a-zA-Z_][a-zA-Z0-9_]* */
}

///
/// Type derived for non-terminal NonTerminal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct NonTerminal<'t> {
    pub identifier: Box<Identifier<'t>>,
    pub non_terminal_opt: Option<Box<NonTerminalOpt>>,
}

///
/// Type derived for non-terminal NonTerminalOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct NonTerminalOpt {
    pub cut_operator: Box<CutOperator>,
}

///
/// Type derived for non-terminal Optional
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Optional<'t> {
    pub alternations: Box<Alternations<'t>>,
}

///
/// Type derived for non-terminal Parol
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Parol<'t> {
    pub prolog: Box<Prolog<'t>>,
    pub grammar_definition: Box<GrammarDefinition<'t>>,
}

///
/// Type derived for non-terminal Production
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Production<'t> {
    pub identifier: Box<Identifier<'t>>,
    pub alternations: Box<Alternations<'t>>,
}

///
/// Type derived for non-terminal Prolog
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Prolog<'t> {
    pub start_declaration: Box<StartDeclaration<'t>>,
    pub prolog_list: Vec<PrologList<'t>>,
    pub prolog_list0: Vec<PrologList0<'t>>,
}

///
/// Type derived for non-terminal PrologList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct PrologList<'t> {
    pub declaration: Box<Declaration<'t>>,
}

///
/// Type derived for non-terminal PrologList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct PrologList0<'t> {
    pub scanner_state: Box<ScannerState<'t>>,
}

///
/// Type derived for non-terminal Repeat
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Repeat<'t> {
    pub alternations: Box<Alternations<'t>>,
}

///
/// Type derived for non-terminal ScannerDirectives
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ScannerDirectives<'t> {
    ScannerDirectives0(ScannerDirectives0<'t>),
    ScannerDirectives1(ScannerDirectives1<'t>),
    ScannerDirectives2(ScannerDirectives2),
    ScannerDirectives3(ScannerDirectives3),
}

///
/// Type derived for non-terminal ScannerState
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ScannerState<'t> {
    pub identifier: Box<Identifier<'t>>,
    pub scanner_state_list: Vec<ScannerStateList<'t>>,
}

///
/// Type derived for non-terminal ScannerStateList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ScannerStateList<'t> {
    pub scanner_directives: Box<ScannerDirectives<'t>>,
}

///
/// Type derived for non-terminal ScannerSwitch
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ScannerSwitch<'t> {
    ScannerSwitch0(ScannerSwitch0<'t>),
    ScannerSwitch1(ScannerSwitch1<'t>),
    ScannerSwitch2(ScannerSwitch2),
}

///
/// Type derived for non-terminal ScannerSwitchOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ScannerSwitchOpt<'t> {
    pub identifier: Box<Identifier<'t>>,
}

///
/// Type derived for non-terminal SimpleToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SimpleToken<'t> {
    pub string: Box<String<'t>>,
    pub simple_token_opt: Option<Box<SimpleTokenOpt<'t>>>,
}

///
/// Type derived for non-terminal SimpleTokenOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SimpleTokenOpt<'t> {
    pub a_s_t_control: Box<ASTControl<'t>>,
}

///
/// Type derived for non-terminal StartDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StartDeclaration<'t> {
    pub identifier: Box<Identifier<'t>>,
}

///
/// Type derived for non-terminal StateList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StateList<'t> {
    pub identifier: Box<Identifier<'t>>,
    pub state_list_list: Vec<StateListList<'t>>,
}

///
/// Type derived for non-terminal StateListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StateListList<'t> {
    pub identifier: Box<Identifier<'t>>,
}

///
/// Type derived for non-terminal String
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct String<'t> {
    pub string: Token<'t>, /* \u{0022}([^\\]|\\.)*?\u{0022} */
}

///
/// Type derived for non-terminal Symbol
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Symbol<'t> {
    Symbol0(Symbol0<'t>),
    Symbol1(Symbol1<'t>),
    Symbol2(Symbol2<'t>),
    Symbol3(Symbol3<'t>),
}

///
/// Type derived for non-terminal TokenWithStates
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TokenWithStates<'t> {
    pub state_list: Box<StateList<'t>>,
    pub string: Box<String<'t>>,
    pub token_with_states_opt: Option<Box<TokenWithStatesOpt<'t>>>,
}

///
/// Type derived for non-terminal TokenWithStatesOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TokenWithStatesOpt<'t> {
    pub a_s_t_control: Box<ASTControl<'t>>,
}

///
/// Type derived for non-terminal UserTypeDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct UserTypeDeclaration<'t> {
    pub user_type_name: Box<UserTypeName<'t>>,
}

///
/// Type derived for non-terminal UserTypeName
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct UserTypeName<'t> {
    pub identifier: Box<Identifier<'t>>,
    pub user_type_name_list: Vec<UserTypeNameList<'t>>,
}

///
/// Type derived for non-terminal UserTypeNameList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct UserTypeNameList<'t> {
    pub identifier: Box<Identifier<'t>>,
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    ASTControl(ASTControl<'t>),
    Alternation(Alternation<'t>),
    AlternationList(Vec<AlternationList<'t>>),
    Alternations(Alternations<'t>),
    AlternationsList(Vec<AlternationsList<'t>>),
    CutOperator(CutOperator),
    Declaration(Declaration<'t>),
    DoubleColon(DoubleColon<'t>),
    Factor(Factor<'t>),
    GrammarDefinition(GrammarDefinition<'t>),
    GrammarDefinitionList(Vec<GrammarDefinitionList<'t>>),
    Group(Group<'t>),
    Identifier(Identifier<'t>),
    NonTerminal(NonTerminal<'t>),
    NonTerminalOpt(Option<Box<NonTerminalOpt>>),
    Optional(Optional<'t>),
    Parol(Parol<'t>),
    Production(Production<'t>),
    Prolog(Prolog<'t>),
    PrologList(Vec<PrologList<'t>>),
    PrologList0(Vec<PrologList0<'t>>),
    Repeat(Repeat<'t>),
    ScannerDirectives(ScannerDirectives<'t>),
    ScannerState(ScannerState<'t>),
    ScannerStateList(Vec<ScannerStateList<'t>>),
    ScannerSwitch(ScannerSwitch<'t>),
    ScannerSwitchOpt(Option<Box<ScannerSwitchOpt<'t>>>),
    SimpleToken(SimpleToken<'t>),
    SimpleTokenOpt(Option<Box<SimpleTokenOpt<'t>>>),
    StartDeclaration(StartDeclaration<'t>),
    StateList(StateList<'t>),
    StateListList(Vec<StateListList<'t>>),
    String(String<'t>),
    Symbol(Symbol<'t>),
    TokenWithStates(TokenWithStates<'t>),
    TokenWithStatesOpt(Option<Box<TokenWithStatesOpt<'t>>>),
    UserTypeDeclaration(UserTypeDeclaration<'t>),
    UserTypeName(UserTypeName<'t>),
    UserTypeNameList(Vec<UserTypeNameList<'t>>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct ParolGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn ParolGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
    // Path of the input file. Used for diagnostics.
    file_name: PathBuf,
}

///
/// The `ParolGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> ParolGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn ParolGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            file_name: PathBuf::default(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// Parol: Prolog GrammarDefinition;
    ///
    #[named]
    fn parol(
        &mut self,
        _prolog: &ParseTreeStackEntry<'t>,
        _grammar_definition: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let grammar_definition =
            if let Some(ASTType::GrammarDefinition(grammar_definition)) = self.pop(context) {
                grammar_definition
            } else {
                bail!("{}: Expecting ASTType::GrammarDefinition", context);
            };
        let prolog = if let Some(ASTType::Prolog(prolog)) = self.pop(context) {
            prolog
        } else {
            bail!("{}: Expecting ASTType::Prolog", context);
        };
        let parol_built = ParolBuilder::default()
            .prolog(Box::new(prolog))
            .grammar_definition(Box::new(grammar_definition))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.parol(&parol_built)?;
        self.push(ASTType::Parol(parol_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Prolog: StartDeclaration PrologList /* Vec */ PrologList0 /* Vec */;
    ///
    #[named]
    fn prolog(
        &mut self,
        _start_declaration: &ParseTreeStackEntry<'t>,
        _prolog_list: &ParseTreeStackEntry<'t>,
        _prolog_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let prolog_list0 = if let Some(ASTType::PrologList0(mut prolog_list0)) = self.pop(context) {
            prolog_list0.reverse();
            prolog_list0
        } else {
            bail!("{}: Expecting ASTType::PrologList0", context);
        };
        let prolog_list = if let Some(ASTType::PrologList(mut prolog_list)) = self.pop(context) {
            prolog_list.reverse();
            prolog_list
        } else {
            bail!("{}: Expecting ASTType::PrologList", context);
        };
        let start_declaration =
            if let Some(ASTType::StartDeclaration(start_declaration)) = self.pop(context) {
                start_declaration
            } else {
                bail!("{}: Expecting ASTType::StartDeclaration", context);
            };
        let prolog_built = PrologBuilder::default()
            .start_declaration(Box::new(start_declaration))
            .prolog_list(prolog_list)
            .prolog_list0(prolog_list0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.prolog(&prolog_built)?;
        self.push(ASTType::Prolog(prolog_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// PrologList0: ScannerState PrologList0; // Vec<T>::Push
    ///
    #[named]
    fn prolog_list0_0(
        &mut self,
        _scanner_state: &ParseTreeStackEntry<'t>,
        _prolog_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut prolog_list0 = if let Some(ASTType::PrologList0(prolog_list0)) = self.pop(context) {
            prolog_list0
        } else {
            bail!("{}: Expecting ASTType::PrologList0", context);
        };
        let scanner_state = if let Some(ASTType::ScannerState(scanner_state)) = self.pop(context) {
            scanner_state
        } else {
            bail!("{}: Expecting ASTType::ScannerState", context);
        };
        let prolog_list0_0_built = PrologList0Builder::default()
            .scanner_state(Box::new(scanner_state))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        prolog_list0.push(prolog_list0_0_built);
        self.push(ASTType::PrologList0(prolog_list0), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// PrologList0: ; // Vec<T>::New
    ///
    #[named]
    fn prolog_list0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let prolog_list0_1_built = Vec::new();
        self.push(ASTType::PrologList0(prolog_list0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// PrologList: Declaration PrologList; // Vec<T>::Push
    ///
    #[named]
    fn prolog_list_0(
        &mut self,
        _declaration: &ParseTreeStackEntry<'t>,
        _prolog_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut prolog_list = if let Some(ASTType::PrologList(prolog_list)) = self.pop(context) {
            prolog_list
        } else {
            bail!("{}: Expecting ASTType::PrologList", context);
        };
        let declaration = if let Some(ASTType::Declaration(declaration)) = self.pop(context) {
            declaration
        } else {
            bail!("{}: Expecting ASTType::Declaration", context);
        };
        let prolog_list_0_built = PrologListBuilder::default()
            .declaration(Box::new(declaration))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        prolog_list.push(prolog_list_0_built);
        self.push(ASTType::PrologList(prolog_list), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// PrologList: ; // Vec<T>::New
    ///
    #[named]
    fn prolog_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let prolog_list_1_built = Vec::new();
        self.push(ASTType::PrologList(prolog_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// StartDeclaration: "%start"^ /* Clipped */ Identifier;
    ///
    #[named]
    fn start_declaration(
        &mut self,
        _percent_start: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = if let Some(ASTType::Identifier(identifier)) = self.pop(context) {
            identifier
        } else {
            bail!("{}: Expecting ASTType::Identifier", context);
        };
        let start_declaration_built = StartDeclarationBuilder::default()
            // Ignore clipped member 'percent_start'
            .identifier(Box::new(identifier))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .start_declaration(&start_declaration_built)?;
        self.push(ASTType::StartDeclaration(start_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// Declaration: "%title"^ /* Clipped */ String;
    ///
    #[named]
    fn declaration_0(
        &mut self,
        _percent_title: &ParseTreeStackEntry<'t>,
        _string: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = if let Some(ASTType::String(string)) = self.pop(context) {
            string
        } else {
            bail!("{}: Expecting ASTType::String", context);
        };
        let declaration_0_built = Declaration0Builder::default()
            // Ignore clipped member 'percent_title'
            .string(Box::new(string))
            .build()
            .into_diagnostic()?;
        let declaration_0_built = Declaration::Declaration0(declaration_0_built);
        // Calling user action here
        self.user_grammar.declaration(&declaration_0_built)?;
        self.push(ASTType::Declaration(declaration_0_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// Declaration: "%comment"^ /* Clipped */ String;
    ///
    #[named]
    fn declaration_1(
        &mut self,
        _percent_comment: &ParseTreeStackEntry<'t>,
        _string: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = if let Some(ASTType::String(string)) = self.pop(context) {
            string
        } else {
            bail!("{}: Expecting ASTType::String", context);
        };
        let declaration_1_built = Declaration1Builder::default()
            // Ignore clipped member 'percent_comment'
            .string(Box::new(string))
            .build()
            .into_diagnostic()?;
        let declaration_1_built = Declaration::Declaration1(declaration_1_built);
        // Calling user action here
        self.user_grammar.declaration(&declaration_1_built)?;
        self.push(ASTType::Declaration(declaration_1_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// Declaration: ScannerDirectives;
    ///
    #[named]
    fn declaration_2(
        &mut self,
        _scanner_directives: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_directives =
            if let Some(ASTType::ScannerDirectives(scanner_directives)) = self.pop(context) {
                scanner_directives
            } else {
                bail!("{}: Expecting ASTType::ScannerDirectives", context);
            };
        let declaration_2_built = Declaration2Builder::default()
            .scanner_directives(Box::new(scanner_directives))
            .build()
            .into_diagnostic()?;
        let declaration_2_built = Declaration::Declaration2(declaration_2_built);
        // Calling user action here
        self.user_grammar.declaration(&declaration_2_built)?;
        self.push(ASTType::Declaration(declaration_2_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// ScannerDirectives: "%line_comment"^ /* Clipped */ String;
    ///
    #[named]
    fn scanner_directives_0(
        &mut self,
        _percent_line_underscore_comment: &ParseTreeStackEntry<'t>,
        _string: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = if let Some(ASTType::String(string)) = self.pop(context) {
            string
        } else {
            bail!("{}: Expecting ASTType::String", context);
        };
        let scanner_directives_0_built = ScannerDirectives0Builder::default()
            // Ignore clipped member 'percent_line_underscore_comment'
            .string(Box::new(string))
            .build()
            .into_diagnostic()?;
        let scanner_directives_0_built =
            ScannerDirectives::ScannerDirectives0(scanner_directives_0_built);
        // Calling user action here
        self.user_grammar
            .scanner_directives(&scanner_directives_0_built)?;
        self.push(
            ASTType::ScannerDirectives(scanner_directives_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// ScannerDirectives: "%block_comment"^ /* Clipped */ String String;
    ///
    #[named]
    fn scanner_directives_1(
        &mut self,
        _percent_block_underscore_comment: &ParseTreeStackEntry<'t>,
        _string: &ParseTreeStackEntry<'t>,
        _string0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string0 = if let Some(ASTType::String(string0)) = self.pop(context) {
            string0
        } else {
            bail!("{}: Expecting ASTType::String", context);
        };
        let string = if let Some(ASTType::String(string)) = self.pop(context) {
            string
        } else {
            bail!("{}: Expecting ASTType::String", context);
        };
        let scanner_directives_1_built = ScannerDirectives1Builder::default()
            // Ignore clipped member 'percent_block_underscore_comment'
            .string(Box::new(string))
            .string0(Box::new(string0))
            .build()
            .into_diagnostic()?;
        let scanner_directives_1_built =
            ScannerDirectives::ScannerDirectives1(scanner_directives_1_built);
        // Calling user action here
        self.user_grammar
            .scanner_directives(&scanner_directives_1_built)?;
        self.push(
            ASTType::ScannerDirectives(scanner_directives_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// ScannerDirectives: "%auto_newline_off"^ /* Clipped */;
    ///
    #[named]
    fn scanner_directives_2(
        &mut self,
        _percent_auto_underscore_newline_underscore_off: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_directives_2_built = ScannerDirectives2Builder::default()
            // Ignore clipped member 'percent_auto_underscore_newline_underscore_off'
            .build()
            .into_diagnostic()?;
        let scanner_directives_2_built =
            ScannerDirectives::ScannerDirectives2(scanner_directives_2_built);
        // Calling user action here
        self.user_grammar
            .scanner_directives(&scanner_directives_2_built)?;
        self.push(
            ASTType::ScannerDirectives(scanner_directives_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// ScannerDirectives: "%auto_ws_off"^ /* Clipped */;
    ///
    #[named]
    fn scanner_directives_3(
        &mut self,
        _percent_auto_underscore_ws_underscore_off: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_directives_3_built = ScannerDirectives3Builder::default()
            // Ignore clipped member 'percent_auto_underscore_ws_underscore_off'
            .build()
            .into_diagnostic()?;
        let scanner_directives_3_built =
            ScannerDirectives::ScannerDirectives3(scanner_directives_3_built);
        // Calling user action here
        self.user_grammar
            .scanner_directives(&scanner_directives_3_built)?;
        self.push(
            ASTType::ScannerDirectives(scanner_directives_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// GrammarDefinition: "%%"^ /* Clipped */ Production GrammarDefinitionList /* Vec */;
    ///
    #[named]
    fn grammar_definition(
        &mut self,
        _percent_percent: &ParseTreeStackEntry<'t>,
        _production: &ParseTreeStackEntry<'t>,
        _grammar_definition_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let grammar_definition_list =
            if let Some(ASTType::GrammarDefinitionList(mut grammar_definition_list)) =
                self.pop(context)
            {
                grammar_definition_list.reverse();
                grammar_definition_list
            } else {
                bail!("{}: Expecting ASTType::GrammarDefinitionList", context);
            };
        let production = if let Some(ASTType::Production(production)) = self.pop(context) {
            production
        } else {
            bail!("{}: Expecting ASTType::Production", context);
        };
        let grammar_definition_built = GrammarDefinitionBuilder::default()
            // Ignore clipped member 'percent_percent'
            .production(Box::new(production))
            .grammar_definition_list(grammar_definition_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .grammar_definition(&grammar_definition_built)?;
        self.push(
            ASTType::GrammarDefinition(grammar_definition_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// GrammarDefinitionList: Production GrammarDefinitionList; // Vec<T>::Push
    ///
    #[named]
    fn grammar_definition_list_0(
        &mut self,
        _production: &ParseTreeStackEntry<'t>,
        _grammar_definition_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut grammar_definition_list = if let Some(ASTType::GrammarDefinitionList(
            grammar_definition_list,
        )) = self.pop(context)
        {
            grammar_definition_list
        } else {
            bail!("{}: Expecting ASTType::GrammarDefinitionList", context);
        };
        let production = if let Some(ASTType::Production(production)) = self.pop(context) {
            production
        } else {
            bail!("{}: Expecting ASTType::Production", context);
        };
        let grammar_definition_list_0_built = GrammarDefinitionListBuilder::default()
            .production(Box::new(production))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        grammar_definition_list.push(grammar_definition_list_0_built);
        self.push(
            ASTType::GrammarDefinitionList(grammar_definition_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// GrammarDefinitionList: ; // Vec<T>::New
    ///
    #[named]
    fn grammar_definition_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let grammar_definition_list_1_built = Vec::new();
        self.push(
            ASTType::GrammarDefinitionList(grammar_definition_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// DoubleColon: "::";
    ///
    #[named]
    fn double_colon(
        &mut self,
        double_colon: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let double_colon = *double_colon.token(parse_tree)?;
        let double_colon_built = DoubleColonBuilder::default()
            .double_colon(double_colon)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.double_colon(&double_colon_built)?;
        self.push(ASTType::DoubleColon(double_colon_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// Production: Identifier ":"^ /* Clipped */ Alternations ";"^ /* Clipped */;
    ///
    #[named]
    fn production(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _alternations: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alternations = if let Some(ASTType::Alternations(alternations)) = self.pop(context) {
            alternations
        } else {
            bail!("{}: Expecting ASTType::Alternations", context);
        };
        let identifier = if let Some(ASTType::Identifier(identifier)) = self.pop(context) {
            identifier
        } else {
            bail!("{}: Expecting ASTType::Identifier", context);
        };
        let production_built = ProductionBuilder::default()
            .identifier(Box::new(identifier))
            // Ignore clipped member 'colon'
            .alternations(Box::new(alternations))
            // Ignore clipped member 'semicolon'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.production(&production_built)?;
        self.push(ASTType::Production(production_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// Alternations: Alternation AlternationsList /* Vec */;
    ///
    #[named]
    fn alternations(
        &mut self,
        _alternation: &ParseTreeStackEntry<'t>,
        _alternations_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alternations_list =
            if let Some(ASTType::AlternationsList(mut alternations_list)) = self.pop(context) {
                alternations_list.reverse();
                alternations_list
            } else {
                bail!("{}: Expecting ASTType::AlternationsList", context);
            };
        let alternation = if let Some(ASTType::Alternation(alternation)) = self.pop(context) {
            alternation
        } else {
            bail!("{}: Expecting ASTType::Alternation", context);
        };
        let alternations_built = AlternationsBuilder::default()
            .alternation(Box::new(alternation))
            .alternations_list(alternations_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.alternations(&alternations_built)?;
        self.push(ASTType::Alternations(alternations_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// AlternationsList: "\|"^ /* Clipped */ Alternation AlternationsList; // Vec<T>::Push
    ///
    #[named]
    fn alternations_list_0(
        &mut self,
        _or: &ParseTreeStackEntry<'t>,
        _alternation: &ParseTreeStackEntry<'t>,
        _alternations_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut alternations_list =
            if let Some(ASTType::AlternationsList(alternations_list)) = self.pop(context) {
                alternations_list
            } else {
                bail!("{}: Expecting ASTType::AlternationsList", context);
            };
        let alternation = if let Some(ASTType::Alternation(alternation)) = self.pop(context) {
            alternation
        } else {
            bail!("{}: Expecting ASTType::Alternation", context);
        };
        let alternations_list_0_built = AlternationsListBuilder::default()
            .alternation(Box::new(alternation))
            // Ignore clipped member 'or'
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        alternations_list.push(alternations_list_0_built);
        self.push(ASTType::AlternationsList(alternations_list), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// AlternationsList: ; // Vec<T>::New
    ///
    #[named]
    fn alternations_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alternations_list_1_built = Vec::new();
        self.push(
            ASTType::AlternationsList(alternations_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// Alternation: AlternationList /* Vec */;
    ///
    #[named]
    fn alternation(
        &mut self,
        _alternation_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alternation_list =
            if let Some(ASTType::AlternationList(mut alternation_list)) = self.pop(context) {
                alternation_list.reverse();
                alternation_list
            } else {
                bail!("{}: Expecting ASTType::AlternationList", context);
            };
        let alternation_built = AlternationBuilder::default()
            .alternation_list(alternation_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.alternation(&alternation_built)?;
        self.push(ASTType::Alternation(alternation_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// AlternationList: Factor AlternationList; // Vec<T>::Push
    ///
    #[named]
    fn alternation_list_0(
        &mut self,
        _factor: &ParseTreeStackEntry<'t>,
        _alternation_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut alternation_list =
            if let Some(ASTType::AlternationList(alternation_list)) = self.pop(context) {
                alternation_list
            } else {
                bail!("{}: Expecting ASTType::AlternationList", context);
            };
        let factor = if let Some(ASTType::Factor(factor)) = self.pop(context) {
            factor
        } else {
            bail!("{}: Expecting ASTType::Factor", context);
        };
        let alternation_list_0_built = AlternationListBuilder::default()
            .factor(Box::new(factor))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        alternation_list.push(alternation_list_0_built);
        self.push(ASTType::AlternationList(alternation_list), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// AlternationList: ; // Vec<T>::New
    ///
    #[named]
    fn alternation_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alternation_list_1_built = Vec::new();
        self.push(ASTType::AlternationList(alternation_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// Factor: Group;
    ///
    #[named]
    fn factor_0(
        &mut self,
        _group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let group = if let Some(ASTType::Group(group)) = self.pop(context) {
            group
        } else {
            bail!("{}: Expecting ASTType::Group", context);
        };
        let factor_0_built = Factor0Builder::default()
            .group(Box::new(group))
            .build()
            .into_diagnostic()?;
        let factor_0_built = Factor::Factor0(factor_0_built);
        // Calling user action here
        self.user_grammar.factor(&factor_0_built)?;
        self.push(ASTType::Factor(factor_0_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// Factor: Repeat;
    ///
    #[named]
    fn factor_1(
        &mut self,
        _repeat: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let repeat = if let Some(ASTType::Repeat(repeat)) = self.pop(context) {
            repeat
        } else {
            bail!("{}: Expecting ASTType::Repeat", context);
        };
        let factor_1_built = Factor1Builder::default()
            .repeat(Box::new(repeat))
            .build()
            .into_diagnostic()?;
        let factor_1_built = Factor::Factor1(factor_1_built);
        // Calling user action here
        self.user_grammar.factor(&factor_1_built)?;
        self.push(ASTType::Factor(factor_1_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// Factor: Optional;
    ///
    #[named]
    fn factor_2(
        &mut self,
        _optional: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let optional = if let Some(ASTType::Optional(optional)) = self.pop(context) {
            optional
        } else {
            bail!("{}: Expecting ASTType::Optional", context);
        };
        let factor_2_built = Factor2Builder::default()
            .optional(Box::new(optional))
            .build()
            .into_diagnostic()?;
        let factor_2_built = Factor::Factor2(factor_2_built);
        // Calling user action here
        self.user_grammar.factor(&factor_2_built)?;
        self.push(ASTType::Factor(factor_2_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// Factor: Symbol;
    ///
    #[named]
    fn factor_3(
        &mut self,
        _symbol: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let symbol = if let Some(ASTType::Symbol(symbol)) = self.pop(context) {
            symbol
        } else {
            bail!("{}: Expecting ASTType::Symbol", context);
        };
        let factor_3_built = Factor3Builder::default()
            .symbol(Box::new(symbol))
            .build()
            .into_diagnostic()?;
        let factor_3_built = Factor::Factor3(factor_3_built);
        // Calling user action here
        self.user_grammar.factor(&factor_3_built)?;
        self.push(ASTType::Factor(factor_3_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// Symbol: NonTerminal;
    ///
    #[named]
    fn symbol_0(
        &mut self,
        _non_terminal: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let non_terminal = if let Some(ASTType::NonTerminal(non_terminal)) = self.pop(context) {
            non_terminal
        } else {
            bail!("{}: Expecting ASTType::NonTerminal", context);
        };
        let symbol_0_built = Symbol0Builder::default()
            .non_terminal(Box::new(non_terminal))
            .build()
            .into_diagnostic()?;
        let symbol_0_built = Symbol::Symbol0(symbol_0_built);
        // Calling user action here
        self.user_grammar.symbol(&symbol_0_built)?;
        self.push(ASTType::Symbol(symbol_0_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// Symbol: SimpleToken;
    ///
    #[named]
    fn symbol_1(
        &mut self,
        _simple_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_token = if let Some(ASTType::SimpleToken(simple_token)) = self.pop(context) {
            simple_token
        } else {
            bail!("{}: Expecting ASTType::SimpleToken", context);
        };
        let symbol_1_built = Symbol1Builder::default()
            .simple_token(Box::new(simple_token))
            .build()
            .into_diagnostic()?;
        let symbol_1_built = Symbol::Symbol1(symbol_1_built);
        // Calling user action here
        self.user_grammar.symbol(&symbol_1_built)?;
        self.push(ASTType::Symbol(symbol_1_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// Symbol: TokenWithStates;
    ///
    #[named]
    fn symbol_2(
        &mut self,
        _token_with_states: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let token_with_states =
            if let Some(ASTType::TokenWithStates(token_with_states)) = self.pop(context) {
                token_with_states
            } else {
                bail!("{}: Expecting ASTType::TokenWithStates", context);
            };
        let symbol_2_built = Symbol2Builder::default()
            .token_with_states(Box::new(token_with_states))
            .build()
            .into_diagnostic()?;
        let symbol_2_built = Symbol::Symbol2(symbol_2_built);
        // Calling user action here
        self.user_grammar.symbol(&symbol_2_built)?;
        self.push(ASTType::Symbol(symbol_2_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// Symbol: ScannerSwitch;
    ///
    #[named]
    fn symbol_3(
        &mut self,
        _scanner_switch: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_switch = if let Some(ASTType::ScannerSwitch(scanner_switch)) = self.pop(context)
        {
            scanner_switch
        } else {
            bail!("{}: Expecting ASTType::ScannerSwitch", context);
        };
        let symbol_3_built = Symbol3Builder::default()
            .scanner_switch(Box::new(scanner_switch))
            .build()
            .into_diagnostic()?;
        let symbol_3_built = Symbol::Symbol3(symbol_3_built);
        // Calling user action here
        self.user_grammar.symbol(&symbol_3_built)?;
        self.push(ASTType::Symbol(symbol_3_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// SimpleToken: String SimpleTokenOpt /* Option */;
    ///
    #[named]
    fn simple_token(
        &mut self,
        _string: &ParseTreeStackEntry<'t>,
        _simple_token_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_token_opt =
            if let Some(ASTType::SimpleTokenOpt(simple_token_opt)) = self.pop(context) {
                simple_token_opt
            } else {
                bail!("{}: Expecting ASTType::SimpleTokenOpt", context);
            };
        let string = if let Some(ASTType::String(string)) = self.pop(context) {
            string
        } else {
            bail!("{}: Expecting ASTType::String", context);
        };
        let simple_token_built = SimpleTokenBuilder::default()
            .string(Box::new(string))
            .simple_token_opt(simple_token_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.simple_token(&simple_token_built)?;
        self.push(ASTType::SimpleToken(simple_token_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// SimpleTokenOpt: ASTControl; // Option<T>::Some
    ///
    #[named]
    fn simple_token_opt_0(
        &mut self,
        _a_s_t_control: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let a_s_t_control = if let Some(ASTType::ASTControl(a_s_t_control)) = self.pop(context) {
            a_s_t_control
        } else {
            bail!("{}: Expecting ASTType::ASTControl", context);
        };
        let simple_token_opt_0_built = SimpleTokenOptBuilder::default()
            .a_s_t_control(Box::new(a_s_t_control))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::SimpleTokenOpt(Some(Box::new(simple_token_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// SimpleTokenOpt: ; // Option<T>::None
    ///
    #[named]
    fn simple_token_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SimpleTokenOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// TokenWithStates: "<"^ /* Clipped */ StateList ">"^ /* Clipped */ String TokenWithStatesOpt /* Option */;
    ///
    #[named]
    fn token_with_states(
        &mut self,
        _l_t: &ParseTreeStackEntry<'t>,
        _state_list: &ParseTreeStackEntry<'t>,
        _g_t: &ParseTreeStackEntry<'t>,
        _string: &ParseTreeStackEntry<'t>,
        _token_with_states_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let token_with_states_opt =
            if let Some(ASTType::TokenWithStatesOpt(token_with_states_opt)) = self.pop(context) {
                token_with_states_opt
            } else {
                bail!("{}: Expecting ASTType::TokenWithStatesOpt", context);
            };
        let string = if let Some(ASTType::String(string)) = self.pop(context) {
            string
        } else {
            bail!("{}: Expecting ASTType::String", context);
        };
        let state_list = if let Some(ASTType::StateList(state_list)) = self.pop(context) {
            state_list
        } else {
            bail!("{}: Expecting ASTType::StateList", context);
        };
        let token_with_states_built = TokenWithStatesBuilder::default()
            // Ignore clipped member 'l_t'
            .state_list(Box::new(state_list))
            // Ignore clipped member 'g_t'
            .string(Box::new(string))
            .token_with_states_opt(token_with_states_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .token_with_states(&token_with_states_built)?;
        self.push(ASTType::TokenWithStates(token_with_states_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// TokenWithStatesOpt: ASTControl; // Option<T>::Some
    ///
    #[named]
    fn token_with_states_opt_0(
        &mut self,
        _a_s_t_control: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let a_s_t_control = if let Some(ASTType::ASTControl(a_s_t_control)) = self.pop(context) {
            a_s_t_control
        } else {
            bail!("{}: Expecting ASTType::ASTControl", context);
        };
        let token_with_states_opt_0_built = TokenWithStatesOptBuilder::default()
            .a_s_t_control(Box::new(a_s_t_control))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::TokenWithStatesOpt(Some(Box::new(token_with_states_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// TokenWithStatesOpt: ; // Option<T>::None
    ///
    #[named]
    fn token_with_states_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TokenWithStatesOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// Group: "\("^ /* Clipped */ Alternations "\)"^ /* Clipped */;
    ///
    #[named]
    fn group(
        &mut self,
        _l_paren: &ParseTreeStackEntry<'t>,
        _alternations: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alternations = if let Some(ASTType::Alternations(alternations)) = self.pop(context) {
            alternations
        } else {
            bail!("{}: Expecting ASTType::Alternations", context);
        };
        let group_built = GroupBuilder::default()
            // Ignore clipped member 'l_paren'
            .alternations(Box::new(alternations))
            // Ignore clipped member 'r_paren'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.group(&group_built)?;
        self.push(ASTType::Group(group_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// Optional: "\["^ /* Clipped */ Alternations "\]"^ /* Clipped */;
    ///
    #[named]
    fn optional(
        &mut self,
        _l_bracket: &ParseTreeStackEntry<'t>,
        _alternations: &ParseTreeStackEntry<'t>,
        _r_bracket: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alternations = if let Some(ASTType::Alternations(alternations)) = self.pop(context) {
            alternations
        } else {
            bail!("{}: Expecting ASTType::Alternations", context);
        };
        let optional_built = OptionalBuilder::default()
            // Ignore clipped member 'l_bracket'
            .alternations(Box::new(alternations))
            // Ignore clipped member 'r_bracket'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.optional(&optional_built)?;
        self.push(ASTType::Optional(optional_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// Repeat: "\{"^ /* Clipped */ Alternations "\}"^ /* Clipped */;
    ///
    #[named]
    fn repeat(
        &mut self,
        _l_brace: &ParseTreeStackEntry<'t>,
        _alternations: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alternations = if let Some(ASTType::Alternations(alternations)) = self.pop(context) {
            alternations
        } else {
            bail!("{}: Expecting ASTType::Alternations", context);
        };
        let repeat_built = RepeatBuilder::default()
            // Ignore clipped member 'l_brace'
            .alternations(Box::new(alternations))
            // Ignore clipped member 'r_brace'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.repeat(&repeat_built)?;
        self.push(ASTType::Repeat(repeat_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// NonTerminal: Identifier NonTerminalOpt /* Option */;
    ///
    #[named]
    fn non_terminal(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _non_terminal_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let non_terminal_opt =
            if let Some(ASTType::NonTerminalOpt(non_terminal_opt)) = self.pop(context) {
                non_terminal_opt
            } else {
                bail!("{}: Expecting ASTType::NonTerminalOpt", context);
            };
        let identifier = if let Some(ASTType::Identifier(identifier)) = self.pop(context) {
            identifier
        } else {
            bail!("{}: Expecting ASTType::Identifier", context);
        };
        let non_terminal_built = NonTerminalBuilder::default()
            .identifier(Box::new(identifier))
            .non_terminal_opt(non_terminal_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.non_terminal(&non_terminal_built)?;
        self.push(ASTType::NonTerminal(non_terminal_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// NonTerminalOpt: CutOperator; // Option<T>::Some
    ///
    #[named]
    fn non_terminal_opt_0(
        &mut self,
        _cut_operator: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let cut_operator = if let Some(ASTType::CutOperator(cut_operator)) = self.pop(context) {
            cut_operator
        } else {
            bail!("{}: Expecting ASTType::CutOperator", context);
        };
        let non_terminal_opt_0_built = NonTerminalOptBuilder::default()
            .cut_operator(Box::new(cut_operator))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::NonTerminalOpt(Some(Box::new(non_terminal_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// NonTerminalOpt: ; // Option<T>::None
    ///
    #[named]
    fn non_terminal_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::NonTerminalOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// Identifier: "[a-zA-Z_][a-zA-Z0-9_]*";
    ///
    #[named]
    fn identifier(
        &mut self,
        identifier: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = *identifier.token(parse_tree)?;
        let identifier_built = IdentifierBuilder::default()
            .identifier(identifier)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.identifier(&identifier_built)?;
        self.push(ASTType::Identifier(identifier_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// String: "\u{0022}([^\\]|\\.)*?\u{0022}";
    ///
    #[named]
    fn string(
        &mut self,
        string: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = *string.token(parse_tree)?;
        let string_built = StringBuilder::default()
            .string(string)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.string(&string_built)?;
        self.push(ASTType::String(string_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// ScannerState: "%scanner"^ /* Clipped */ Identifier "\{"^ /* Clipped */ ScannerStateList /* Vec */ "\}"^ /* Clipped */;
    ///
    #[named]
    fn scanner_state(
        &mut self,
        _percent_scanner: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _scanner_state_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_state_list =
            if let Some(ASTType::ScannerStateList(mut scanner_state_list)) = self.pop(context) {
                scanner_state_list.reverse();
                scanner_state_list
            } else {
                bail!("{}: Expecting ASTType::ScannerStateList", context);
            };
        let identifier = if let Some(ASTType::Identifier(identifier)) = self.pop(context) {
            identifier
        } else {
            bail!("{}: Expecting ASTType::Identifier", context);
        };
        let scanner_state_built = ScannerStateBuilder::default()
            // Ignore clipped member 'percent_scanner'
            .identifier(Box::new(identifier))
            // Ignore clipped member 'l_brace'
            .scanner_state_list(scanner_state_list)
            // Ignore clipped member 'r_brace'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.scanner_state(&scanner_state_built)?;
        self.push(ASTType::ScannerState(scanner_state_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// ScannerStateList: ScannerDirectives ScannerStateList; // Vec<T>::Push
    ///
    #[named]
    fn scanner_state_list_0(
        &mut self,
        _scanner_directives: &ParseTreeStackEntry<'t>,
        _scanner_state_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut scanner_state_list =
            if let Some(ASTType::ScannerStateList(scanner_state_list)) = self.pop(context) {
                scanner_state_list
            } else {
                bail!("{}: Expecting ASTType::ScannerStateList", context);
            };
        let scanner_directives =
            if let Some(ASTType::ScannerDirectives(scanner_directives)) = self.pop(context) {
                scanner_directives
            } else {
                bail!("{}: Expecting ASTType::ScannerDirectives", context);
            };
        let scanner_state_list_0_built = ScannerStateListBuilder::default()
            .scanner_directives(Box::new(scanner_directives))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        scanner_state_list.push(scanner_state_list_0_built);
        self.push(ASTType::ScannerStateList(scanner_state_list), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// ScannerStateList: ; // Vec<T>::New
    ///
    #[named]
    fn scanner_state_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_state_list_1_built = Vec::new();
        self.push(
            ASTType::ScannerStateList(scanner_state_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// StateList: Identifier StateListList /* Vec */;
    ///
    #[named]
    fn state_list(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _state_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let state_list_list =
            if let Some(ASTType::StateListList(mut state_list_list)) = self.pop(context) {
                state_list_list.reverse();
                state_list_list
            } else {
                bail!("{}: Expecting ASTType::StateListList", context);
            };
        let identifier = if let Some(ASTType::Identifier(identifier)) = self.pop(context) {
            identifier
        } else {
            bail!("{}: Expecting ASTType::Identifier", context);
        };
        let state_list_built = StateListBuilder::default()
            .identifier(Box::new(identifier))
            .state_list_list(state_list_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.state_list(&state_list_built)?;
        self.push(ASTType::StateList(state_list_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// StateListList: ","^ /* Clipped */ Identifier StateListList; // Vec<T>::Push
    ///
    #[named]
    fn state_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _state_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut state_list_list =
            if let Some(ASTType::StateListList(state_list_list)) = self.pop(context) {
                state_list_list
            } else {
                bail!("{}: Expecting ASTType::StateListList", context);
            };
        let identifier = if let Some(ASTType::Identifier(identifier)) = self.pop(context) {
            identifier
        } else {
            bail!("{}: Expecting ASTType::Identifier", context);
        };
        let state_list_list_0_built = StateListListBuilder::default()
            .identifier(Box::new(identifier))
            // Ignore clipped member 'comma'
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        state_list_list.push(state_list_list_0_built);
        self.push(ASTType::StateListList(state_list_list), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// StateListList: ; // Vec<T>::New
    ///
    #[named]
    fn state_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let state_list_list_1_built = Vec::new();
        self.push(ASTType::StateListList(state_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// ScannerSwitch: "%sc"^ /* Clipped */ "\("^ /* Clipped */ ScannerSwitchOpt /* Option */ "\)"^ /* Clipped */;
    ///
    #[named]
    fn scanner_switch_0(
        &mut self,
        _percent_sc: &ParseTreeStackEntry<'t>,
        _l_paren: &ParseTreeStackEntry<'t>,
        _scanner_switch_opt: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_switch_opt =
            if let Some(ASTType::ScannerSwitchOpt(scanner_switch_opt)) = self.pop(context) {
                scanner_switch_opt
            } else {
                bail!("{}: Expecting ASTType::ScannerSwitchOpt", context);
            };
        let scanner_switch_0_built = ScannerSwitch0Builder::default()
            // Ignore clipped member 'percent_sc'
            // Ignore clipped member 'l_paren'
            .scanner_switch_opt(scanner_switch_opt)
            // Ignore clipped member 'r_paren'
            .build()
            .into_diagnostic()?;
        let scanner_switch_0_built = ScannerSwitch::ScannerSwitch0(scanner_switch_0_built);
        // Calling user action here
        self.user_grammar.scanner_switch(&scanner_switch_0_built)?;
        self.push(ASTType::ScannerSwitch(scanner_switch_0_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// ScannerSwitch: "%push"^ /* Clipped */ "\("^ /* Clipped */ Identifier "\)"^ /* Clipped */;
    ///
    #[named]
    fn scanner_switch_1(
        &mut self,
        _percent_push: &ParseTreeStackEntry<'t>,
        _l_paren: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = if let Some(ASTType::Identifier(identifier)) = self.pop(context) {
            identifier
        } else {
            bail!("{}: Expecting ASTType::Identifier", context);
        };
        let scanner_switch_1_built = ScannerSwitch1Builder::default()
            // Ignore clipped member 'percent_push'
            // Ignore clipped member 'l_paren'
            .identifier(Box::new(identifier))
            // Ignore clipped member 'r_paren'
            .build()
            .into_diagnostic()?;
        let scanner_switch_1_built = ScannerSwitch::ScannerSwitch1(scanner_switch_1_built);
        // Calling user action here
        self.user_grammar.scanner_switch(&scanner_switch_1_built)?;
        self.push(ASTType::ScannerSwitch(scanner_switch_1_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// ScannerSwitch: "%pop"^ /* Clipped */ "\("^ /* Clipped */ "\)"^ /* Clipped */;
    ///
    #[named]
    fn scanner_switch_2(
        &mut self,
        _percent_pop: &ParseTreeStackEntry<'t>,
        _l_paren: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_switch_2_built = ScannerSwitch2Builder::default()
            // Ignore clipped member 'percent_pop'
            // Ignore clipped member 'l_paren'
            // Ignore clipped member 'r_paren'
            .build()
            .into_diagnostic()?;
        let scanner_switch_2_built = ScannerSwitch::ScannerSwitch2(scanner_switch_2_built);
        // Calling user action here
        self.user_grammar.scanner_switch(&scanner_switch_2_built)?;
        self.push(ASTType::ScannerSwitch(scanner_switch_2_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// ScannerSwitchOpt: Identifier; // Option<T>::Some
    ///
    #[named]
    fn scanner_switch_opt_0(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = if let Some(ASTType::Identifier(identifier)) = self.pop(context) {
            identifier
        } else {
            bail!("{}: Expecting ASTType::Identifier", context);
        };
        let scanner_switch_opt_0_built = ScannerSwitchOptBuilder::default()
            .identifier(Box::new(identifier))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ScannerSwitchOpt(Some(Box::new(scanner_switch_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// ScannerSwitchOpt: ; // Option<T>::None
    ///
    #[named]
    fn scanner_switch_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ScannerSwitchOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// ASTControl: CutOperator;
    ///
    #[named]
    fn a_s_t_control_0(
        &mut self,
        _cut_operator: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let cut_operator = if let Some(ASTType::CutOperator(cut_operator)) = self.pop(context) {
            cut_operator
        } else {
            bail!("{}: Expecting ASTType::CutOperator", context);
        };
        let a_s_t_control_0_built = ASTControl0Builder::default()
            .cut_operator(Box::new(cut_operator))
            .build()
            .into_diagnostic()?;
        let a_s_t_control_0_built = ASTControl::ASTControl0(a_s_t_control_0_built);
        // Calling user action here
        self.user_grammar.a_s_t_control(&a_s_t_control_0_built)?;
        self.push(ASTType::ASTControl(a_s_t_control_0_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// ASTControl: UserTypeDeclaration;
    ///
    #[named]
    fn a_s_t_control_1(
        &mut self,
        _user_type_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let user_type_declaration =
            if let Some(ASTType::UserTypeDeclaration(user_type_declaration)) = self.pop(context) {
                user_type_declaration
            } else {
                bail!("{}: Expecting ASTType::UserTypeDeclaration", context);
            };
        let a_s_t_control_1_built = ASTControl1Builder::default()
            .user_type_declaration(Box::new(user_type_declaration))
            .build()
            .into_diagnostic()?;
        let a_s_t_control_1_built = ASTControl::ASTControl1(a_s_t_control_1_built);
        // Calling user action here
        self.user_grammar.a_s_t_control(&a_s_t_control_1_built)?;
        self.push(ASTType::ASTControl(a_s_t_control_1_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// CutOperator: "\^"^ /* Clipped */;
    ///
    #[named]
    fn cut_operator(
        &mut self,
        _cut_operator: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let cut_operator_built = CutOperatorBuilder::default()
            // Ignore clipped member 'cut_operator'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.cut_operator(&cut_operator_built)?;
        self.push(ASTType::CutOperator(cut_operator_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// UserTypeDeclaration: ":"^ /* Clipped */ UserTypeName;
    ///
    #[named]
    fn user_type_declaration(
        &mut self,
        _colon: &ParseTreeStackEntry<'t>,
        _user_type_name: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let user_type_name = if let Some(ASTType::UserTypeName(user_type_name)) = self.pop(context)
        {
            user_type_name
        } else {
            bail!("{}: Expecting ASTType::UserTypeName", context);
        };
        let user_type_declaration_built = UserTypeDeclarationBuilder::default()
            // Ignore clipped member 'colon'
            .user_type_name(Box::new(user_type_name))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .user_type_declaration(&user_type_declaration_built)?;
        self.push(
            ASTType::UserTypeDeclaration(user_type_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// UserTypeName: Identifier UserTypeNameList /* Vec */;
    ///
    #[named]
    fn user_type_name(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _user_type_name_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let user_type_name_list =
            if let Some(ASTType::UserTypeNameList(mut user_type_name_list)) = self.pop(context) {
                user_type_name_list.reverse();
                user_type_name_list
            } else {
                bail!("{}: Expecting ASTType::UserTypeNameList", context);
            };
        let identifier = if let Some(ASTType::Identifier(identifier)) = self.pop(context) {
            identifier
        } else {
            bail!("{}: Expecting ASTType::Identifier", context);
        };
        let user_type_name_built = UserTypeNameBuilder::default()
            .identifier(Box::new(identifier))
            .user_type_name_list(user_type_name_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.user_type_name(&user_type_name_built)?;
        self.push(ASTType::UserTypeName(user_type_name_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// UserTypeNameList: DoubleColon^ /* Clipped */ Identifier UserTypeNameList; // Vec<T>::Push
    ///
    #[named]
    fn user_type_name_list_0(
        &mut self,
        _double_colon: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _user_type_name_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut user_type_name_list =
            if let Some(ASTType::UserTypeNameList(user_type_name_list)) = self.pop(context) {
                user_type_name_list
            } else {
                bail!("{}: Expecting ASTType::UserTypeNameList", context);
            };
        let identifier = if let Some(ASTType::Identifier(identifier)) = self.pop(context) {
            identifier
        } else {
            bail!("{}: Expecting ASTType::Identifier", context);
        };
        // Ignore clipped member 'double_colon'
        self.pop(context);
        let user_type_name_list_0_built = UserTypeNameListBuilder::default()
            .identifier(Box::new(identifier))
            // Ignore clipped member 'double_colon'
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        user_type_name_list.push(user_type_name_list_0_built);
        self.push(ASTType::UserTypeNameList(user_type_name_list), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// UserTypeNameList: ; // Vec<T>::New
    ///
    #[named]
    fn user_type_name_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let user_type_name_list_1_built = Vec::new();
        self.push(
            ASTType::UserTypeNameList(user_type_name_list_1_built),
            context,
        );
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for ParolGrammarAuto<'t, '_> {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// It is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, file_name: &Path) {
        self.file_name = file_name.to_owned();
        self.user_grammar.init(file_name);
    }

    ///
    /// This function is implemented automatically for the user's item ParolGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.parol(&children[0], &children[1], parse_tree),
            1 => self.prolog(&children[0], &children[1], &children[2], parse_tree),
            2 => self.prolog_list0_0(&children[0], &children[1], parse_tree),
            3 => self.prolog_list0_1(parse_tree),
            4 => self.prolog_list_0(&children[0], &children[1], parse_tree),
            5 => self.prolog_list_1(parse_tree),
            6 => self.start_declaration(&children[0], &children[1], parse_tree),
            7 => self.declaration_0(&children[0], &children[1], parse_tree),
            8 => self.declaration_1(&children[0], &children[1], parse_tree),
            9 => self.declaration_2(&children[0], parse_tree),
            10 => self.scanner_directives_0(&children[0], &children[1], parse_tree),
            11 => self.scanner_directives_1(&children[0], &children[1], &children[2], parse_tree),
            12 => self.scanner_directives_2(&children[0], parse_tree),
            13 => self.scanner_directives_3(&children[0], parse_tree),
            14 => self.grammar_definition(&children[0], &children[1], &children[2], parse_tree),
            15 => self.grammar_definition_list_0(&children[0], &children[1], parse_tree),
            16 => self.grammar_definition_list_1(parse_tree),
            17 => self.double_colon(&children[0], parse_tree),
            18 => self.production(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            19 => self.alternations(&children[0], &children[1], parse_tree),
            20 => self.alternations_list_0(&children[0], &children[1], &children[2], parse_tree),
            21 => self.alternations_list_1(parse_tree),
            22 => self.alternation(&children[0], parse_tree),
            23 => self.alternation_list_0(&children[0], &children[1], parse_tree),
            24 => self.alternation_list_1(parse_tree),
            25 => self.factor_0(&children[0], parse_tree),
            26 => self.factor_1(&children[0], parse_tree),
            27 => self.factor_2(&children[0], parse_tree),
            28 => self.factor_3(&children[0], parse_tree),
            29 => self.symbol_0(&children[0], parse_tree),
            30 => self.symbol_1(&children[0], parse_tree),
            31 => self.symbol_2(&children[0], parse_tree),
            32 => self.symbol_3(&children[0], parse_tree),
            33 => self.simple_token(&children[0], &children[1], parse_tree),
            34 => self.simple_token_opt_0(&children[0], parse_tree),
            35 => self.simple_token_opt_1(parse_tree),
            36 => self.token_with_states(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            37 => self.token_with_states_opt_0(&children[0], parse_tree),
            38 => self.token_with_states_opt_1(parse_tree),
            39 => self.group(&children[0], &children[1], &children[2], parse_tree),
            40 => self.optional(&children[0], &children[1], &children[2], parse_tree),
            41 => self.repeat(&children[0], &children[1], &children[2], parse_tree),
            42 => self.non_terminal(&children[0], &children[1], parse_tree),
            43 => self.non_terminal_opt_0(&children[0], parse_tree),
            44 => self.non_terminal_opt_1(parse_tree),
            45 => self.identifier(&children[0], parse_tree),
            46 => self.string(&children[0], parse_tree),
            47 => self.scanner_state(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            48 => self.scanner_state_list_0(&children[0], &children[1], parse_tree),
            49 => self.scanner_state_list_1(parse_tree),
            50 => self.state_list(&children[0], &children[1], parse_tree),
            51 => self.state_list_list_0(&children[0], &children[1], &children[2], parse_tree),
            52 => self.state_list_list_1(parse_tree),
            53 => self.scanner_switch_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            54 => self.scanner_switch_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            55 => self.scanner_switch_2(&children[0], &children[1], &children[2], parse_tree),
            56 => self.scanner_switch_opt_0(&children[0], parse_tree),
            57 => self.scanner_switch_opt_1(parse_tree),
            58 => self.a_s_t_control_0(&children[0], parse_tree),
            59 => self.a_s_t_control_1(&children[0], parse_tree),
            60 => self.cut_operator(&children[0], parse_tree),
            61 => self.user_type_declaration(&children[0], &children[1], parse_tree),
            62 => self.user_type_name(&children[0], &children[1], parse_tree),
            63 => self.user_type_name_list_0(&children[0], &children[1], &children[2], parse_tree),
            64 => self.user_type_name_list_1(parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
