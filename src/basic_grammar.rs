use crate::{
    basic_grammar_trait::*,
    errors::BasicError,
    operators::{BinaryOperator, UnaryOperator},
};
use log::trace;
#[allow(unused_imports)]
use miette::{miette, Result, WrapErr};
use parol_runtime::{errors::FileSource, lexer::Token};
use std::{
    collections::BTreeMap,
    fmt::{Debug, Display, Error, Formatter},
    marker::PhantomData,
    path::{Path, PathBuf},
};

///
/// The value range for the supported calculations
///
pub type DefinitionRange = f32;

///
/// The value range for line numbers
///
pub type LineNumberRange = u16;

const MAX_LINE_NUMBER: u16 = 63999;

#[derive(Debug)]
struct CompiledLine<'a, 't>
where
    't: 'a,
{
    statements: Vec<&'a Statement<'t>>,
    next_line: Option<LineNumberRange>,
}

#[derive(Debug, Default)]
pub struct BasicLines<'a, 't> {
    lines: BTreeMap<u16, CompiledLine<'a, 't>>,
}

///
/// Data structure that implements the semantic actions for our Basic grammar
///
#[derive(Debug, Default)]
pub struct BasicGrammar<'t> {
    pub env: BTreeMap<String, DefinitionRange>,
    file_name: PathBuf,
    next_line: Option<LineNumberRange>,
    last_line: Option<LineNumberRange>,
    phantom: PhantomData<&'t str>, // Just to hold the lifetime generated by parol
}

impl<'t> BasicGrammar<'t> {
    pub fn new() -> Self {
        BasicGrammar::default()
    }

    fn value(&self, context: &str, id: &Token<'t>) -> Result<DefinitionRange> {
        let name: &str = if id.symbol.len() < 2 {
            id.symbol
        } else {
            &id.symbol[..2]
        };
        let value = self.env.get(name).cloned().unwrap_or_default();
        trace!("value @ {context}: {name} = {value}");
        Ok(value)
    }

    fn set_value(&mut self, id: &str, context: &str, value: DefinitionRange) {
        let name: &str = if id.len() < 2 { id } else { &id[..2] };
        trace!("set_value @ {context}: {name} = {value}");
        self.env.insert(name.to_owned(), value);
    }

    fn parse_number(&self, context: &str, token: &Token<'t>) -> Result<DefinitionRange> {
        let symbol = token.symbol.replace(' ', "").replace('E', "e");
        match symbol.parse::<DefinitionRange>() {
            Ok(number) => Ok(number),
            Err(error) => Err(miette!(BasicError::ParseFloat {
                context: context.to_owned(),
                input: FileSource::try_new(self.file_name.clone())?.into(),
                token: token.into()
            }))
            .wrap_err(miette!(error)),
        }
    }

    fn parse_line_number(&self, context: &str, token: &Token<'t>) -> Result<LineNumberRange> {
        let symbol = token.symbol.replace(' ', "");
        match symbol.parse::<LineNumberRange>() {
            Ok(number) => Ok(number),
            Err(error) => Err(miette!(BasicError::ParseLineNumber {
                context: context.to_owned(),
                input: FileSource::try_new(self.file_name.clone())?.into(),
                token: token.into()
            }))
            .wrap_err(miette!(error)),
        }
    }

    fn process_basic(&mut self, basic: &Basic<'t>) -> Result<()> {
        match basic {
            Basic::Basic0(b0) => self.process_lines(&b0.line, &b0.basic_list),
            Basic::Basic1(b1) => self.process_lines(&b1.line, &b1.basic_list),
        }
    }

    fn process_lines(
        &mut self,
        first_line: &Line<'t>,
        other_lines: &[BasicList<'t>],
    ) -> Result<()> {
        let lines = self.pre_process_lines(first_line, other_lines)?;
        self.interpret(&lines)
    }

    fn pre_process_lines<'a>(
        &mut self,
        first_line: &'a Line<'t>,
        other_lines: &'a [BasicList<'t>],
    ) -> Result<BasicLines<'a, 't>> {
        let context = "pre_process_lines";

        let mut lines = BasicLines::default();
        let (k, v) = self.pre_process_line(first_line)?;
        lines.lines.insert(k, v);

        for line in other_lines {
            let (k, v) = self.pre_process_line(&line.line)?;
            if lines.lines.insert(k, v).is_some() {
                return Err(miette!(BasicError::LineNumberDefinedTwice {
                    context: context.to_owned(),
                    input: FileSource::try_new(self.file_name.clone())?.into(),
                    token: (&line.line.line_number.line_number).into()
                }));
            }
        }

        // Add the follow relation
        self.next_line = None;
        lines.lines.iter_mut().rev().for_each(|(k, v)| {
            v.next_line = self.next_line;
            self.next_line = Some(*k);
        });

        // We need the last line only to be able to abort search for undefine destination in GOTO
        self.last_line = lines.lines.iter().rev().next().map(|l| *l.0);

        Ok(lines)
    }

    fn pre_process_line<'a>(
        &mut self,
        line: &'a Line<'t>,
    ) -> Result<(LineNumberRange, CompiledLine<'a, 't>)> {
        let context = "pre_process_line";
        let token = &line.line_number.line_number;
        let line_number = self.parse_line_number(context, token)?;
        if line_number > MAX_LINE_NUMBER {
            return Err(miette!(BasicError::LineNumberTooLarge {
                context: context.to_owned(),
                input: FileSource::try_new(self.file_name.clone())?.into(),
                token: token.into()
            }));
        }

        // On each line there can exist multiple statements separated by colons!
        let mut statements = vec![line.statement.as_ref()];

        line.line_list.iter().for_each(|statement| {
            statements.push(statement.statement.as_ref());
        });

        let compiled_line = CompiledLine {
            statements,
            next_line: None,
        };

        Ok((line_number, compiled_line))
    }

    fn interpret<'a>(&mut self, lines: &BasicLines<'a, 't>) -> Result<()> {
        while self.next_line.is_some() {
            self.interpret_line(lines)?;
        }
        Ok(())
    }

    fn interpret_line<'a>(&mut self, lines: &BasicLines<'a, 't>) -> Result<()> {
        if let Some(current_line) = lines.lines.get(&self.next_line.unwrap()) {
            self.next_line = current_line.next_line;
            let mut continue_statements = true;
            for statement in &current_line.statements {
                self.interpret_statement(statement, lines, &mut continue_statements)?;
                if !continue_statements {
                    break;
                }
            }
        } else {
        }
        Ok(())
    }

    fn interpret_statement<'a>(
        &mut self,
        statement: &'a Statement<'t>,
        lines: &BasicLines<'a, 't>,
        continue_statements: &mut bool,
    ) -> Result<()> {
        *continue_statements = true;
        match statement {
            Statement::Statement0(remark) => self.process_remark(remark),
            Statement::Statement1(goto) => {
                *continue_statements = false;
                self.process_goto(&goto.goto_statement.line_number.line_number, lines)
            }
            Statement::Statement2(if_statement) => {
                self.process_if_statement(if_statement, continue_statements, lines)
            }
            Statement::Statement3(assign) => self.process_assign(assign),
            Statement::Statement4(print_statement) => self.process_print_statement(print_statement),
            Statement::Statement5(end_statement) => {
                *continue_statements = false;
                self.process_end_statement(end_statement)
            }
        }
    }

    fn process_remark(&self, _remark: &Statement0) -> Result<()> {
        Ok(())
    }

    fn process_goto<'a>(&mut self, token: &Token<'t>, lines: &BasicLines<'a, 't>) -> Result<()> {
        let context = "process_goto";
        let mut line_number = self.parse_line_number(context, token)?;

        let last_line = self.last_line.unwrap();
        while !lines.lines.contains_key(&line_number) && line_number < last_line {
            // A GOTO statement targets a line that doesn't exist.
            // The Commodore BASIC defines that the execution is proceeded at the first
            // executable statement encountered after the given line number.
            line_number += 1;
            trace!("Trying next line: {line_number}");
        }

        if !lines.lines.contains_key(&line_number) {
            return Err(miette!(BasicError::LineNumberBeyondLastLine {
                context: context.to_owned(),
                input: FileSource::try_new(self.file_name.clone())?.into(),
                token: token.into()
            }));
        }

        trace!("{context}: setting next line to {line_number}");
        self.next_line = Some(line_number);
        Ok(())
    }

    fn process_if_statement<'a>(
        &mut self,
        if_statement: &'a Statement2<'t>,
        continue_statements: &mut bool,
        lines: &BasicLines<'a, 't>,
    ) -> Result<()> {
        let context = "process_if_statement";
        *continue_statements = true;
        let condition = self.process_expression(&*if_statement.if_statement.expression)?;
        trace!("{context}: condition: {condition}");
        if condition != 0.0 {
            match &*if_statement.if_statement.if_body {
                IfBody::IfBody0(then) => {
                    self.interpret_statement(&*then.statement, lines, continue_statements)
                }
                IfBody::IfBody1(goto) => self.process_goto(&goto.line_number.line_number, lines),
            }
        } else {
            Ok(())
        }
    }

    fn process_assign(&mut self, assign: &Statement3) -> Result<()> {
        let context = "process_assign";
        match &*assign.assignment {
            Assignment::Assignment0(Assignment0 {
                variable,
                expression,
                ..
            }) => {
                let value = self.process_expression(&*expression)?;
                let symbol = variable.variable.symbol;
                trace!("{context}: {symbol} = {value}");
                self.set_value(symbol, context, value)
            }
            Assignment::Assignment1(Assignment1 {
                variable,
                expression,
                ..
            }) => {
                let value = self.process_expression(&*expression)?;
                let symbol = variable.variable.symbol;
                trace!("{context}: {symbol} = {value}");
                self.set_value(symbol, context, value)
            }
        }
        Ok(())
    }

    fn process_print_statement(&mut self, print_statement: &Statement4) -> Result<()> {
        let value = self.process_expression(&*print_statement.print_statement.expression)?;
        print!("{value} ");
        for elem in &print_statement.print_statement.print_statement_list {
            let value = self.process_expression(&*elem.expression)?;
            print!("{value} ");
        }
        Ok(())
    }

    fn process_end_statement(&mut self, _end_statement: &Statement5) -> Result<()> {
        let context = "process_end_statement";
        trace!("{context}: setting next line to None");
        self.next_line = None;
        Ok(())
    }

    fn process_expression(&mut self, expression: &Expression) -> Result<DefinitionRange> {
        self.process_logical_or(&*expression.logical_or)
    }

    fn process_logical_or(&mut self, logical_or: &LogicalOr) -> Result<DefinitionRange> {
        let context = "process_logical_or";
        let mut result = self.process_logical_and(&logical_or.logical_and)?;
        for item in &logical_or.logical_or_list {
            let op: BinaryOperator = item.logical_or_op.logical_or_op.symbol.try_into()?;
            let next_operand = self.process_logical_and(&item.logical_and)?;
            result = BinaryOperator::apply_binary_operation(result, &op, next_operand, context)?;
        }
        Ok(result)
    }

    fn process_logical_and(&mut self, logical_and: &LogicalAnd) -> Result<DefinitionRange> {
        let context = "process_logical_and";
        let mut result = self.process_logical_not(&logical_and.logical_not)?;
        for item in &logical_and.logical_and_list {
            let op: BinaryOperator = item.logical_and_op.logical_and_op.symbol.try_into()?;
            let next_operand = self.process_logical_not(&item.logical_not)?;
            result = BinaryOperator::apply_binary_operation(result, &op, next_operand, context)?;
        }
        Ok(result)
    }

    fn process_logical_not(&mut self, logical_not: &LogicalNot) -> Result<DefinitionRange> {
        let context = "process_logical_not";
        match logical_not {
            LogicalNot::LogicalNot0(not) => {
                let result = self.process_relational(&*not.relational)?;
                let op: UnaryOperator = not.logical_not_op.logical_not_op.symbol.try_into()?;
                UnaryOperator::apply_unary_operation(&op, result, context)
            }
            LogicalNot::LogicalNot1(not) => self.process_relational(&*not.relational),
        }
    }

    fn process_relational(&mut self, relational: &Relational) -> Result<DefinitionRange> {
        let context = "process_relational";
        let mut result = self.process_summation(&*relational.summation)?;
        for item in &relational.relational_list {
            let op: BinaryOperator = item.relational_op.relational_op.symbol.try_into()?;
            let next_operand = self.process_summation(&*item.summation)?;
            result = BinaryOperator::apply_binary_operation(result, &op, next_operand, context)?;
        }
        Ok(result)
    }

    fn process_summation(&mut self, summation: &Summation) -> Result<DefinitionRange> {
        let context = "process_summation";
        let mut result = self.process_multiplication(&*summation.multiplication)?;
        for item in &summation.summation_list {
            let op: BinaryOperator = match &*item.summation_list_group {
                SummationListGroup::SummationListGroup0(plus) => plus.plus.plus.symbol.try_into(),
                SummationListGroup::SummationListGroup1(minus) => {
                    minus.minus.minus.symbol.try_into()
                }
            }?;
            let next_operand = self.process_multiplication(&*item.multiplication)?;
            result = BinaryOperator::apply_binary_operation(result, &op, next_operand, context)?;
        }
        Ok(result)
    }

    fn process_multiplication(
        &mut self,
        multiplication: &Multiplication,
    ) -> Result<DefinitionRange> {
        let context = "process_multiplication";
        let mut result = self.process_factor(&*multiplication.factor)?;
        for item in &multiplication.multiplication_list {
            let op: BinaryOperator = item.mul_op.mul_op.symbol.try_into()?;
            let next_operand = self.process_factor(&*item.factor)?;
            result = BinaryOperator::apply_binary_operation(result, &op, next_operand, context)?;
        }
        Ok(result)
    }

    fn process_factor(&mut self, factor: &Factor) -> Result<DefinitionRange> {
        let context = "process_factor";
        match factor {
            Factor::Factor0(Factor0 { literal }) => match &*literal.number {
                Number::Number0(flt) => match &*flt.float {
                    Float::Float0(float) => Ok(self.parse_number(context, &float.float1.float1)?),
                    Float::Float1(float) => Ok(self.parse_number(context, &float.float2.float2)?),
                },
                Number::Number1(int) => Ok(self.parse_number(context, &int.integer.integer)?),
            },
            Factor::Factor1(Factor1 { variable }) => self.value(context, &variable.variable),
            Factor::Factor2(Factor2 { factor, .. }) => Ok(-(self.process_factor(factor)?)),
            Factor::Factor3(Factor3 { expression, .. }) => self.process_expression(expression),
        }
    }
}

impl Display for Basic<'_> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::result::Result<(), Error> {
        write!(f, ":-)")
    }
}

impl Display for BasicGrammar<'_> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::result::Result<(), Error> {
        write!(
            f,
            "{}",
            self.env
                .iter()
                .map(|(k, v)| format!("{k}: {v}"))
                .collect::<Vec<String>>()
                .join(", ")
        )
    }
}

impl<'t> BasicGrammarTrait<'t> for BasicGrammar<'t> {
    fn init(&mut self, file_name: &Path) {
        self.file_name = file_name.into();
    }

    /// Semantic action for user production 0:
    ///
    /// Basic: [EndOfLine] Line {EndOfLine Line} [EndOfLine];
    ///
    fn basic(&mut self, basic: &Basic<'t>) -> Result<()> {
        self.process_basic(basic)
    }
}
